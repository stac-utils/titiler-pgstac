{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> <p>Connect PgSTAC and TiTiler.</p> </p> <p> </p> <p>Documentation: stac-utils.github.io/titiler-pgstac/</p> <p>Source Code: stac-utils/titiler-pgstac</p> <p>TiTiler-PgSTAC is a TiTiler extension that connects to a PgSTAC database to create dynamic mosaics based on search queries.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install from PyPI and run:</p> <pre><code># Make sure to have pip up to date\n$ python -m pip install -U pip\n\n# Install `psycopg` or `psycopg[\"binary\"]` or `psycopg[\"c\"]`\n$ python -m pip install psycopg[\"binary\"]\n\n$ python -m pip install titiler.pgstac\n</code></pre> <p>To install from sources and run for development:</p> <pre><code>$ git clone https://github.com/stac-utils/titiler-pgstac.git\n$ cd titiler-pgstac\n$ python -m pip install -e .\n</code></pre>"},{"location":"#pgstac-version","title":"<code>PgSTAC</code> version","text":"<p><code>titiler.pgstac</code> depends on <code>pgstac &gt;=0.3.4</code> (github.com/stac-utils/pgstac/blob/main/CHANGELOG.md#v034).</p>"},{"location":"#psycopg-requirement","title":"<code>psycopg</code> requirement","text":"<p><code>titiler.pgstac</code> depends on the <code>psycopg</code> library. Because there are three ways of installing this package (<code>psycopg</code> or , <code>psycopg[\"c\"]</code>, <code>psycopg[\"binary\"]</code>), the user must install this separately from <code>titiler.pgstac</code>.</p> <ul> <li><code>psycopg</code>: no wheel, pure python implementation. It requires the <code>libpq</code> installed in the system.</li> <li><code>psycopg[\"binary\"]</code>: binary wheel distribution (shipped with libpq) of the <code>psycopg</code> package and is simpler for development. It requires development packages installed on the client machine.</li> <li><code>psycopg[\"c\"]</code>: a C (faster) implementation of the libpq wrapper. It requires the <code>libpq</code> installed in the system.</li> </ul> <p><code>psycopg[c]</code> or <code>psycopg</code> are generally recommended for production use.</p> <p>In <code>titiler.pgstac</code> setup.py, we have added three options to let users choose which psycopg install to use:</p> <ul> <li><code>python -m pip install titiler.pgstac[\"psycopg\"]</code>: pure python</li> <li><code>python -m pip install titiler.pgstac[\"psycopg-c\"]</code>: use the C wrapper (requires development packages installed on the client machine)</li> <li><code>python -m pip install titiler.pgstac[\"psycopg-binary\"]</code>: binary wheels</li> </ul>"},{"location":"#launch","title":"Launch","text":"<p>You'll need to have <code>POSTGRES_USER</code>, <code>POSTGRES_PASS</code>, <code>POSTGRES_DBNAME</code>, <code>POSTGRES_HOST</code>, <code>POSTGRES_PORT</code> variables set in your environment pointing to your Postgres database where pgstac has been installed.</p> <pre><code>export POSTGRES_USER=username\nexport POSTGRES_PASS=password\nexport POSTGRES_DBNAME=postgis\nexport POSTGRES_HOST=database\nexport POSTGRES_PORT=5432\n</code></pre> <pre><code>$ python -m pip install uvicorn\n$ uvicorn titiler.pgstac.main:app --reload\n</code></pre>"},{"location":"#using-docker","title":"Using Docker","text":"<pre><code>$ git clone https://github.com/stac-utils/titiler-pgstac.git\n$ cd titiler-pgstac\n$ docker compose up --build tiler\n# or\n$ docker compose up --build tiler-uvicorn\n</code></pre>"},{"location":"#contribution-development","title":"Contribution &amp; Development","text":"<p>See CONTRIBUTING.md</p>"},{"location":"#license","title":"License","text":"<p>See LICENSE</p>"},{"location":"#authors","title":"Authors","text":"<p>See contributors for a listing of individual contributors.</p>"},{"location":"#changes","title":"Changes","text":"<p>See CHANGES.md.</p>"},{"location":"contributing/","title":"Development - Contributing","text":"<p>Issues and pull requests are more than welcome: github.com/stac-utils/titiler-pgstac/issues</p> <p>dev install</p> <pre><code>$ git clone https://github.com/stac-utils/titiler-pgstac.git\n$ cd titiler-pgstac\n$ python -m pip install -e \".[dev,test,psycopg]\"\n</code></pre> <p>You can then run the tests with the following command:</p> <pre><code>python -m pytest --cov titiler.pgstac --cov-report term-missing\n</code></pre> <p>This repo is set to use <code>pre-commit</code> to run isort, flake8, pydocstring, black (\"uncompromising Python code formatter\") and mypy when committing new code.</p> <pre><code>$ pre-commit install\n</code></pre>"},{"location":"intro/","title":"Intro","text":"<p>TiTiler.PgSTAC is a TiTiler extension, which create dynamic tiler connected to PgSTAC databases.</p> <p>By default the main application (<code>titiler.pgstac.main.app</code>) provides three sets of endpoints:</p> <ul> <li> <p><code>/searches/{search_id}</code>: Dynamic mosaic tiler based on PgSTAC Search Query</p> </li> <li> <p><code>/collections/{collection_id}</code>: Dynamic mosaic tiler based on STAC Collection</p> </li> <li> <p><code>/collections/{collection_id}/items/{item_id}</code>: Dynamic tiler for single STAC item (stored in PgSTAC)</p> </li> </ul> <p>Two other sets of endpoints can be enabled using environment variable:</p> <ul> <li> <p><code>/collections/{collection_id}/items/{item_id}/assets/{asset_id}</code>: Dynamic tiler of single STAC Asset (stored in PgSTAC), enabled setting <code>TITILER_PGSTAC_API_ENABLE_ASSETS_ENDPOINTS=TRUE</code></p> </li> <li> <p><code>/external</code>: Dynamic tiler of single Cloud Optimized dataset, enabled setting <code>TITILER_PGSTAC_API_ENABLE_EXTERNAL_DATASET_ENDPOINTS=TRUE</code></p> </li> </ul>"},{"location":"intro/#stac-searches-searchessearch_id","title":"STAC Searches - <code>/searches/{search_id}</code>","text":""},{"location":"intro/#register-a-pgstac-search-request","title":"Register a PgSTAC <code>Search</code> request","text":"<p>Important</p> <p>In <code>TiTiler.PgSTAC</code> a STAC <code>Search Query</code> is equivalent to a Virtual Mosaic and a PgSTAC <code>Search Hash</code> is equivalent to a Mosaic Identifier.</p> <p>Before being able to create Map Tiles, the user needs to register a <code>Search Query</code> within the PgSTAC database (in the <code>searches</code> table). By default, <code>TiTiler.PgSTAC</code> has a <code>/searches/register (POST)</code> endpoint which will:</p> <ul> <li> <p>validate the search query (based on the STAC API specification <code>item-search</code>)</p> </li> <li> <p>send the search query to the postgres database using the <code>search_query</code> PgSTAC function</p> </li> <li> <p>return a PgSTAC Search hash</p> </li> </ul> <p>Example</p> <pre><code>curl -X 'POST' 'http://127.0.0.1:8081/searches/register' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"collections\":[\"landsat-c2l2-sr\"], \"bbox\":[-123.75,34.30714385628804,-118.125,38.82259097617712], \"filter-lang\": \"cql-json\"}' | jq\n\n&gt;&gt; {\n  \"id\": \"5a1b82d38d53a5d200273cbada886bd7\",\n  \"links\": [\n    {\n      \"rel\": \"metadata\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/searches/5a1b82d38d53a5d200273cbada886bd7/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/searches/5a1b82d38d53a5d200273cbada886bd7/tilejson.json\"\n    }\n  ]\n}\n\n# Or using CQL-2\ncurl -X 'POST' 'http://127.0.0.1:8081/searches/register' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"filter\": {\"op\": \"and\", \"args\": [{\"op\": \"=\", \"args\": [{\"property\": \"collection\"}, \"landsat-c2l2-sr\"]}, {\"op\": \"s_intersects\", \"args\": [{\"property\": \"geometry\"}, {\"coordinates\": [[[-123.75, 34.30714385628804], [-123.75, 38.82259097617712], [-118.125, 38.82259097617712], [-118.125, 34.30714385628804], [-123.75, 34.30714385628804]]], \"type\": \"Polygon\"}]}]}}' | jq\n\n&gt;&gt; {\n  \"id\": \"5063721f06957d6b2320326d82e90d1e\",\n  \"links\": [\n    {\n      \"rel\": \"metadata\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/searches/5063721f06957d6b2320326d82e90d1e/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/searches/5063721f06957d6b2320326d82e90d1e/tilejson.json\"\n    }\n  ]\n}\n</code></pre> <pre><code>curl http://127.0.0.1:8081/searches/5063721f06957d6b2320326d82e90d1e/info | jq\n\n&gt;&gt; {\n  \"search\": {\n    \"hash\": \"5063721f06957d6b2320326d82e90d1e\",  # &lt;-- this is the PgSTAC Hash = search/mosaic identifier\n    \"search\": {  # &lt;-- Summary of the search request\n      \"filter\": {  # &lt;-- this is CQL2 filter associated with the search\n        \"op\": \"and\",\n        \"args\": [\n          {\n            \"op\": \"=\",\n            \"args\": [\n              {\n                \"property\": \"collection\"\n              },\n              \"landsat-c2l2-sr\"\n            ]\n          },\n          {\n            \"op\": \"s_intersects\",\n            \"args\": [\n              {\n                \"property\": \"geometry\"\n              },\n              {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                  [\n                    [\n                      -123.75,\n                      34.30714385628804\n                    ],\n                    [\n                      -123.75,\n                      38.82259097617712\n                    ],\n                    [\n                      -118.125,\n                      38.82259097617712\n                    ],\n                    [\n                      -118.125,\n                      34.30714385628804\n                    ],\n                    [\n                      -123.75,\n                      34.30714385628804\n                    ]\n                  ]\n                ]\n              }\n            ]\n          }\n        ]\n      }\n    },\n    \"_where\": \"(  ( (collection_id = 'landsat-c2l2-sr') and st_intersects(geometry, '0103000020E610000001000000050000000000000000F05EC055F6687D502741400000000000F05EC02D553EA94A6943400000000000885DC02D553EA94A6943400000000000885DC055F6687D502741400000000000F05EC055F6687D50274140'::geometry) )  )  \",  # &lt;-- internal pgstac WHERE expression\n    \"orderby\": \"datetime DESC, id DESC\",\n    \"lastused\": \"2022-03-03T11:44:55.878504+00:00\",  # &lt;-- internal pgstac variable\n    \"usecount\": 2,  # &lt;-- internal pgstac variable\n    \"metadata\": {  # &lt;-- titiler-pgstac Mosaic Metadata\n      \"type\": \"mosaic\"  # &lt;-- when we use the `/searches/register` endpoint, titiler-pgstac will add `type=mosaic` to the metadata\n    }\n  },\n  \"links\": [\n    {\n      \"rel\": \"self\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/searches/5063721f06957d6b2320326d82e90d1e/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/searches/5063721f06957d6b2320326d82e90d1e/tilejson.json\"\n    }\n  ]\n}\n</code></pre>"},{"location":"intro/#mosaic-metadata","title":"Mosaic Metadata","text":"<p>In addition to the <code>search query</code>, a user can pass <code>metadata</code>, which will be saved in the postgres table.</p> <pre><code>curl -X 'POST' 'http://127.0.0.1:8081/searches/register' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"collections\":[\"landsat-c2l2-sr\"], \"bbox\":[-123.75,34.30714385628804,-118.125,38.82259097617712], \"filter-lang\": \"cql-json\", \"metadata\": {\"minzoom\": 8, \"maxzoom\": 13, \"assets\": [\"B04\", \"B03\", \"B02\"], \"defaults\": {\"true_color\": {\"assets\": [\"B04\", \"B03\", \"B02\"], \"color_formula\": \"Gamma RGB 3.5 Saturation 1.7 Sigmoidal RGB 15 0.35\"}}}}' | jq\n\n&gt;&gt; {\n  \"id\": \"f31d7de8a5ddfa3a80b9a9dd06378db1\",\n  \"links\": [\n    {\n      \"rel\": \"metadata\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/searches/f31d7de8a5ddfa3a80b9a9dd06378db1/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/searches/f31d7de8a5ddfa3a80b9a9dd06378db1/tilejson.json\"\n    }\n  ]\n}\n\ncurl http://127.0.0.1:8081/searches/f31d7de8a5ddfa3a80b9a9dd06378db1/info | jq '.search.metadata'\n&gt;&gt; {\n  \"type\": \"mosaic\",\n  \"minzoom\": 8,\n  \"maxzoom\": 13,\n  \"assets\": [\n    \"B04\",\n    \"B03\",\n    \"B02\"\n  ],\n  \"defaults\": {\n    \"true_color\": {\n      \"assets\": [\n        \"B04\",\n        \"B03\",\n        \"B02\"\n      ],\n      \"color_formula\": \"Gamma RGB 3.5 Saturation 1.7 Sigmoidal RGB 15 0.35\"\n    }\n  }\n}\n</code></pre>"},{"location":"intro/#fetch-mosaic-tiles","title":"Fetch mosaic <code>Tiles</code>","text":"<p>When we have an id we can call the dynamic tiler and ask for Map Tiles.</p> <p></p> <p>How it works</p> <p>On each <code>Tile</code> request, the tiler api is going to call the PgSTAC <code>geometrysearch</code> function with the <code>id</code> and the <code>Tile geometry</code> to get the list of STAC Items (code). Then based on the <code>assets</code> parameter, the tiler will construct the tile image (code).</p> <p>Important</p> <p>Because <code>Tiles</code> will be created from STAC Items we HAVE TO pass <code>assets={stac asset}</code> option to the tile endpoint to tell the tiler which STAC assets has to be used.</p> <p>See full list of options</p> <p>Example</p> <pre><code>curl 'http://127.0.0.1:8081/searches/f1ed59f0a6ad91ed80ae79b7b52bc707/tiles/8/40/102.png?assets=B01&amp;rescale=0,16000 &gt; 8-40-102.png\n</code></pre>"},{"location":"intro/#stac-collection-collectionscollection_id","title":"STAC Collection - <code>/collections/{collection_id}</code>","text":"<p>No need for the user to <code>register</code> search queries for those endpoints. The tiler will automatically <code>register</code> a search query (<code>collection={collection_id}</code>).</p> <p>example</p> <pre><code>curl http://127.0.0.1:8081/collections/my-collection/tilejson.json?assets=data\n{\n  \"tilejson\": \"2.2.0\",\n  \"name\": \"Mosaic for 'my-collection' Collection\",\n  \"version\": \"1.0.0\",\n  \"scheme\": \"xyz\",\n  \"tiles\": [\n    \"http://127.0.0.1:8081/collections/my-collection/tiles/WebMercatorQuad/{z}/{x}/{y}?assets=data\"\n  ],\n  \"minzoom\": 0,\n  \"maxzoom\": 24,\n  \"bounds\": [\n    -180,\n    -90,\n    180,\n    90\n  ],\n  \"center\": [\n    0,\n    0,\n    0\n  ]\n}\n</code></pre>"},{"location":"intro/#stac-item-collectionscollection_iditemsitem_id","title":"STAC Item - <code>/collections/{collection_id}/items/{item_id}</code>","text":"<p><code>titiler-pgstac</code> can also be used to access individual item stored in the PgSTAC database. By default the <code>titiler-pgstac</code> application will have a set of <code>/collections/{collection_id}/items/{item_id}/...</code> endpoints. The endpoints are created using titiler.core.factory.MultiBaseTilerFactory but using a custom <code>path_dependency</code> with <code>collection_id</code> and <code>item_id</code> path parameters instead of the STAC url as query parameter.</p> <p>example</p> <pre><code>curl http://127.0.0.1:8081/collections/world/items/world_20000_5000/info | jq\n{\n  \"asset\": {\n    \"bounds\": [\n      153.5000000000667,\n      -76.83333333336668,\n      179.8333333334053,\n      6.4999999999833165\n    ],\n    \"minzoom\": 3,\n    \"maxzoom\": 6,\n    \"band_metadata\": [\n      [\n        \"b1\",\n        {}\n      ],\n      [\n        \"b2\",\n        {}\n      ],\n      [\n        \"b3\",\n        {}\n      ]\n    ],\n    \"band_descriptions\": [\n      [\n        \"b1\",\n        \"\"\n      ],\n      [\n        \"b2\",\n        \"\"\n      ],\n      [\n        \"b3\",\n        \"\"\n      ]\n    ],\n    \"dtype\": \"uint8\",\n    \"nodata_type\": \"None\",\n    \"colorinterp\": [\n      \"red\",\n      \"green\",\n      \"blue\"\n    ],\n    \"driver\": \"GTiff\",\n    \"count\": 3,\n    \"width\": 1580,\n    \"height\": 5000,\n    \"overviews\": [\n      2,\n      4,\n      8,\n      16\n    ]\n  }\n}\n</code></pre> <p>See full list of endpoints</p>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#unreleased","title":"Unreleased","text":""},{"location":"release-notes/#190-2025-09-23","title":"1.9.0 (2025-09-23)","text":"<ul> <li> <p>update titiler requirement to <code>&gt;=0.24,&lt;0.25</code></p> <ul> <li>add OpenTelemetry instrumentation to the tiler factory classes</li> <li>fix layer's bounds for non-wgs84 CRS in WMTS document</li> <li>refactor HTML templating</li> <li>remove python 3.9 support </li> </ul> </li> <li> <p>switch from bitnami to official python:3.12 docker image</p> </li> </ul>"},{"location":"release-notes/#180-2025-05-12","title":"1.8.0 (2025-05-12)","text":"<ul> <li>update titiler requirement to <code>&gt;=0.22,&lt;0.23</code></li> <li>add <code>/conformance</code> endpoint</li> <li>use HTML templates for landing page from <code>titiler.core</code></li> <li>add <code>query</code> and <code>sortby</code> options to <code>/collections</code></li> <li>update input types for <code>dependencies.get_collection_id</code> function  breaking change<ul> <li><code>ids</code>: <code>List[str]</code> -&gt; <code>str</code></li> <li><code>bbox</code>: <code>List[float]</code> -&gt; <code>str</code></li> </ul> </li> </ul>"},{"location":"release-notes/#172-2025-04-03","title":"1.7.2 (2025-04-03)","text":"<ul> <li>fix Landing page links when app is behind proxy</li> </ul>"},{"location":"release-notes/#171-2025-03-04","title":"1.7.1 (2025-03-04)","text":"<ul> <li>remove <code>PostgresSettings</code> initialization from <code>main.py</code></li> </ul>"},{"location":"release-notes/#170-2025-02-13","title":"1.7.0 (2025-02-13)","text":"<ul> <li>update titiler requirement to <code>&gt;=0.21,&lt;0.22</code></li> <li>use <code>URN</code> style CRS notation in WMTS document</li> <li> <p>Unify Docker images (deprecate <code>uvicorn-*</code> tags)</p> <pre><code># Uvicorn\n# before\ndocker run \\\n    --platform=linux/amd64 \\\n    -p 8000:8000 \\\n    --env PORT=8000 \\\n    --env DATABASE_URL=postgresql://username:password@0.0.0.0:5439/postgis \\\n    --rm -it ghcr.io/stac-utils/titiler-pgstac:uvicorn-latest\n\n# now\ndocker run \\\n    --platform=linux/amd64 \\\n    -p 8000:8000 \\\n    --env DATABASE_URL=postgresql://username:password@0.0.0.0:5439/postgis \\\n    --rm -it ghcr.io/stac-utils/titiler-pgstac:latest \\\n    uvicorn titiler.pgstac.main:app --host 0.0.0.0 --port 8000 --workers 1\n\n# Gunicorn\n# before\ndocker run \\\n    --platform=linux/amd64 \\\n    -p 8000:8000 \\\n    --env PORT=8000 \\\n    --env DATABASE_URL=postgresql://username:password@0.0.0.0:5439/postgis \\\n    --rm -it ghcr.io/stac-utils/titiler-pgstac:latest\n\n# now\ndocker run \\\n    --platform=linux/amd64 \\\n    -p 8000:8000 \\\n    --env DATABASE_URL=postgresql://username:password@0.0.0.0:5439/postgis \\\n    --rm -it ghcr.io/stac-utils/titiler-pgstac:latest \\\n    gunicorn -k uvicorn.workers.UvicornWorker titiler.pgstac.main:app --bind 0.0.0.0:8000 --workers 1\n</code></pre> </li> </ul>"},{"location":"release-notes/#160-2025-01-13","title":"1.6.0 (2025-01-13)","text":"<ul> <li> <p>remove <code>rescale_dependency</code> and <code>color_formula_dependency</code> attributes in TilerFactory class breaking change</p> </li> <li> <p>add <code>render_func: Callable[..., Tuple[bytes, str]] = render_image</code> attribute in TilerFactory class</p> </li> <li> <p>update <code>/healthz</code> endpoint to return dependencies versions (titiler, rasterio, gdal, ...)</p> </li> <li> <p>migrate <code>templates/index.html</code> to bootstrap5, remove unused css, reuse bs classes</p> </li> <li> <p>Updated WMTS endpoint to return layer bounds in coordinate ordering matching CRS order if WGS84 is not used</p> </li> <li> <p>Update package build backend from <code>pdm-pep517</code> to <code>pdm-backend</code> (backend.pdm-project.org/#migrate-from-pdm-pep517)</p> </li> <li> <p>Update namespace package from using <code>.</code> to <code>-</code> as separator to comply with PEP-625 (peps.python.org/pep-0625/)</p> </li> <li> <p>Remove <code>python3.8</code> support</p> </li> <li> <p>Add <code>python3.13</code> support</p> </li> </ul>"},{"location":"release-notes/#150-2024-11-28","title":"1.5.0 (2024-11-28)","text":"<ul> <li> <p>update titiler requirement to <code>&gt;=0.19.0,&lt;0.20</code></p> </li> <li> <p>Use <code>@attrs.define</code> instead of dataclass for factories breaking change</p> </li> <li> <p>Remove default <code>WebMercatorQuad</code> tile matrix set in <code>/tiles</code>, <code>/tilesjson.json</code>, <code>/map</code> and <code>/WMTSCapabilities.xml</code> endpoints breaking change</p> <pre><code># Before\n/tiles/{z}/{x}/{y}\n/tilejson.json\n/map\n/WMTSCapabilities.xml\n\n# Now\n/tiles/WebMercatorQuad/{z}/{x}/{y}\n/WebMercatorQuad/tilejson.json\n/WebMercatorQuad/map\n/WebMercatorQuad/WMTSCapabilities.xml\n</code></pre> </li> <li> <p>Use <code>.as_dict()</code> method when passing option to rio-tiler Reader's methods to avoid parameter conflicts when using custom Readers.</p> </li> <li> <p>add OGC Tiles <code>/tiles</code> and <code>/tiles/{tileMatrixSet}</code> endpoints</p> </li> <li> <p>add <code>/point</code> prefix to <code>/{lon},{lat}/assets</code> endpoint breaking change</p> </li> <li> <p>rename <code>reader</code> attribute to <code>backend</code> in <code>MosaicTilerFactory</code> breaking change</p> </li> <li> <p>rename <code>titiler/pgstac/mosaic.py \u2192 titiler/pgstac/backend.py</code> breaking change</p> </li> <li> <p>rename <code>titiler.pgstac.mosaic.CustomSTACReader \u2192 titiler.pgstac.reader.SimpleSTACReader</code> breaking change</p> </li> <li> <p>rename factory's method to match the one from <code>titiler.core/titiler.mosaic</code> breaking change</p> </li> <li> <p>split <code>_assets_routes</code> into <code>assets_tile</code> and <code>assets_point</code> breaking change</p> </li> </ul>"},{"location":"release-notes/#140-2024-09-06","title":"1.4.0 (2024-09-06)","text":"<ul> <li>add <code>/collections/{collection_id}/items/{item_id}/assets/{asset_id}</code> optional endpoints (<code>TITILER_PGSTAC_API_ENABLE_ASSETS_ENDPOINTS=TRUE|FALSE</code>)</li> <li>add <code>/external</code> optional endpoints (<code>TITILER_PGSTAC_API_ENABLE_EXTERNAL_DATASET_ENDPOINTS=TRUE|FALSE</code>)</li> <li>add <code>cachecontrol_exclude_paths</code> attribute in <code>ApiSettings</code> to let users decide if some path should not have cache-control headers (defaults is to exclude <code>/list</code>)</li> <li>add <code>PgstacSettings</code> such that the user can provide their own default settings for PgSTAC search</li> <li>add check for pgstac <code>read-only</code> mode and raise <code>ReadOnlyPgSTACError</code> error when trying to write to the pgstac instance</li> <li>add <code>/pgstac</code> endpoint in the application (when <code>TITILER_PGSTAC_API_DEBUG=TRUE</code>)</li> <li>add <code>ids</code>, <code>bbox</code> and <code>datetime</code> options to the <code>/collections/{collection_id}</code> endpoints</li> </ul>"},{"location":"release-notes/#131-2024-08-01","title":"1.3.1 (2024-08-01)","text":"<ul> <li>update models to avoid pydantic deprecation</li> <li>update <code>searches</code> model for pgstac&gt;=9.1</li> <li>update psycopg error catching when <code>search</code> doesn't exist</li> </ul>"},{"location":"release-notes/#130-2024-05-17","title":"1.3.0 (2024-05-17)","text":"<ul> <li>update titiler requirement to <code>&gt;=0.18.0,&lt;0.19</code></li> <li>Add <code>/colorMaps</code> endpoints to the application</li> <li> <p>Deprecation remove default <code>WebMercatorQuad</code> tile matrix set in <code>/tiles</code>, <code>/tilesjson.json</code>, <code>/map</code>, <code>/WMTSCapabilities.xml</code> and <code>/assets</code> endpoints</p> <pre><code># Before\n/tiles/{z}/{x}/{y}\n/tilejson.json\n/map\n/WMTSCapabilities.xml\n\n# Now\n/tiles/WebMercatorQuad/{z}/{x}/{y}\n/WebMercatorQuad/tilejson.json\n/WebMercatorQuad/map\n/WebMercatorQuad/WMTSCapabilities.xml\n</code></pre> </li> <li> <p>update <code>titiler.pgstac.model.Link</code> to match the OGC specification</p> </li> <li>use <code>{tileMatrixSetId}</code> in templated URL links</li> <li>add support for <code>render</code> and <code>item-assets</code> STAC Collection extensions for the <code>STAC Collections</code> info and wmts endpoints</li> <li>add <code>/info</code> endpoint to the <code>STAC Collections</code> endpoints</li> <li>add <code>/collections</code> and <code>/collections/{collection_id}</code> endpoints when <code>TITILER_PGSTAC_API_DEBUG=TRUE</code></li> <li> <p>Expect the <code>Metadata.defaults</code> configurations to follow the STAC <code>render</code> extension (stac-extensions/render)</p> <pre><code>    // before\n    \"blue\": {\n        \"rescale\": [\"0,100\"],\n        \"assets\": \"b1\",\n    }\n\n    // now\n    \"blue\": {\n        \"rescale\": [[0, 100]],\n        \"assets\": [\"b1\"],\n    }\n</code></pre> </li> </ul>"},{"location":"release-notes/#123-2024-03-25","title":"1.2.3 (2024-03-25)","text":"<ul> <li>add python 3.12 support</li> <li>Add <code>extra=\"ignore\"</code> option <code>CacheSettings</code> to fix pydantic issue when using <code>.env</code> file</li> </ul>"},{"location":"release-notes/#122-2024-02-21","title":"1.2.2 (2024-02-21)","text":"<ul> <li>enable passing <code>ConnectionPool</code> kwargs option in <code>titiler.pgstac.db.connect_to_db</code> function (author @smohiudd, stac-utils/titiler-pgstac!155)</li> </ul>"},{"location":"release-notes/#121-2024-01-19","title":"1.2.1 (2024-01-19)","text":"<ul> <li>fix invalid url parsing in HTML responses</li> </ul>"},{"location":"release-notes/#120-2024-01-17","title":"1.2.0 (2024-01-17)","text":"<ul> <li>update titiler requirement to <code>&gt;=0.17.0,&lt;0.18</code></li> <li>use new <code>align_bounds_with_dataset=True</code> rio-tiler option in GeoJSON statistics methods for more precise calculation</li> </ul>"},{"location":"release-notes/#110-2024-01-10","title":"1.1.0 (2024-01-10)","text":"<ul> <li>update titiler requirement to <code>&gt;=0.16.0,&lt;0.17</code></li> <li>use morecantile <code>TileMatrixSet.cellSize</code> property instead of deprecated/private <code>TileMatrixSet._resolution</code> method (author @hrodmn, stac-utils/titiler-pgstac!148)</li> <li>add <code>/point/{lon},{lat}</code> endpoint in <code>MosaicTilerFactory</code> (co-author @hrodmn, stac-utils/titiler-pgstac!150)</li> </ul>"},{"location":"release-notes/#100-2023-12-12","title":"1.0.0 (2023-12-12)","text":"<ul> <li>no change since <code>1.0.0a4</code></li> </ul>"},{"location":"release-notes/#100a4-2023-11-10","title":"1.0.0a4 (2023-11-10)","text":"<ul> <li>add <code>algorithm</code> options for <code>/statistics [POST]</code> endpoints (back-ported from 0.8.1)</li> </ul>"},{"location":"release-notes/#100a3-2023-11-03","title":"1.0.0a3 (2023-11-03)","text":"<ul> <li>remove <code>reverse</code> option in <code>PGSTACBackend</code> mosaic backend. Reverse item order should be achieved with STAC search sortby.</li> </ul>"},{"location":"release-notes/#100a2-2023-11-02","title":"1.0.0a2 (2023-11-02)","text":"<ul> <li>update titiler's dependency to <code>&gt;=0.15.2,&lt;0.16</code></li> <li>rename <code>dependencies.TileParams</code> to <code>dependencies.TmsTileParams</code></li> </ul>"},{"location":"release-notes/#100a1-2023-10-20","title":"1.0.0a1 (2023-10-20)","text":"<ul> <li>rename <code>dependencies.ItemPathParams</code> to <code>ItemIdParams</code> breaking change</li> </ul>"},{"location":"release-notes/#100a0-2023-10-20","title":"1.0.0a0 (2023-10-20)","text":"<ul> <li> <p>add <code>pgstac_dependency</code> attribute in <code>MosaicTilerFactory</code> (defaults to <code>dependencies.PgSTACParams</code>)</p> </li> <li> <p>add database's <code>pool</code> check in startup event</p> </li> <li> <p>add metadata layers links in mosaic's <code>/info</code> response for TileJSON, map and wmts endpoint links</p> </li> <li> <p>add <code>CollectionIdParams</code> dependency to retrieve a SearchId for a CollectionId</p> </li> <li> <p>add <code>/collections/{collection_id}</code> virtual mosaic endpoints</p> </li> <li> <p>update endpoints Tags (<code>STAC Search</code>, <code>STAC Collection</code>, <code>STAC Item</code>)</p> </li> </ul>"},{"location":"release-notes/#endpoint-breaking-changes","title":"Endpoint breaking changes","text":"<ul> <li> <p>move PgSTAC Search Virtual Mosaic's endpoints from <code>/mosaic</code> to <code>/searches</code></p> </li> <li> <p>in <code>model.RegisterResponse</code> (model used in <code>/register</code> endpoint) rename <code>searchid</code> by <code>id</code></p> <pre><code># before\nresp = httpx.post(\"/mosaic/register\", body={\"collections\": [\"my-collection\"], \"filter-lang\": \"cql-json\"})\nassert resp.json()[\"searchid\"]\n\n# now\nresp = httpx.post(\"/searches/register\", body={\"collections\": [\"my-collection\"], \"filter-lang\": \"cql-json\"})\nassert resp.json()[\"id\"]\n</code></pre> </li> </ul>"},{"location":"release-notes/#api-breaking-changes","title":"API breaking changes","text":"<ul> <li> <p>rename <code>dependencies.PathParams</code> to <code>dependencies.SearchIdParams</code></p> </li> <li> <p>rename <code>searchid</code> path parameter to <code>search_id</code> in <code>SearchIdParams</code></p> </li> <li> <p>move <code>check_query_params</code> methods outside <code>MosaicTilerFactory</code> class</p> </li> <li> <p>make <code>path_dependency</code> a required input to <code>MosaicTilerFactory</code> class</p> <pre><code># before\napp = FastAPI()\nmosaic = MosaicTilerFactory(...)\napp.include_router(mosaic.router)\n\n# now\napp = FastAPI()\nmosaic = MosaicTilerFactory(\n    ...,\n    path_dependency=lambda: \"aaaaaaaaaaaaaa\"\n)\napp.include_router(mosaic.router)\n</code></pre> </li> <li> <p>remove <code>/{search_id}</code> prefix in <code>MosaicTilerFactory</code> routes. Now use parameter injection from global prefix</p> <pre><code># Before\napp = FastAPI()\nmosaic = MosaicTilerFactory(\n    ...,\n    router_prefix=\"/mosaics\"\n)\napp.include_router(mosaic.router, prefix=\"/mosaics\")\n\n# Now\napp = FastAPI()\nmosaic = MosaicTilerFactory(\n    ...\n    router_prefix=\"/mosaics/{search_id}\"\n)\napp.include_router(mosaic.router, prefix=\"/mosaics/{search_id}\")\n</code></pre> </li> <li> <p>move <code>/info</code> endpoint outside the <code>MosaicTilerFactory</code> to its own extension (<code>titiler.pgstac.extension.searchInfoExtension</code>)</p> <pre><code># Before\napp = FastAPI()\nmosaic = MosaicTilerFactory(...)\napp.include_router(mosaic.router)\n\n# Now\napp = FastAPI()\nmosaic = MosaicTilerFactory(\n    ...\n    extensions=[\n        searchInfoExtension(),\n    ]\n)\napp.include_router(mosaic.router)\n</code></pre> </li> <li> <p>move <code>/register</code> and <code>/list</code> endpoint creation outside the <code>MosaicTilerFactory</code> class</p> <pre><code># before\nfrom titiler.pgstac.factory import MosaicTilerFactory\n\nmosaic = MosaicTilerFactory(\n    ...,\n    router_prefix=\"/{search_id}\",\n)\napp.include_router(mosaic.router, prefix=\"/{search_id}\")\n\n# Now\nfrom titiler.pgstac.factory import (\n    MosaicTilerFactory,\n    add_search_register_route,\n    add_mosaic_register_route,\n)\n\nmosaic = MosaicTilerFactory(\n    ...,\n    router_prefix=\"/{search_id}\",\n)\napp.include_router(mosaic.router, prefix=\"/{search_id}\")\n\n# add /register endpoint\nadd_search_register_route(\n    app,\n    # any dependency we want to validate\n    # when creating the tilejson/map links\n    tile_dependencies=[\n        mosaic.layer_dependency,\n        mosaic.dataset_dependency,\n        mosaic.pixel_selection_dependency,\n        mosaic.process_dependency,\n        mosaic.rescale_dependency,\n        mosaic.colormap_dependency,\n        mosaic.render_dependency,\n        mosaic.pgstac_dependency,\n        mosaic.reader_dependency,\n        mosaic.backend_dependency,\n    ],\n)\n# add /list endpoint\nadd_search_list_route(app)\n</code></pre> </li> </ul>"},{"location":"release-notes/#083-2024-02-21","title":"0.8.3 (2024-02-21)","text":"<ul> <li>enable passing <code>ConnectionPool</code> kwargs option in <code>titiler.pgstac.db.connect_to_db</code> function (author @smohiudd, #155) [backported from 1.2.2]</li> </ul>"},{"location":"release-notes/#082-2024-01-23","title":"0.8.2 (2024-01-23)","text":"<ul> <li>update rio-tiler version to <code>&gt;6.3.0</code> (defined in <code>titiler&gt;=0.17</code>)</li> <li>use new <code>align_bounds_with_dataset=True</code> rio-tiler option in GeoJSON statistics methods for more precise calculation [backported from 1.2.0]</li> <li>use morecantile <code>TileMatrixSet.cellSize</code> property instead of deprecated/private TileMatrixSet._resolution method [backported from 1.1.0]</li> </ul>"},{"location":"release-notes/#081-2023-11-10","title":"0.8.1 (2023-11-10)","text":"<ul> <li>add <code>algorithm</code> options for <code>/statistics [POST]</code> endpoints</li> </ul>"},{"location":"release-notes/#080-2023-10-06","title":"0.8.0 (2023-10-06)","text":"<ul> <li>update titiler requirement to <code>&gt;=0.15.0,&lt;0.16</code></li> <li>remove <code>max_size</code> default for mosaic's <code>/statistics [POST]</code> endpoint  breaking change</li> <li>add <code>/bbox</code> and <code>/feature [POST]</code> optional endpoints</li> <li>add <code>img_part_dependency</code> attribute in <code>MosaicTilerFactory</code> (defaults to <code>titiler.code.dependencies.PartFeatureParams</code>)</li> </ul>"},{"location":"release-notes/#070-2023-09-28","title":"0.7.0 (2023-09-28)","text":"<ul> <li>update requirements to switch to pydantic~=2.0</li> <li>pydantic&gt;=2.4,&lt;3.0</li> <li>pydantic-settings~=2.0</li> <li>geojson-pydantic~=1.0</li> <li> <p>cogeo-mosaic&gt;=7.0,&lt;8.0</p> </li> <li> <p>update titiler requirement to <code>&gt;=0.14.0,&lt;0.15</code></p> <ul> <li> <p>replace <code>-</code> by <code>_</code> in query parameters</p> <ul> <li>coord-crs -&gt; coord_crs</li> <li>dst-crs -&gt; dst_crs</li> </ul> </li> </ul> </li> </ul>"},{"location":"release-notes/#060-2023-09-18","title":"0.6.0 (2023-09-18)","text":"<ul> <li>add <code>tilejson</code> URL links for <code>layers</code> defined in mosaic's metadata in <code>/mosaic/register</code> and <code>/mosaic/{mosaic_id}/info</code> response</li> <li>support multiple <code>layers</code> in <code>/mosaic/{mosaic_id}/WMTSCapabilities.xml</code> endpoint created from mosaic's metadata</li> </ul> <p>breaking change</p> <ul> <li> <p>In <code>/mosaic/WMTSCapabilities.xml</code> we removed the query-parameters related to the <code>tile</code> endpoint (which are forwarded) so <code>?assets=</code> is no more required. The endpoint will still raise an error if there are no <code>layers</code> in the mosaic metadata and no required tile's parameters are passed.</p> <pre><code># before\nresponse = httpx.get(\"/mosaic/{mosaic_id}/WMTSCapabilities.xml\")\nassert response.status_code == 400\n\nresponse = httpx.get(\"/mosaic/{mosaic_id}/WMTSCapabilities.xml?assets=cog\")\nassert response.status_code == 200\n\n# now\n# If the mosaic has `defaults` layers set in the metadata\n# we will construct a WMTS document with multiple layers, so no need for the user to pass any `assets=`\nresponse = httpx.get(\"/mosaic/{mosaic_id}/WMTSCapabilities.xml\")\nassert response.status_code == 200\nwith rasterio.open(io.BytesIO(response.content)) as src:\n    assert src.profile[\"driver\"] == \"WMTS\"\n    assert len(src.subdatasets) == 2\n\n# If the user pass any valid `tile` parameters, an additional layer will be added to the one from the metadata\nresponse = httpx.get(\"/mosaic/{mosaic_id}/WMTSCapabilities.xml?assets=cog\")\nassert response.status_code == 200\nwith rasterio.open(io.BytesIO(response.content)) as src:\n    assert src.profile[\"driver\"] == \"WMTS\"\n    assert len(src.subdatasets) == 3\n</code></pre> </li> </ul>"},{"location":"release-notes/#051-2023-08-03","title":"0.5.1 (2023-08-03)","text":"<ul> <li>add <code>python-dotenv</code> requirement</li> </ul>"},{"location":"release-notes/#050-2023-07-20","title":"0.5.0 (2023-07-20)","text":"<ul> <li>update <code>titiler</code> requirement to <code>&gt;=0.12.0,&lt;0.13</code></li> <li>use <code>Annotated</code> Type for Query/Path parameters</li> <li>re-order endpoints in <code>MosaicTilerFactory</code> to avoid conflicts between <code>tiles</code> and <code>assets</code> endpoints</li> <li>remove <code>stac-pydantic</code> dependency</li> <li>add optional <code>root_path</code> setting to specify a url path prefix to use when running the app behind a reverse proxy</li> <li>add landing page <code>/</code></li> <li>use <code>lifespan</code> option instead of deprecated <code>@app.on_event</code> method to initiate/close DB connection</li> </ul> <p>breaking changes</p> <ul> <li>remove deprecated <code>/{searchid}/{z}/{x}/{y}/assets</code> endpoints</li> <li>use /api and /api.html for documentation (instead of /openapi.json and /docs)</li> <li>replace Enum's with <code>Literal</code> types</li> <li>replace variable <code>TileMatrixSetId</code> by <code>tileMatrixSetId</code></li> <li>add <code>pixel_selection_dependency</code> attribute to the <code>MosaicTilerFactory</code></li> </ul>"},{"location":"release-notes/#041-2023-06-21","title":"0.4.1 (2023-06-21)","text":"<ul> <li>update <code>titiler</code> requirement to <code>&gt;=0.11.7</code></li> <li>fix <code>/map</code> endpoint template name</li> <li>rename <code>add_map_viewer</code> to <code>add_viewer</code> option in <code>MosaicTilerFactory</code> for consistency with <code>titiler's</code> options</li> </ul>"},{"location":"release-notes/#040-2023-05-22","title":"0.4.0 (2023-05-22)","text":"<ul> <li>remove deprecated <code>/tiles/{searchid}/...</code> endpoints (replaced with <code>/{searchid}/tiles/...</code>)</li> <li>depreciate <code>/{searchid}/{z}/{x}/{y}/assets</code> endpoints and add <code>/{searchid}/tiles/{z}/{x}/{y}/assets</code></li> <li>update minimum titiler requirement to <code>&gt;=0.11.6</code></li> <li>remove timing headers</li> <li>add <code>strict_zoom</code> option (controled with <code>MOSAIC_STRICT_ZOOM</code> environment variable) to raise (or not) error when fetching tile outside mosaic min/max zoom range</li> </ul>"},{"location":"release-notes/#033-2023-04-27","title":"0.3.3 (2023-04-27)","text":"<ul> <li>update python packaging/build system to <code>pdm-pep517</code></li> <li>use <code>Ruff</code> for lint</li> <li>add retry mechanism on Database connection issues for <code>PGSTACBackend.get_assets()</code> and <code>get_stac_item</code> methods (back ported from 0.2.4)</li> </ul>"},{"location":"release-notes/#032-2023-03-14","title":"0.3.2 (2023-03-14)","text":"<ul> <li>update titiler requirement to <code>0.10.2</code></li> <li>fix maximum version of FastAPI to 0.92 (to avoid breaking change of starlette &gt;0.25)</li> </ul>"},{"location":"release-notes/#031-2022-12-16","title":"0.3.1 (2022-12-16)","text":"<ul> <li>update Type information for <code>dependencies.get_stac_item</code> (back ported from 0.2.2)</li> </ul>"},{"location":"release-notes/#030-2022-12-16","title":"0.3.0 (2022-12-16)","text":"<p>breaking changes</p> <ul> <li> <p>Use <code>/collections/{collection_id}/items/{item_id}</code> prefix for Item endpoint.     <pre><code># Before\n{endpoint}/stac/info?collection=collection1&amp;item=item1\n\n# Now\n{endpoint}/collections/collection1/items/item1/info\n</code></pre></p> </li> <li> <p>Change tile url path parameter order from <code>/tiles/{searchid}/{TileMatrixSetId}/{z}/{x}/{y}</code> to <code>/{searchid}/tiles/{TileMatrixSetId}/{z}/{x}/{y}</code> <pre><code># Before\n{endpoint}/mosaic/tiles/20200307aC0853900w361030/0/0/0\n\n# Now\n{endpoint}/mosaic/20200307aC0853900w361030/tiles/0/0/0\n</code></pre></p> </li> </ul>"},{"location":"release-notes/#024-2023-04-27","title":"0.2.4 (2023-04-27)","text":"<ul> <li>add retry mechanism on Database connection issues for <code>PGSTACBackend.get_assets()</code> and <code>get_stac_item</code> methods</li> </ul>"},{"location":"release-notes/#023-2023-03-14","title":"0.2.3 (2023-03-14)","text":"<ul> <li>fix maximum version of FastAPI to 0.92 (to avoid breaking change of starlette &gt;0.25)</li> </ul>"},{"location":"release-notes/#022-2022-12-16","title":"0.2.2 (2022-12-16)","text":"<ul> <li>update Type information for <code>dependencies.get_stac_item</code></li> </ul>"},{"location":"release-notes/#021-2022-12-15","title":"0.2.1 (2022-12-15)","text":"<ul> <li>update titiler requirement to <code>&gt;=0.10.1,&lt;0.11</code> and fix <code>/map</code> endpoint (to accept multiple TMS)</li> </ul>"},{"location":"release-notes/#020-2022-12-13","title":"0.2.0 (2022-12-13)","text":"<ul> <li>add python 3.10 and 3.11 support</li> <li>update to rio-tiler 4.1</li> <li>add <code>/{searchid}/map</code> endpoint to the <code>MosaicTilerFactory</code> (added when <code>add_map_viewer</code> is set to <code>True</code>)</li> <li>add <code>/{searchid}/WMTSCapabilities.xml</code> OGC WMTS endpoint to the <code>MosaicTilerFactory</code></li> <li>add <code>/list</code> to the <code>MosaicTilerFactory</code> to list available mosaics (added when <code>add_mosaic_list</code> is set to <code>True</code>)</li> </ul> <p>breaking changes</p> <ul> <li>remove python 3.7 support</li> <li>update titiler requirement to <code>&gt;=0.10.0</code></li> <li>replace <code>connection_string</code> by <code>database_url</code> in <code>settings.PostgresSettings</code>. We can now directly set <code>DATABASE_URL</code> environment variable.</li> </ul>"},{"location":"release-notes/#frontend-changes","title":"Frontend changes","text":"<ul> <li>remove <code>asset_expression</code> (Mosaic and Item)</li> <li>histogram band names are prefixed with <code>b</code> (e.g <code>b1</code>) (Mosaic and Item) (ref: github.com/cogeotiff/rio-tiler/blob/main/docs/src/v4_migration.md#band-names)</li> <li>expression for STAC have to be in form of <code>{asset}_b{band_name}</code> (e.g <code>red_b1/green_b1</code>) (Mosaic and Item) (ref: github.com/cogeotiff/rio-tiler/blob/main/docs/src/v4_migration.md#multibasereader-expressions)</li> <li>added <code>asset_as_band</code> option to force expression to be in form of <code>{asset}</code> (e.g <code>red/green</code>) (Mosaic and Item)</li> <li>expression's band should now be delimited with <code>;</code> (previously <code>,</code> was accepted) (Mosaic and Item)</li> <li>point output model to include band_names (Item)</li> <li>added <code>algorithm</code> options</li> </ul>"},{"location":"release-notes/#010-2022-06-27","title":"0.1.0 (2022-06-27)","text":"<ul> <li>update <code>titiler.core</code> and <code>titiler.mosaic</code> requirement to <code>0.7</code></li> <li>add <code>MosaicTilerFactory._tilejson_routes</code> method to register <code>TileJSON</code> routes</li> <li>raise <code>cogeo_mosaic.errors.MosaicNotFoundError</code> when SearchId is not found in pgstac.searches table</li> </ul> <p>breaking changes</p> <ul> <li>move version definition in <code>titiler.pgstac.__version__</code></li> <li>remove unused <code>fetch_options</code> in <code>titiler.pgstac.reader.PgSTACReader</code></li> </ul>"},{"location":"release-notes/#010a10-2022-05-16-pre-release","title":"0.1.0a10 (2022-05-16) Pre-Release","text":"<ul> <li>update <code>titiler</code> version and add <code>reader_dependency</code> and <code>backend_dependency</code> in endpoint factory.</li> </ul>"},{"location":"release-notes/#010a9-2022-05-05-pre-release","title":"0.1.0.a9 (2022-05-05) Pre-Release","text":"<ul> <li>remove LRU cache on all settings classes to enable support for manually providing settings via keyword arguments and to minimize lines of code (author @alukach, stac-utils/titiler-pgstac!54)</li> </ul>"},{"location":"release-notes/#010a8-2022-05-02-pre-release","title":"0.1.0.a8 (2022-05-02) Pre-Release","text":"<ul> <li>Insert mosaic metadata <code>min/max zoom</code> and <code>bounds</code> in tilejson (stac-utils/titiler-pgstac!51)</li> <li>allow users the ability to optionally provide <code>PostgresSettings</code> to <code>connect_to_db()</code> function in the event that they want to customize how their DB credentials are populated (author @alukach, stac-utils/titiler-pgstac!53)</li> </ul>"},{"location":"release-notes/#010a7-2022-04-05-pre-release","title":"0.1.0.a7 (2022-04-05) Pre-Release","text":"<ul> <li>add <code>feature()</code> method to <code>PGSTACBackend</code> mosaic backend</li> <li>add <code>/statistics</code> endpoint to return statistics given a GeoJSON feature or featureCollection</li> <li>add <code>collection</code> in allowed returned fields</li> <li>switch to <code>pgstac.search</code> to get the STAC Item in <code>titiler.pgstac.dependencies.get_stac_item</code> (stac-utils/titiler-pgstac!50)</li> </ul>"},{"location":"release-notes/#010a6-2022-03-14-pre-release","title":"0.1.0.a6 (2022-03-14) Pre-Release","text":"<ul> <li>move dependencies to <code>titiler.pgstac.dependencies</code></li> <li>add <code>/stac</code> endpoints to work with PgSTAC items</li> </ul> <p>breaking changes</p> <ul> <li>add <code>/mosaic</code> prefix to the PgSTAC mosaic endpoints</li> </ul>"},{"location":"release-notes/#010a5-2022-03-03-pre-release","title":"0.1.0.a5 (2022-03-03) Pre-Release","text":"<ul> <li>Add <code>search_dependency</code> to allow customization of the PgSTAC Search query (Author @drnextgis, stac-utils/titiler-pgstac!41)</li> <li>Add PgSTAC Search entries model (stac-utils/titiler-pgstac!43)</li> <li>Add <code>Metadata</code> specification (stac-utils/titiler-pgstac!38)</li> </ul> <p>breaking changes</p> <ul> <li>update <code>titiler.core</code> and <code>titiler.mosaic</code> requirement to <code>&gt;=0.5</code></li> <li>When registering a <code>search</code> to PgSTAC with the <code>/register</code> endpoint, a default metadata <code>{\"type\": \"mosaic\"}</code> will be set.</li> <li>Renamed <code>titiler.pgstac.models</code> to <code>titiler.pgstac.model</code></li> <li>Renamed <code>titiler.pgstac.models.SearchQuery</code> to <code>titiler.pgstac.model.PgSTACSearch</code> (and removed <code>metadata</code>)</li> <li> <p>output response for <code>/register</code> endpoint: <pre><code>// before\n{\n    \"searchid\": \"...\",\n    \"metadata\": \"http://endpoint/.../info\",\n    \"tiles\": \"http://endpoint/.../tilejson.json\",\n}\n\n// now\n{\n    \"searchid\": \"...\",\n    \"links\": [\n        {\n            \"rel\": \"info\",\n            \"href\": \"http://endpoint/.../info\",\n            \"type\": \"application/json\",\n        },\n        {\n            \"rel\": \"tilejson\",\n            \"href\": \"http://endpoint/.../tilejson.json\",\n            \"type\": \"application/json\",\n        }\n    ]\n}\n</code></pre></p> </li> <li> <p>output response for <code>/info</code> endpoint: <pre><code>// before\n{\n    \"hash\": \"...\",\n    \"search\": {},\n    \"_where\": \"...\",\n    ...\n}\n\n// now\n{\n    \"search\": {\n        \"hash\": \"...\",\n        \"search\": {},\n        \"_where\": \"...\",\n        ...\n    },\n    \"links\": [\n        {\n            \"rel\": \"self\",\n            \"href\": \"http://endpoint/.../info\",\n            \"type\": \"application/json\",\n        },\n        {\n            \"rel\": \"tilejson\",\n            \"href\": \"http://endpoint/.../tilejson.json\",\n            \"type\": \"application/json\",\n        }\n    ]\n}\n</code></pre></p> </li> </ul>"},{"location":"release-notes/#010a4-2022-02-07-pre-release","title":"0.1.0.a4 (2022-02-07) Pre-Release","text":"<ul> <li>add tile <code>buffer</code> option to match rio-tiler tile options (stac-utils/titiler-pgstac!31)</li> </ul>"},{"location":"release-notes/#010a3-2021-12-15-pre-release","title":"0.1.0.a3 (2021-12-15) Pre-Release","text":"<ul> <li>Forward TMS to the STAC Reader (allow multiple TMS) (stac-utils/titiler-pgstac!28)</li> </ul>"},{"location":"release-notes/#010a2-2021-12-13-pre-release","title":"0.1.0.a2 (2021-12-13) Pre-Release","text":"<ul> <li>Switch to psycopg3</li> <li>add <code>filter-lang</code> in Search model to support newer PgSTAC (with CQL-2)</li> <li>add <code>metadata</code> in Search model to allow forwarding metadata to the search query entry in PgSTAC</li> </ul> <p>breaking changes</p> <ul> <li>Unify reader/writer db pools to <code>request.app.state.dbpool</code></li> <li>rename <code>PostgresSettings.db_max_inactive_conn_lifetime</code> to <code>PostgresSettings.max_idle</code></li> <li>remove <code>PostgresSettings().reader_connection_string</code> and <code>PostgresSettings().writer_connection_string</code>. Replaced with <code>PostgresSettings().connection_string</code></li> <li>update titiler requirement (&gt;= 0.4)</li> </ul>"},{"location":"release-notes/#010a1-2021-09-15-pre-release","title":"0.1.0.a1 (2021-09-15) Pre-Release","text":"<ul> <li>Surface PgSTAC options (<code>scan_limit</code>, <code>items_limit</code>, <code>time_limit</code>, <code>exitwhenfull</code> and <code>skipcovered</code>) in Tile endpoints</li> </ul> <p>breaking changes</p> <ul> <li>remove <code>psycopg2</code> requirements to avoid conflict with <code>psycopg2-binary</code> (stac-utils/titiler-pgstac!15)</li> </ul>"},{"location":"release-notes/#010a0-2021-09-06-pre-release","title":"0.1.0.a0 (2021-09-06) Pre-Release","text":"<p>Initial release</p>"},{"location":"tiler_factories/","title":"Tiler Factories","text":""},{"location":"tiler_factories/#mosaics-titilerpgstacfactorymosaictilerfactory","title":"Mosaics: <code>titiler.pgstac.factory.MosaicTilerFactory</code>","text":"<p><code>TiTiler.PgSTAC</code> provides a <code>MosaicTilerFactory</code> factory which is an helper functions to create FastAPI router (<code>fastapi.APIRouter</code>) with a minimal set of endpoints.</p> <pre><code># Minimal PgSTAC Mosaic Application\nfrom contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI\nfrom titiler.pgstac.db import close_db_connection, connect_to_db\nfrom titiler.pgstac.factory import MosaicTilerFactory\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"FastAPI Lifespan.\"\"\"\n    # Create Connection Pool\n    await connect_to_db(app)\n    yield\n    # Close the Connection Pool\n    await close_db_connection(app)\n\n\napp = FastAPI(lifespan=lifespan)\n\nmosaic = MosaicTilerFactory(\n    path_dependency=lambda: \"aaaaaaaaaaaaaaaaaaaaa\",\n)\napp.include_router(mosaic.router)\n</code></pre> <p>Important</p> <p>The <code>MosaicTilerFactory</code> requires a <code>path_dependency</code>, which should be a <code>Callable</code> that return a search_id (PgSTAC Search Hash).</p> <p>For the <code>/searches/{search_id}</code> endpoints the <code>path_dependency</code> is set to <code>titiler.pgstac.dependencies.SearchIdParams</code> and to <code>titiler.pgstac.dependencies.CollectionIdParams</code> for the <code>/collections/{collection_id}</code> endpoints.</p> <p>`</p> Method URL Output Description <code>GET</code> <code>/tiles</code> JSON List of OGC Tilesets available <code>GET</code> <code>/tiles/{tileMatrixSetId}</code> JSON OGC Tileset metadata <code>GET</code> <code>/tiles/{TileMatrixSetId}/{z}/{x}/{Y}/assets</code> JSON Return a list of assets which overlap a given tile <code>GET</code> <code>/tiles/{TileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin Create a web map tile image for a search query and a tile index <code>GET</code> <code>/{TileMatrixSetId}/map</code> HTML Simple map viewer OPTIONAL <code>GET</code> <code>/{TileMatrixSetId}/tilejson.json</code> JSON (TileJSON) Return a Mapbox TileJSON document <code>GET</code> <code>/{TileMatrixSetId}/WMTSCapabilities.xml</code> XML Return OGC WMTS Get Capabilities <code>GET</code> <code>/point/{lon}x{lat}</code> JSON (Point) Return pixel values from assets intersecting with a given point <code>GET</code> <code>/point/{lon},{lat}/assets</code> JSON Return a list of assets which overlap a given point <code>GET</code> <code>/bbox/{minx},{miny},{maxx},{maxy}[/{width}x{height}].{format}</code> image/bin Create an image from part of a dataset OPTIONAL <code>POST</code> <code>/feature[/{width}x{height}][.{format}]</code> image/bin Create an image from a GeoJSON feature OPTIONAL <code>POST</code> <code>/statistics</code> GeoJSON (Statistics) Return statistics for geojson features OPTIONAL"},{"location":"tiler_factories/#extensions","title":"Extensions","text":""},{"location":"tiler_factories/#searchinfoextension","title":"<code>searchInfoExtension</code>","text":"Method URL Output Description <code>GET</code> <code>/info</code> JSON (Infos) Return list of Search entries with <code>Mosaic</code> type  OPTIONAL <pre><code>app = FastAPI()\nmosaic = MosaicTilerFactory(\n    path_dependency=lambda: \"aaaaaaaaaaaaaaaaaaaaa\",\n    extensions=[\n        searchInfoExtension(),\n    ],\n)\napp.include_router(mosaic.router)\n</code></pre>"},{"location":"tiler_factories/#register-and-list","title":"<code>register and list</code>","text":"Method URL Output Description <code>POST</code> <code>/register</code> JSON (Register) Register Search query  OPTIONAL <code>GET</code> <code>/list</code> JSON (Info) Return Search query infos  OPTIONAL <pre><code>app = FastAPI()\nmosaic = MosaicTilerFactory(\n    path_dependency=lambda: \"aaaaaaaaaaaaaaaaaaaaa\",\n)\napp.include_router(mosaic.router)\n\nadd_search_register_route(app)\nadd_search_list_route(app)\n</code></pre>"},{"location":"tiler_factories/#items-titilercorefactorymultibasetilerfactory","title":"Items: <code>titiler.core.factory.MultiBaseTilerFactory</code>","text":"<p>For the <code>single STAC item</code> endpoints we use TiTiler's MultiBaseTilerFactory with a custom <code>path_dependency</code> to use <code>item_id</code> and <code>collection_id</code> path parameter (instead of the default <code>url</code> query param).</p> <p>This custom <code>path_dependency</code> will connect to PgSTAC directly to fetch the STAC Item and pass it to a custom Reader.</p> <pre><code># Minimal PgSTAC Item Application\nfrom contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI\n\nfrom titiler.core.factory import MultiBaseTilerFactory\n\nfrom titiler.pgstac.db import close_db_connection, connect_to_db\nfrom titiler.pgstac.dependencies import ItemPathParams\nfrom titiler.pgstac.reader import PgSTACReader\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"FastAPI Lifespan.\"\"\"\n    # Create Connection Pool\n    await connect_to_db(app)\n    yield\n    # Close the Connection Pool\n    await close_db_connection(app)\n\n\napp = FastAPI(lifespan=lifespan)\n\nitem = MultiBaseTilerFactory(\n    reader=PgSTACReader,\n    path_dependency=ItemPathParams,\n    router_prefix=\"/collections/{collection_id}/items/{item_id}\",\n)\napp.include_router(item.router, prefix=\"/collections/{collection_id}/items/{item_id}\")\n</code></pre>"},{"location":"advanced/custom_search/","title":"Custom search model","text":"<p>Even though <code>TiTiler.PgSTAC</code> includes default FastAPI application, it also can be used like a library if you want to extend or override default behavior.</p> <p>Let's look at one such example. Imagine that we use JSON Web Token (JWT) based approach for authorization and every token contains information about area a user has access to:</p> <pre><code>{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"iat\": 1516239022,\n  \"scope\": \"zone_A\"\n}\n</code></pre> <p>We want our application to take this information into account while registering a search query. It can be done in the following way:</p> <pre><code>from contextlib import asynccontextmanager\n\nfrom typing import Tuple\nimport json\nimport jwt\nfrom fastapi import FastAPI\nfrom fastapi.security.utils import get_authorization_scheme_param\nfrom starlette.requests import Request\nfrom titiler.pgstac.factory import MosaicTilerFactory, add_search_register_route\nfrom titiler.pgstac.model import RegisterMosaic, Metadata, PgSTACSearch\nfrom titiler.pgstac.db import close_db_connection, connect_to_db\nfrom titiler.pgstac.extensions import searchInfoExtension\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"FastAPI Lifespan.\"\"\"\n    # Create Connection Pool\n    await connect_to_db(app, settings=postgres_settings)\n    yield\n    # Close the Connection Pool\n    await close_db_connection(app)\n\napp = FastAPI(lifespan=lifespan)\n\nAREAS = {\n    \"zone_A\": {\"type\": \"Point\", \"coordinates\": [-41.93, -12.76]},\n    \"zone_B\": {\"type\": \"Point\", \"coordinates\": [2.15, 41.39]},\n}\n\n\ndef search_factory(request: Request, body: RegisterMosaic) -&gt; Tuple[PgSTACSearch, Metadata]:\n    authorization = request.headers.get(\"Authorization\")\n    scheme, token = get_authorization_scheme_param(authorization)\n    payload = jwt.decode(token, algorithms=[\"HS256\"], key=\"your-256-bit-secret\")\n\n    search = body.model_dump(exclude_none=True, exclude={\"metadata\"}, by_alias=True)\n    search[\"filter\"] = {\n        \"op\": \"and\",\n        \"args\": [\n            {\n                \"op\": \"s_intersects\",\n                \"args\": [{\"property\": \"geometry\"}, AREAS[payload[\"scope\"]]],\n            },\n            search[\"filter\"],\n        ],\n    }\n\n    return model.PgSTACSearch(**search), body.metadata\n\n\nmosaic = MosaicTilerFactory(\n    extensions=[\n      searchInfoExtension\n    ]\n)\napp.include_router(mosaic.router)\nadd_search_register_route(app, search_dependency=search_factory)\n</code></pre> <p>Checking:</p> <pre><code>$ curl -s -X 'POST' \\\n  'http://localhost:8081/register' \\\n  -H 'accept: application/json' \\\n  -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJzY29wZSI6InpvbmVfQSJ9.BelzluX7v7kYObix2KSyy1T5gEOQYQn_pyNO5Ri0gWo' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"filter\":{\"op\":\"and\",\"args\":[{\"op\":\"=\",\"args\":[{\"property\":\"collection\"},\"l1\"]}]}}' | jq '.id'\n\"bbc3c8f4c392436f74de6cd0308469f6\"\n\n$ curl -X 'GET' \\\n  'http://localhost:8081/bbc3c8f4c392436f74de6cd0308469f6/info' \\\n  -H 'accept: application/json'\n{\"hash\":\"bbc3c8f4c392436f74de6cd0308469f6\",\"search\":{\"filter\":{\"op\":\"and\",\"args\":[{\"op\":\"s_intersects\",\"args\":[{\"property\":\"geometry\"},{\"type\":\"Point\",\"coordinates\":[-41.93,-12.76]}]},{\"op\":\"and\",\"args\":[{\"op\":\"=\",\"args\":[{\"property\":\"collection\"},\"l1\"]}]}]}},\"_where\":\"(  ( st_intersects(geometry, '0101000020E6100000D7A3703D0AF744C085EB51B81E8529C0'::geometry) and  ( (collection_id = 'l1') )  )  )  \",\"orderby\":\"datetime DESC, id DESC\",\"lastused\":\"2022-02-23T13:00:04.090757+00:00\",\"usecount\":3,\"metadata\":{\"type\":\"mosaic\"}}\n</code></pre>"},{"location":"advanced/custom_tilejson/","title":"Custom TileJSON endpoint","text":"<p>Goal: enable users to select a predefined configuration stored in the mosaic Metadata.</p> <pre><code>import sys\nfrom typing import Optional\nfrom dataclasses import dataclass\n\nfrom morecantile import TileMatrixSet\nfrom titiler.core.resources.enums import ImageType\nfrom titiler.core.models.mapbox import TileJSON\nfrom titiler.pgstac import factory as TitilerPgSTACFactory\nfrom titiler.pgstac.dependencies import PgSTACParams\nfrom typing_extensions import Annotated\n\nfrom fastapi import Depends, Query\n\nfrom starlette.requests import Request\n\n\n@dataclass\nclass MosaicTilerFactory(TitilerPgSTACFactory.MosaicTilerFactory):\n    \"\"\"Custom factory.\"\"\"\n\n    def tilejson(self) -&gt; None:\n        \"\"\"Custom TileJSON endpoint.\"\"\"\n\n        @self.router.get(\n            \"/{tileMatrixSetId}/tilejson.json\",\n            response_model=TileJSON,\n            responses={200: {\"description\": \"Return a tilejson\"}},\n            response_model_exclude_none=True,\n        )\n        def tilejson(\n            request: Request,\n            tileMatrixSetId: Annotated[\n                Literal[tuple(self.supported_tms.list())],\n                Path(\n                    description=\"Identifier selecting one of the TileMatrixSetId supported.\"\n                ),\n            ],\n            ########################################################\n            # CUSTOM: add `layer=` query-parameter\n            layer: Annotated[\n                str,\n                Query(description=\"Name of default configuration\"),\n            ] = None,\n            ########################################################\n            tile_format: Annotated[\n                Optional[ImageType],\n                Query(\n                    description=\"Default will be automatically defined if the output image needs a mask (png) or not (jpeg).\",\n                ),\n            ] = None,\n            tile_scale: Annotated[\n                Optional[int],\n                Query(\n                    gt=0, lt=4, description=\"Tile size scale. 1=256x256, 2=512x512...\"\n                ),\n            ] = None,\n            minzoom: Annotated[\n                Optional[int],\n                Query(description=\"Overwrite default minzoom.\"),\n            ] = None,\n            maxzoom: Annotated[\n                Optional[int],\n                Query(description=\"Overwrite default maxzoom.\"),\n            ] = None,\n            search_id=Depends(self.path_dependency),\n            layer_params=Depends(self.layer_dependency),\n            dataset_params=Depends(self.dataset_dependency),\n            pixel_selection=Depends(self.pixel_selection_dependency),\n            buffer: Annotated[\n                Optional[float],\n                Query(\n                    gt=0,\n                    title=\"Tile buffer.\",\n                    description=\"Buffer on each side of the given tile. It must be a multiple of `0.5`. Output **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257, 1.0 = 258x258).\",\n                ),\n            ] = None,\n            post_process=Depends(self.process_dependency),\n            rescale=Depends(self.rescale_dependency),\n            color_formula: Annotated[\n                Optional[str],\n                Query(\n                    title=\"Color Formula\",\n                    description=\"rio-color formula (info: https://github.com/mapbox/rio-color)\",\n                ),\n            ] = None,\n            colormap=Depends(self.colormap_dependency),\n            render_params=Depends(self.render_dependency),\n            pgstac_params: PgSTACParams = Depends(),\n            backend_params=Depends(self.backend_dependency),\n            reader_params=Depends(self.reader_dependency),\n        ):\n            \"\"\"Return TileJSON document for a SearchId.\"\"\"\n            with request.app.state.dbpool.connection() as conn:\n                with conn.cursor(row_factory=class_row(model.Search)) as cursor:\n                    cursor.execute(\n                        \"SELECT * FROM searches WHERE hash=%s;\",\n                        (search_id,),\n                    )\n                    search_info = cursor.fetchone()\n                    if not search_info:\n                        raise KeyError(f\"search {search_id} not found\")\n\n            route_params = {\n                \"search_id\": search_info.id,\n                \"z\": \"{z}\",\n                \"x\": \"{x}\",\n                \"y\": \"{y}\",\n                \"tileMatrixSetId\": tileMatrixSetId,\n            }\n            if tile_scale:\n                route_params[\"scale\"] = tile_scale\n            if tile_format:\n                route_params[\"format\"] = tile_format.value\n\n            tiles_url = self.url_for(request, \"tile\", **route_params)\n\n            qs_key_to_remove = [\n                \"tilematrixsetid\",\n                \"tile_format\",\n                \"tile_scale\",\n                \"minzoom\",\n                \"maxzoom\",\n                \"layer\",\n            ]\n            qs = [\n                (key, value)\n                for (key, value) in request.query_params._list\n                if key.lower() not in qs_key_to_remove\n            ]\n\n            if layer:\n                config = search_info.metadata.defaults_params.get(layer)\n                if not config:\n                    raise HTTPException(status_code=404, detail=f\"Invalid {layer} configuration.\")\n\n                # This assume the default configuration follows the endpoint expected format\n                # as `\"true_color\": {\"assets\": [\"B4\", \"B3\", \"B2\"]}`\n                qs = QueryParams(config)\n\n            if qs:\n                tiles_url += f\"?{urlencode(qs, doseq=True)}\"\n\n            minzoom = _first_value([minzoom, search_info.metadata.minzoom], tms.minzoom)\n            maxzoom = _first_value([maxzoom, search_info.metadata.maxzoom], tms.maxzoom)\n            bounds = _first_value(\n                [search_info.input_search.get(\"bbox\"), search_info.metadata.bounds],\n                tms.bbox,\n            )\n            return {\n                \"bounds\": bounds,\n                \"minzoom\": minzoom,\n                \"maxzoom\": maxzoom,\n                \"name\": search_info.metadata.name or search_info.id,\n                \"tiles\": [tiles_url],\n            }\n</code></pre>"},{"location":"advanced/metadata/","title":"Mosaic metadata specification","text":"<p><code>TiTiler-PgSTAC</code> uses PgSTAC search to host mosaic parameters for performance purposes. To help users we added the possibility to add <code>metadata</code> to search entries and in <code>TiTiler-PgSTAC</code> we introduced a <code>non-official</code> specification to help user storing meaningful information.</p>"},{"location":"advanced/metadata/#specification","title":"Specification","text":"<pre><code>{\n    // OPTIONAL. Default: \"mosaic\" (No other value accepted for now). Describe the `type` of metadata.\n    \"type\": \"mosaic\",\n\n    // OPTIONAL. Default: null.\n    // The maximum extent of available map tiles. The bounds are represented in WGS:84\n    // latitude and longitude values, in the order left, bottom, right, top.\n    // Values may be integers or floating point numbers.\n    \"bounds\": [ -180, -85.05112877980659, 180, 85.0511287798066 ],\n\n    // OPTIONAL. Default: null.\n    // An integer specifying the minimum zoom level.\n    \"minzoom\": 0,\n\n    // OPTIONAL. Default: null.\n    // An integer specifying the maximum zoom level. MUST be &gt;= minzoom.\n    \"maxzoom\": 11,\n\n    // OPTIONAL. Default: null. The name can contain any legal character.\n    \"name\": \"compositing\",\n\n    // OPTIONAL. Default: null. An array of available assets.\n    \"assets\": [\"image\", \"cog\"],\n\n    // OPTIONAL. Default: null. A set of `defaults` configuration to be forwarded to the /tiles endpoints.\n    // Note: The defaults block should follow the STAC render extension https://github.com/stac-extensions/render\n    \"defaults\": {\n        \"true_color\": {\n            \"assets\": [\"B4\", \"B3\", \"B2\"],\n            \"color_formula\": \"Gamma RGB 3.5 Saturation 1.7 Sigmoidal RGB 15 0.35\",\n        },\n        \"ndvi\": {\n            \"expression\": \"(B4-B3)/(B4+B3)\",\n            \"rescale\": [[-1, 1]],\n            \"colormap_name\": \"viridis\"\n        }\n    }\n}\n</code></pre> <p>Important</p> <ul> <li>When using the <code>/searches/register</code> endpoint, <code>{\"type\": \"mosaic\"}</code> will be set by default</li> <li>All metadata fields are optional and custom fields are also allowed.</li> </ul> <pre><code>curl -X 'POST' 'http://127.0.0.1:8081/searches/register' -H 'accept: application/json' -H 'Content-Type: application/json' -d '{\"filter\": {\"op\": \"=\", \"args\": [{\"property\": \"collection\"}, \"landsat-c2l2-sr\"]}, \"metadata\": {\"name\": \"landsat mosaic\"}}'\n&gt;&gt; {\n  \"id\": \"d7fcdefd0457c949ea7a6192bc2c7122\",\n  \"links\": [\n    {\n      \"rel\": \"metadata\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/searches/d7fcdefd0457c949ea7a6192bc2c7122/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/searches/d7fcdefd0457c949ea7a6192bc2c7122/tilejson.json\"\n    }\n  ]\n}\n\ncurl http://127.0.0.1:8081/searches/d7fcdefd0457c949ea7a6192bc2c7122/info | jq '.search.metadata'\n&gt;&gt; {\n  \"type\": \"mosaic\",\n  \"name\": \"landsat mosaic\"\n}\n</code></pre> <pre><code>curl -X 'POST' 'http://127.0.0.1:8081/searches/register' -H 'accept: application/json' -H 'Content-Type: application/json' -d '{\"collections\": [\"noaa-emergency-response\"], \"bbox\": [-87.0251, 36.0999, -85.4249, 36.2251], \"filter-lang\": \"cql-json\", \"metadata\": {\"bounds\": [-87.0251, 36.0999, -85.4249, 36.2251], \"minzoom\": 14, \"maxzoom\": 18, \"assets\": [\"cog\"], \"defaults\": {\"true_color\": {\"bidx\": [1, 2, 3]}}}}'\n&gt;&gt; {\n  \"id\":\"4b0db3dbd1858d54a3a55f84de97d1ca\",\n  \"links\":[\n    {\n      \"rel\": \"metadata\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/searches/4b0db3dbd1858d54a3a55f84de97d1ca/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/searches/4b0db3dbd1858d54a3a55f84de97d1ca/tilejson.json\"\n    }\n  ]\n}\n\ncurl http://127.0.0.1:8081/searches/4b0db3dbd1858d54a3a55f84de97d1ca/info | jq '.search.metadata'\n&gt;&gt; {\n  \"type\": \"mosaic\",\n  \"bounds\": [\n    -87.0251,\n    36.0999,\n    -85.4249,\n    36.2251\n  ],\n  \"minzoom\": 14,\n  \"maxzoom\": 18,\n  \"assets\": [\n    \"cog\"\n  ],\n  \"defaults\": {\n    \"true_color\": {\n      \"bidx\": [\n        1,\n        2,\n        3\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"advanced/searches_list/","title":"Mosaic list","text":"<p>Starting with <code>titiler-pgstac&gt;=0.2.0</code>, we've added a <code>/searches/list</code> endpoint to be able to list all registered mosaics. When we add a mosaic via <code>/searches/register</code> we add a specific <code>metadata.type: \"mosaic\"</code> to the pgstac <code>search</code> entry, which is then used by the <code>/searches/list</code> endpoint to filter the pgstac <code>searches</code>.</p> <p>In order to make the mosaic list performant, users might want to alter their PgSTAC database to add an index</p> <pre><code>$ psql\npostgis=# SET schema 'pgstac';\n&gt;&gt; SET\n\npostgis=# CREATE INDEX IF NOT EXISTS searches_mosaic ON searches ((true)) WHERE metadata-&gt;&gt;'type'='mosaic';\n&gt;&gt; NOTICE:  relation \"searches_mosaic\" already exists, skipping\n&gt;&gt; CREATE INDEX\n\npostgis=# SELECT\n    indexname,\n    indexdef\nFROM\n    pg_indexes\nWHERE\n    tablename = 'searches';\n\n&gt;&gt;     indexname    |                                                         indexdef\n&gt;&gt; -----------------+---------------------------------------------------------------------------------------------------------------------------\n&gt;&gt;  searches_pkey   | CREATE UNIQUE INDEX searches_pkey ON pgstac.searches USING btree (hash)\n&gt;&gt;  searches_mosaic | CREATE INDEX searches_mosaic ON pgstac.searches USING btree ((true)) WHERE ((metadata -&gt;&gt; 'type'::text) = 'mosaic'::text)\n</code></pre> <p>ref: github.com/developmentseed/eoAPI/blob/master/stack/handlers/db_handler.py#L204-L213</p>"},{"location":"advanced/support_multidim_dataset/","title":"Zarr/NetCDF support","text":"<p>Goal: enable support of Zarr/NetCDF assets.</p> <p>By default titiler-pgstac (which is using rio-tiler's STACReader to access dataset) will only support 2D dataset (github.com/cogeotiff/rio-tiler/blob/83e8fc4ed765445d1aa0267cc3bccee15664b9b3/rio_tiler/io/stac.py#L42-L53). In this example we will create customized Readers enabling Zarr/NetCDF assets to use in the endpoint factories.</p>"},{"location":"advanced/support_multidim_dataset/#1-custom-stac-readers","title":"1. Custom STAC Readers","text":"<p>We need a Custom STACReader which can handle a new <code>md://{assetName}?variable={variableName}</code>. Note: here are the other query-parameters options github.com/developmentseed/titiler/blob/a1955706f02671cefac7e2806e43bab46f2a04dd/src/titiler/xarray/titiler/xarray/io.py#L252-L262</p> <pre><code>import warnings\nfrom typing import Optional, Set, Type, Tuple, Dict\nfrom urllib.parse import urlparse, parse_qsl\n\nimport attr\nfrom rio_tiler.types import AssetInfo\nfrom rio_tiler.io import BaseReader, Reader\nfrom rio_tiler.io.stac import DEFAULT_VALID_TYPE, STAC_ALTERNATE_KEY\nfrom rio_tiler.errors import InvalidAssetName\n\nfrom titiler.pgstac import reader\nfrom titiler.xarray.io import Reader as XarrayReader\n\n\n# Items Reader\n# Used for `/collections/{collection_id}/items/{item_id}` endpoints\n@attr.s\nclass PgSTACReader(reader.PgSTACReader):\n    \"\"\"\n\n    Example:\n\n        import httpx\n        import pystac\n\n        item = pystac.Item.from_dict(httpx.get(\"https://raw.githubusercontent.com/cogeotiff/rio-tiler/refs/heads/main/tests/fixtures/stac_netcdf.json\").json())\n\n        with PgSTACReader(item) as src:\n            print(src)\n            print(src._get_asset_info(\"netcdf\"))\n            print(src._get_reader(src._get_asset_info(\"netcdf\")))\n            print(src._get_reader(src._get_asset_info(\"md://netcdf?variable=data\")))\n            print(src._get_reader(src._get_asset_info(\"vrt://netcdf?sd_name=data\")))\n\n        &gt;&gt; PgSTACReader(bounds=(-170.085, 79.91999999999659, 169.91499999997504, -80.08), crs=CRS.from_epsg(4326), transform=[0.16999999999998752, 0, -170.085, 0, 0.1599999999999966, -80.08, 0, 0, 1], height=1000, width=2000, input=&lt;Item id=my_stac&gt;, tms=&lt;TileMatrixSet title='Google Maps Compatible for the World' id='WebMercatorQuad' crs='http://www.opengis.net/def/crs/EPSG/0/3857&gt;, minzoom=0, maxzoom=3, include_assets=None, exclude_assets=None, exclude_asset_types=None, assets=['geotiff', 'netcdf'], default_assets=None, reader=&lt;class 'rio_tiler.io.rasterio.Reader'&gt;, reader_options={}, ctx=&lt;class 'rasterio.env.Env'&gt;, item=&lt;Item id=my_stac&gt;, fetch_options=NOTHING, include_asset_types=['image/tiff; application=geotiff', 'image/tiff; profile=cloud-optimized; application=geotiff', 'application/x-hdf', 'image/jp2', 'application/x-hdf5', 'image/tiff', 'image/tiff; application=geotiff; profile=cloud-optimized', 'image/x.geotiff', 'image/vnd.stac.geotiff; cloud-optimized=true', 'application/x-netcdf', 'application/x-zarr', 'application/vnd+zarr'])\n        &gt;&gt; {'url': 'dataset_2d.nc', 'metadata': {}, 'media_type': 'application/x-netcdf'}\n        &gt;&gt; (&lt;class 'titiler.xarray.io.Reader'&gt;, {})\n        &gt;&gt; (&lt;class 'titiler.xarray.io.Reader'&gt;, {'variable': 'data'})\n        &gt;&gt; (&lt;class 'rio_tiler.io.rasterio.Reader'&gt;, {})\n\n    \"\"\"\n\n    include_asset_types: Set[str] = attr.ib(\n        default=[\n            *DEFAULT_VALID_TYPE,\n            \"application/x-netcdf\",\n            \"application/x-zarr\",\n            \"application/vnd+zarr\",\n        ]\n    )\n\n    def _get_reader(self, asset_info: AssetInfo) -&gt; Tuple[Type[BaseReader], Dict]:\n        \"\"\"Get Asset Reader.\"\"\"\n        asset_type = asset_info.get(\"media_type\", None)\n        if (\n            asset_type and\n            asset_type in [\n                \"application/x-netcdf\",\n                \"application/x-zarr\",\n                \"application/vnd+zarr\"\n            ] and\n            not asset_info[\"url\"].startswith(\"vrt://\")\n        ):\n            return XarrayReader, asset_info.get(\"reader_options\", {})\n\n        return Reader, asset_info.get(\"reader_options\", {})\n\n    def _parse_md_asset(self, asset: str) -&gt; Tuple[str, Optional[str]]:\n        \"\"\"Parse md:// prefixed asset.\"\"\"\n        if asset.startswith(\"md://\") and asset not in self.assets:\n            parsed = urlparse(asset)\n            if not parsed.netloc:\n                raise InvalidAssetName(\n                    f\"'{asset}' is not valid, couldn't find valid asset\"\n                )\n\n            if parsed.netloc not in self.assets:\n                raise InvalidAssetName(\n                    f\"'{parsed.netloc}' is not valid, should be one of {self.assets}\"\n                )\n\n\n            return parsed.netloc, dict(parse_qsl(parsed.query))\n\n        return asset, None\n\n\n    # We need a Custom _get_asset_info method to handle\n    # `md://{asset}:{variable}` form\n    def _get_asset_info(self, asset: str) -&gt; AssetInfo:\n        # Catch vrt://{assetName}?{vrtOptions}\n        asset, vrt_options = self._parse_vrt_asset(asset)\n\n        # Catch md://{assetName}?{readerOptions}\n        asset, reader_options = self._parse_md_asset(asset)\n\n        if asset not in self.assets:\n            raise InvalidAssetName(\n                f\"'{asset}' is not valid, should be one of {self.assets}\"\n            )\n\n        asset_info = self.item.assets[asset]\n        extras = asset_info.extra_fields\n\n        info = AssetInfo(\n            url=asset_info.get_absolute_href() or asset_info.href,\n            metadata=extras if not vrt_options else None,\n        )\n\n        if STAC_ALTERNATE_KEY and extras.get(\"alternate\"):\n            if alternate := extras[\"alternate\"].get(STAC_ALTERNATE_KEY):\n                info[\"url\"] = alternate[\"href\"]\n\n        if asset_info.media_type:\n            info[\"media_type\"] = asset_info.media_type\n\n        # https://github.com/stac-extensions/file\n        if head := extras.get(\"file:header_size\"):\n            info[\"env\"] = {\"GDAL_INGESTED_BYTES_AT_OPEN\": head}\n\n        # https://github.com/stac-extensions/raster\n        if extras.get(\"raster:bands\") and not vrt_options:\n            bands = extras.get(\"raster:bands\")\n            stats = [\n                (b[\"statistics\"][\"minimum\"], b[\"statistics\"][\"maximum\"])\n                for b in bands\n                if {\"minimum\", \"maximum\"}.issubset(b.get(\"statistics\", {}))\n            ]\n            # check that stats data are all double and make warning if not\n            if (\n                stats\n                and all(isinstance(v, (int, float)) for stat in stats for v in stat)\n                and len(stats) == len(bands)\n            ):\n                info[\"dataset_statistics\"] = stats\n            else:\n                warnings.warn(\n                    \"Some statistics data in STAC are invalid, they will be ignored.\"\n                )\n\n        if vrt_options:\n            # Construct VRT url\n            info[\"url\"] = f\"vrt://{info['url']}?{vrt_options}\"\n\n        if reader_options is not None:\n            # NOTE: add `reader_options`,\n            # not defined in AssetInfo structure\n            info[\"reader_options\"] = reader_options\n\n        return info\n\n\n# PgSTAC Backend Simple Reader\n# Used for `/collections/{collection_id}` and `/searches/{search_id}` endpoints\n# PgSTAC will return Items in form of Simple Dictionary\n@attr.s\nclass SimpleSTACReader(reader.SimpleSTACReader):\n\n    \"\"\"\n    Example:\n\n        item =     {\n            \"id\": \"IAMASTACITEM\",\n            \"collection\": \"mycollection\",\n            \"bbox\": (0, 0, 10, 10),\n            \"assets\": {\n                \"COG\": {\n                    \"href\": \"https://somewhereovertherainbow.io/cog.tif\"\n                },\n                \"NETCDF\": {\n                    \"href\": \"https://somewhereovertherainbow.io/cog.nc\",\n                    \"type\": \"application/x-netcdf\"\n                }\n            }\n        }\n\n        with SimpleSTACReader(item) as src:\n            print(src)\n            print(src._get_asset_info(\"NETCDF\"))\n            print(src._get_reader(src._get_asset_info(\"NETCDF\")))\n            print(src._get_reader(src._get_asset_info(\"md://NETCDF?variable=data\")))\n            print(src._get_reader(src._get_asset_info(\"vrt://NETCDF?sd_name=data\")))\n\n        &gt;&gt; SimpleSTACReader(bounds=(0, 0, 10, 10), crs=CRS.from_epsg(4326), transform=None, height=None, width=None, input={'id': 'IAMASTACITEM', 'collection': 'mycollection', 'bbox': (0, 0, 10, 10), 'assets': {'COG': {'href': 'https://somewhereovertherainbow.io/cog.tif'}, 'NETCDF': {'href': 'https://somewhereovertherainbow.io/cog.nc', 'media_type': 'application/x-netcdf'}}}, tms=&lt;TileMatrixSet title='Google Maps Compatible for the World' id='WebMercatorQuad' crs='http://www.opengis.net/def/crs/EPSG/0/3857&gt;, minzoom=0, maxzoom=24, assets=['COG', 'NETCDF'], default_assets=None, reader=&lt;class 'rio_tiler.io.rasterio.Reader'&gt;, reader_options={}, ctx=&lt;class 'rasterio.env.Env'&gt;)\n        &gt;&gt; {'url': 'https://somewhereovertherainbow.io/cog.nc', 'env': {}, 'media_type': 'application/x-netcdf'}\n        &gt;&gt; (&lt;class 'titiler.xarray.io.Reader'&gt;, {})\n        &gt;&gt; (&lt;class 'titiler.xarray.io.Reader'&gt;, {'variable': 'data'})\n        &gt;&gt; (&lt;class 'rio_tiler.io.rasterio.Reader'&gt;, {})\n\n    \"\"\"\n\n    def _get_reader(self, asset_info: AssetInfo) -&gt; Tuple[Type[BaseReader], Dict]:\n        \"\"\"Get Asset Reader.\"\"\"\n        asset_type = asset_info.get(\"media_type\", None)\n        if (\n            asset_type and\n            asset_type in [\n                \"application/x-netcdf\",\n                \"application/x-zarr\",\n                \"application/vnd+zarr\"\n            ] and\n            not asset_info[\"url\"].startswith(\"vrt://\")\n        ):\n            return XarrayReader, asset_info.get(\"reader_options\", {})\n\n        return Reader, asset_info.get(\"reader_options\", {})\n\n    def _parse_vrt_asset(self, asset: str) -&gt; Tuple[str, Optional[str]]:\n        if asset.startswith(\"vrt://\") and asset not in self.assets:\n            parsed = urlparse(asset)\n            if not parsed.netloc:\n                raise InvalidAssetName(\n                    f\"'{asset}' is not valid, couldn't find valid asset\"\n                )\n\n            if parsed.netloc not in self.assets:\n                raise InvalidAssetName(\n                    f\"'{parsed.netloc}' is not valid, should be one of {self.assets}\"\n                )\n\n            return parsed.netloc, parsed.query\n\n        return asset, None\n\n    def _parse_md_asset(self, asset: str) -&gt; Tuple[str, Optional[str]]:\n        \"\"\"Parse md:// prefixed asset.\"\"\"\n        if asset.startswith(\"md://\") and asset not in self.assets:\n            parsed = urlparse(asset)\n            if not parsed.netloc:\n                raise InvalidAssetName(\n                    f\"'{asset}' is not valid, couldn't find valid asset\"\n                )\n\n            if parsed.netloc not in self.assets:\n                raise InvalidAssetName(\n                    f\"'{parsed.netloc}' is not valid, should be one of {self.assets}\"\n                )\n\n\n            return parsed.netloc, dict(parse_qsl(parsed.query))\n\n        return asset, None\n\n    # We need a Custom _get_asset_info method to handle\n    # `md://{asset}:{variable}` form\n    def _get_asset_info(self, asset: str) -&gt; AssetInfo:\n        # Catch vrt://{assetName}?{vrtOptions}\n        asset, vrt_options = self._parse_vrt_asset(asset)\n\n        # Catch md://{assetName}?{readerOptions}\n        asset, reader_options = self._parse_md_asset(asset)\n\n        if asset not in self.assets:\n            raise InvalidAssetName(\n                f\"'{asset}' is not valid, should be one of {self.assets}\"\n            )\n\n        asset_info = self.input[\"assets\"][asset]\n        info = AssetInfo(\n            url=asset_info[\"href\"],\n            env={},\n        )\n\n        if media_type := asset_info.get(\"type\"):\n            info[\"media_type\"] = media_type\n\n        if header_size := asset_info.get(\"file:header_size\"):\n            info[\"env\"][\"GDAL_INGESTED_BYTES_AT_OPEN\"] = header_size\n\n        if bands := asset_info.get(\"raster:bands\"):\n            stats = [\n                (b[\"statistics\"][\"minimum\"], b[\"statistics\"][\"maximum\"])\n                for b in bands\n                if {\"minimum\", \"maximum\"}.issubset(b.get(\"statistics\", {}))\n            ]\n            if len(stats) == len(bands):\n                info[\"dataset_statistics\"] = stats\n\n        if vrt_options:\n            # Construct VRT url\n            info[\"url\"] = f\"vrt://{info['url']}?{vrt_options}\"\n\n        if reader_options is not None:\n            # NOTE: add `reader_options`,\n            # not defined in AssetInfo structure\n            info[\"reader_options\"] = reader_options\n\n        return info\n</code></pre>"},{"location":"advanced/support_multidim_dataset/#2-create-application","title":"2. Create Application","text":"<pre><code>from contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom titiler.pgstac.dependencies import (\n    CollectionIdParams,\n    ItemIdParams,\n    SearchIdParams,\n)\nfrom titiler.pgstac.db import close_db_connection, connect_to_db\nfrom titiler.pgstac.factory import MosaicTilerFactory\nfrom titiler.core.factory import MultiBaseTilerFactory\n\nfrom .custom import SimpleSTACReader, PgSTACReader\n\npostgres_settings = PostgresSettings()\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"FastAPI Lifespan.\"\"\"\n    # Create Connection Pool\n    await connect_to_db(app, settings=postgres_settings)\n    yield\n    # Close the Connection Pool\n    await close_db_connection(app)\n\n\napp = FastAPI(\n    title=settings.name,\n    openapi_url=\"/api\",\n    docs_url=\"/api.html\",\n    lifespan=lifespan,\n)\n\n\n\n###############################################################################\n# STAC Search Endpoints\nsearches = MosaicTilerFactory(\n    path_dependency=SearchIdParams,\n    # Use our Custom Reader\n    dataset_reader=SimpleSTACReader,\n    router_prefix=\"/searches/{search_id}\",\n    add_viewer=True,\n)\napp.include_router(\n    searches.router, tags=[\"STAC Search\"], prefix=\"/searches/{search_id}\"\n)\n\n###############################################################################\n# STAC COLLECTION Endpoints\ncollection = MosaicTilerFactory(\n    path_dependency=CollectionIdParams,\n    # Use our Custom Reader\n    dataset_reader=SimpleSTACReader,\n    router_prefix=\"/collections/{collection_id}\",\n    add_viewer=True,\n)\napp.include_router(\n    collection.router, tags=[\"STAC Collection\"], prefix=\"/collections/{collection_id}\"\n)\n\n###############################################################################\n# STAC Item Endpoints\nstac = MultiBaseTilerFactory(\n    # Use our Custom Reader\n    reader=PgSTACReader,\n    path_dependency=ItemIdParams,\n    router_prefix=\"/collections/{collection_id}/items/{item_id}\",\n    add_viewer=True,\n)\napp.include_router(\n    stac.router,\n    tags=[\"STAC Item\"],\n    prefix=\"/collections/{collection_id}/items/{item_id}\",\n)\n</code></pre>"},{"location":"api/titiler/pgstac/backend/","title":"backend","text":""},{"location":"api/titiler/pgstac/backend/#titiler.pgstac.backend","title":"titiler.pgstac.backend","text":"<p>TiTiler.PgSTAC custom Mosaic Backend and Custom STACReader.</p>"},{"location":"api/titiler/pgstac/backend/#titiler.pgstac.backend.PGSTACBackend","title":"PGSTACBackend","text":"<p>               Bases: <code>BaseBackend</code></p> <p>PgSTAC Mosaic Backend.</p>"},{"location":"api/titiler/pgstac/backend/#titiler.pgstac.backend.PGSTACBackend.__attrs_post_init__","title":"__attrs_post_init__","text":"<pre><code>__attrs_post_init__() -&gt; None\n</code></pre> <p>Post Init.</p>"},{"location":"api/titiler/pgstac/backend/#titiler.pgstac.backend.PGSTACBackend._read","title":"_read","text":"<pre><code>_read() -&gt; MosaicJSON\n</code></pre> <p>This method is not used but is required by the abstract class.</p>"},{"location":"api/titiler/pgstac/backend/#titiler.pgstac.backend.PGSTACBackend.assets_for_bbox","title":"assets_for_bbox","text":"<pre><code>assets_for_bbox(xmin: float, ymin: float, xmax: float, ymax: float, coord_crs: CRS = WGS84_CRS, **kwargs: Any) -&gt; List[Dict]\n</code></pre> <p>Retrieve assets for bbox.</p>"},{"location":"api/titiler/pgstac/backend/#titiler.pgstac.backend.PGSTACBackend.assets_for_point","title":"assets_for_point","text":"<pre><code>assets_for_point(lng: float, lat: float, coord_crs: CRS = WGS84_CRS, **kwargs: Any) -&gt; List[Dict]\n</code></pre> <p>Retrieve assets for point.</p>"},{"location":"api/titiler/pgstac/backend/#titiler.pgstac.backend.PGSTACBackend.assets_for_tile","title":"assets_for_tile","text":"<pre><code>assets_for_tile(x: int, y: int, z: int, **kwargs: Any) -&gt; List[Dict]\n</code></pre> <p>Retrieve assets for tile.</p>"},{"location":"api/titiler/pgstac/backend/#titiler.pgstac.backend.PGSTACBackend.feature","title":"feature","text":"<pre><code>feature(shape: Dict, dst_crs: Optional[CRS] = None, shape_crs: CRS = WGS84_CRS, max_size: int = 1024, scan_limit: Optional[int] = None, items_limit: Optional[int] = None, time_limit: Optional[int] = None, exitwhenfull: Optional[bool] = None, skipcovered: Optional[bool] = None, **kwargs: Any) -&gt; Tuple[ImageData, List[str]]\n</code></pre> <p>Create an Image from multiple items for a GeoJSON feature.</p>"},{"location":"api/titiler/pgstac/backend/#titiler.pgstac.backend.PGSTACBackend.get_assets","title":"get_assets","text":"<pre><code>get_assets(geom: Geometry, fields: Optional[Dict[str, Any]] = None, scan_limit: Optional[int] = None, items_limit: Optional[int] = None, time_limit: Optional[int] = None, exitwhenfull: Optional[bool] = None, skipcovered: Optional[bool] = None) -&gt; List[Dict]\n</code></pre> <p>Find assets.</p>"},{"location":"api/titiler/pgstac/backend/#titiler.pgstac.backend.PGSTACBackend.part","title":"part","text":"<pre><code>part(bbox: BBox, dst_crs: Optional[CRS] = None, bounds_crs: CRS = WGS84_CRS, scan_limit: Optional[int] = None, items_limit: Optional[int] = None, time_limit: Optional[int] = None, exitwhenfull: Optional[bool] = None, skipcovered: Optional[bool] = None, **kwargs: Any) -&gt; Tuple[ImageData, List[str]]\n</code></pre> <p>Create an Image from multiple items for a bbox.</p>"},{"location":"api/titiler/pgstac/backend/#titiler.pgstac.backend.PGSTACBackend.point","title":"point","text":"<pre><code>point(lon: float, lat: float, coord_crs: CRS = WGS84_CRS, scan_limit: Optional[int] = None, items_limit: Optional[int] = None, time_limit: Optional[int] = None, exitwhenfull: Optional[bool] = None, skipcovered: Optional[bool] = None, **kwargs: Any) -&gt; List\n</code></pre> <p>Get Point value from multiple observation.</p>"},{"location":"api/titiler/pgstac/backend/#titiler.pgstac.backend.PGSTACBackend.tile","title":"tile","text":"<pre><code>tile(tile_x: int, tile_y: int, tile_z: int, scan_limit: Optional[int] = None, items_limit: Optional[int] = None, time_limit: Optional[int] = None, exitwhenfull: Optional[bool] = None, skipcovered: Optional[bool] = None, **kwargs: Any) -&gt; Tuple[ImageData, List[str]]\n</code></pre> <p>Get Tile from multiple observation.</p>"},{"location":"api/titiler/pgstac/backend/#titiler.pgstac.backend.PGSTACBackend.update","title":"update","text":"<pre><code>update() -&gt; None\n</code></pre> <p>We overwrite the default method.</p>"},{"location":"api/titiler/pgstac/backend/#titiler.pgstac.backend.PGSTACBackend.write","title":"write","text":"<pre><code>write(overwrite: bool = True) -&gt; None\n</code></pre> <p>This method is not used but is required by the abstract class.</p>"},{"location":"api/titiler/pgstac/backend/#titiler.pgstac.backend.multi_points_pgstac","title":"multi_points_pgstac","text":"<pre><code>multi_points_pgstac(asset_list: Sequence[Dict[str, Any]], reader: Callable[..., PointData], *args: Any, threads: int = MAX_THREADS, allowed_exceptions: Optional[Tuple] = None, **kwargs: Any) -&gt; Dict\n</code></pre> <p>Merge values returned from tasks.</p> <p>Custom version of <code>rio_tiler.task.multi_values</code> which use constructed <code>item_id</code> as dict key.</p>"},{"location":"api/titiler/pgstac/db/","title":"db","text":""},{"location":"api/titiler/pgstac/db/#titiler.pgstac.db","title":"titiler.pgstac.db","text":"<p>Database connection handling.</p>"},{"location":"api/titiler/pgstac/db/#titiler.pgstac.db.close_db_connection","title":"close_db_connection  <code>async</code>","text":"<pre><code>close_db_connection(app: FastAPI) -&gt; None\n</code></pre> <p>Close Pool.</p>"},{"location":"api/titiler/pgstac/db/#titiler.pgstac.db.connect_to_db","title":"connect_to_db  <code>async</code>","text":"<pre><code>connect_to_db(app: FastAPI, settings: Optional[PostgresSettings] = None, pool_kwargs: Optional[Dict[str, Any]] = None) -&gt; None\n</code></pre> <p>Connect to Database.</p>"},{"location":"api/titiler/pgstac/dependencies/","title":"dependencies","text":""},{"location":"api/titiler/pgstac/dependencies/#titiler.pgstac.dependencies","title":"titiler.pgstac.dependencies","text":"<p>titiler-pgstac dependencies.</p>"},{"location":"api/titiler/pgstac/dependencies/#titiler.pgstac.dependencies.BackendParams","title":"BackendParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>backend parameters.</p> Source code in <code>titiler/pgstac/dependencies.py</code> <pre><code>@dataclass(init=False)\nclass BackendParams(DefaultDependency):\n    \"\"\"backend parameters.\"\"\"\n\n    pool: ConnectionPool = field(init=False)\n\n    def __init__(self, request: Request):\n        \"\"\"Initialize BackendParams\n\n        Note: Because we don't want `pool` to appear in the documentation we use a dataclass with a custom `__init__` method.\n        FastAPI will use the `__init__` method but will exclude Request in the documentation making `pool` an invisible dependency.\n        \"\"\"\n        self.pool = request.app.state.dbpool\n</code></pre>"},{"location":"api/titiler/pgstac/dependencies/#titiler.pgstac.dependencies.BackendParams.__init__","title":"__init__","text":"<pre><code>__init__(request: Request)\n</code></pre> <p>Initialize BackendParams</p> <p>Note: Because we don't want <code>pool</code> to appear in the documentation we use a dataclass with a custom <code>__init__</code> method. FastAPI will use the <code>__init__</code> method but will exclude Request in the documentation making <code>pool</code> an invisible dependency.</p> Source code in <code>titiler/pgstac/dependencies.py</code> <pre><code>def __init__(self, request: Request):\n    \"\"\"Initialize BackendParams\n\n    Note: Because we don't want `pool` to appear in the documentation we use a dataclass with a custom `__init__` method.\n    FastAPI will use the `__init__` method but will exclude Request in the documentation making `pool` an invisible dependency.\n    \"\"\"\n    self.pool = request.app.state.dbpool\n</code></pre>"},{"location":"api/titiler/pgstac/dependencies/#titiler.pgstac.dependencies.PgSTACParams","title":"PgSTACParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>PgSTAC parameters.</p> Source code in <code>titiler/pgstac/dependencies.py</code> <pre><code>@dataclass\nclass PgSTACParams(DefaultDependency):\n    \"\"\"PgSTAC parameters.\"\"\"\n\n    scan_limit: Annotated[\n        Optional[int],\n        Query(\n            description=\"Return as soon as we scan N items (defaults to 10000 in PgSTAC).\",\n        ),\n    ] = None\n    items_limit: Annotated[\n        Optional[int],\n        Query(\n            description=\"Return as soon as we have N items per geometry (defaults to 100 in PgSTAC).\",\n        ),\n    ] = None\n    time_limit: Annotated[\n        Optional[int],\n        Query(\n            description=\"Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).\",\n        ),\n    ] = None\n    exitwhenfull: Annotated[\n        Optional[bool],\n        Query(\n            description=\"Return as soon as the geometry is fully covered (defaults to True in PgSTAC).\",\n        ),\n    ] = None\n    skipcovered: Annotated[\n        Optional[bool],\n        Query(\n            description=\"Skip any items that would show up completely under the previous items (defaults to True in PgSTAC).\",\n        ),\n    ] = None\n</code></pre>"},{"location":"api/titiler/pgstac/dependencies/#titiler.pgstac.dependencies.AssetIdParams","title":"AssetIdParams","text":"<pre><code>AssetIdParams(request: Request, collection_id: Annotated[str, Path(description='STAC Collection Identifier')], item_id: Annotated[str, Path(description='STAC Item Identifier')], asset_id: Annotated[str, Path(description='STAC Asset Identifier')]) -&gt; str\n</code></pre> <p>STAC Asset dependency.</p> Source code in <code>titiler/pgstac/dependencies.py</code> <pre><code>def AssetIdParams(\n    request: Request,\n    collection_id: Annotated[\n        str,\n        Path(description=\"STAC Collection Identifier\"),\n    ],\n    item_id: Annotated[str, Path(description=\"STAC Item Identifier\")],\n    asset_id: Annotated[str, Path(description=\"STAC Asset Identifier\")],\n) -&gt; str:\n    \"\"\"STAC Asset dependency.\"\"\"\n    item = get_stac_item(request.app.state.dbpool, collection_id, item_id)\n    asset_info = item.assets[asset_id]\n    return asset_info.get_absolute_href() or asset_info.href\n</code></pre>"},{"location":"api/titiler/pgstac/dependencies/#titiler.pgstac.dependencies.CollectionIdParams","title":"CollectionIdParams","text":"<pre><code>CollectionIdParams(request: Request, collection_id: Annotated[str, Path(description='STAC Collection Identifier')], ids: Annotated[Optional[str], Query(description='Array of Item ids', openapi_examples={user - provided: {value: None}, multiple - items: {value: (item1, item2)}})] = None, bbox: Annotated[Optional[str], Query(description='Filters items intersecting this bounding box', openapi_examples={user - provided: {value: None}, Montreal: {value: (-73.896103, 45.36469, -73.413734, 45.674283)}})] = None, datetime: Annotated[Optional[str], Query(description='Filters items that have a temporal property that intersects this value.\\n\\nEither a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339. Open intervals are expressed using double-dots.', openapi_examples={user - defined: {value: None}, datetime: {value: '2018-02-12T23:20:50Z'}, closed - interval: {value: '2018-02-12T00:00:00Z/2018-03-18T12:31:12Z'}, 'open-interval-from': {value: '2018-02-12T00:00:00Z/..'}, open - interval - to: {value: '../2018-03-18T12:31:12Z'}})] = None, query: Annotated[Optional[str], Query(description='Allows additional filtering based on the properties of Item objects', openapi_examples={user - provided: {value: None}, cloudy: {value: {'eo:cloud_cover': {'gte': 95}}}})] = None, sortby: Annotated[Optional[str], Query(description=\"An array of property names, prefixed by either '+' for ascending or '-' for descending. If no prefix is provided, '+' is assumed.\", openapi_examples={user - provided: {value: None}, resolution: {value: -gsd}, 'resolution-and-dates': {value: (-gsd, -datetime)}})] = None) -&gt; str\n</code></pre> <p>Collection endpoints Parameters</p> Source code in <code>titiler/pgstac/dependencies.py</code> <pre><code>def CollectionIdParams(\n    request: Request,\n    collection_id: Annotated[\n        str,\n        Path(description=\"STAC Collection Identifier\"),\n    ],\n    ids: Annotated[\n        Optional[str],\n        Query(\n            description=\"Array of Item ids\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"multiple-items\": {\"value\": \"item1,item2\"},\n            },\n        ),\n    ] = None,\n    bbox: Annotated[\n        Optional[str],\n        Query(\n            description=\"Filters items intersecting this bounding box\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"Montreal\": {\"value\": \"-73.896103,45.364690,-73.413734,45.674283\"},\n            },\n        ),\n    ] = None,\n    datetime: Annotated[\n        Optional[str],\n        Query(\n            description=\"\"\"Filters items that have a temporal property that intersects this value.\\n\nEither a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339. Open intervals are expressed using double-dots.\"\"\",\n            openapi_examples={\n                \"user-defined\": {\"value\": None},\n                \"datetime\": {\"value\": \"2018-02-12T23:20:50Z\"},\n                \"closed-interval\": {\n                    \"value\": \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\"\n                },\n                \"open-interval-from\": {\"value\": \"2018-02-12T00:00:00Z/..\"},\n                \"open-interval-to\": {\"value\": \"../2018-03-18T12:31:12Z\"},\n            },\n        ),\n    ] = None,\n    query: Annotated[\n        Optional[str],\n        Query(\n            description=\"Allows additional filtering based on the properties of Item objects\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"cloudy\": {\"value\": '{\"eo:cloud_cover\": {\"gte\": 95}}'},\n            },\n        ),\n    ] = None,\n    sortby: Annotated[\n        Optional[str],\n        Query(\n            description=\"An array of property names, prefixed by either '+' for ascending or '-' for descending. If no prefix is provided, '+' is assumed.\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"resolution\": {\"value\": \"-gsd\"},\n                \"resolution-and-dates\": {\"value\": \"-gsd,-datetime\"},\n            },\n        ),\n    ] = None,\n) -&gt; str:\n    \"\"\"Collection endpoints Parameters\"\"\"\n    return get_collection_id(\n        request.app.state.dbpool,\n        collection_id=collection_id,\n        ids=ids,\n        bbox=bbox,\n        datetime=datetime,\n        query=query,\n        sortby=sortby,\n    )\n</code></pre>"},{"location":"api/titiler/pgstac/dependencies/#titiler.pgstac.dependencies.ItemIdParams","title":"ItemIdParams","text":"<pre><code>ItemIdParams(request: Request, collection_id: Annotated[str, Path(description='STAC Collection Identifier')], item_id: Annotated[str, Path(description='STAC Item Identifier')]) -&gt; Item\n</code></pre> <p>STAC Item dependency.</p> Source code in <code>titiler/pgstac/dependencies.py</code> <pre><code>def ItemIdParams(\n    request: Request,\n    collection_id: Annotated[\n        str,\n        Path(description=\"STAC Collection Identifier\"),\n    ],\n    item_id: Annotated[str, Path(description=\"STAC Item Identifier\")],\n) -&gt; pystac.Item:\n    \"\"\"STAC Item dependency.\"\"\"\n    return get_stac_item(request.app.state.dbpool, collection_id, item_id)\n</code></pre>"},{"location":"api/titiler/pgstac/dependencies/#titiler.pgstac.dependencies.SearchIdParams","title":"SearchIdParams","text":"<pre><code>SearchIdParams(search_id: Annotated[str, Path(description='PgSTAC Search Identifier (Hash)')]) -&gt; str\n</code></pre> <p>search_id</p> Source code in <code>titiler/pgstac/dependencies.py</code> <pre><code>def SearchIdParams(\n    search_id: Annotated[\n        str,\n        Path(description=\"PgSTAC Search Identifier (Hash)\"),\n    ],\n) -&gt; str:\n    \"\"\"search_id\"\"\"\n    return search_id\n</code></pre>"},{"location":"api/titiler/pgstac/dependencies/#titiler.pgstac.dependencies.SearchParams","title":"SearchParams","text":"<pre><code>SearchParams(body: RegisterMosaic) -&gt; Tuple[PgSTACSearch, Metadata]\n</code></pre> <p>Search parameters.</p> Source code in <code>titiler/pgstac/dependencies.py</code> <pre><code>def SearchParams(\n    body: model.RegisterMosaic,\n) -&gt; Tuple[model.PgSTACSearch, model.Metadata]:\n    \"\"\"Search parameters.\"\"\"\n    search = body.model_dump(\n        exclude_none=True,\n        exclude={\"metadata\"},\n        by_alias=True,\n    )\n    return model.PgSTACSearch(**search), body.metadata\n</code></pre>"},{"location":"api/titiler/pgstac/dependencies/#titiler.pgstac.dependencies.TmsTileParams","title":"TmsTileParams","text":"<pre><code>TmsTileParams(z: Annotated[int, Path(description='Identifier (Z) selecting one of the scales defined in the TileMatrixSet and representing the scaleDenominator the tile.')], x: Annotated[int, Path(description='Column (X) index of the tile on the selected TileMatrix. It cannot exceed the MatrixHeight-1 for the selected TileMatrix.')], y: Annotated[int, Path(description='Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the MatrixWidth-1 for the selected TileMatrix.')]) -&gt; Tile\n</code></pre> <p>TileMatrixSet Tile parameters.</p> Source code in <code>titiler/pgstac/dependencies.py</code> <pre><code>def TmsTileParams(\n    z: Annotated[\n        int,\n        Path(\n            description=\"Identifier (Z) selecting one of the scales defined in the TileMatrixSet and representing the scaleDenominator the tile.\",\n        ),\n    ],\n    x: Annotated[\n        int,\n        Path(\n            description=\"Column (X) index of the tile on the selected TileMatrix. It cannot exceed the MatrixHeight-1 for the selected TileMatrix.\",\n        ),\n    ],\n    y: Annotated[\n        int,\n        Path(\n            description=\"Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the MatrixWidth-1 for the selected TileMatrix.\",\n        ),\n    ],\n) -&gt; morecantile.Tile:\n    \"\"\"TileMatrixSet Tile parameters.\"\"\"\n    return morecantile.Tile(x, y, z)\n</code></pre>"},{"location":"api/titiler/pgstac/dependencies/#titiler.pgstac.dependencies.get_collection_id","title":"get_collection_id","text":"<pre><code>get_collection_id(pool: ConnectionPool, collection_id: str, ids: Optional[str] = None, bbox: Optional[str] = None, datetime: Optional[str] = None, query: Optional[str] = None, sortby: Optional[str] = None) -&gt; str\n</code></pre> <p>Get Search Id for a Collection.</p> Source code in <code>titiler/pgstac/dependencies.py</code> <pre><code>@cached(  # type: ignore\n    TTLCache(maxsize=cache_config.maxsize, ttl=cache_config.ttl),\n    key=lambda pool, collection_id, ids, bbox, datetime, query, sortby: hashkey(\n        collection_id,\n        ids,\n        bbox,\n        datetime,\n        query,\n        sortby,\n    ),\n    lock=Lock(),\n)\n@retry(\n    tries=retry_config.retry,\n    delay=retry_config.delay,\n    exceptions=(\n        pgErrors.OperationalError,\n        pgErrors.InterfaceError,\n    ),\n)\ndef get_collection_id(  # noqa: C901\n    pool: ConnectionPool,\n    collection_id: str,\n    ids: Optional[str] = None,\n    bbox: Optional[str] = None,\n    datetime: Optional[str] = None,\n    query: Optional[str] = None,\n    sortby: Optional[str] = None,\n) -&gt; str:  # noqa: C901\n    \"\"\"Get Search Id for a Collection.\"\"\"\n    sort_param: List[model.SortExtension] = []\n    if sortby:\n        for sort in sortby.split(\",\"):\n            if sortparts := re.match(r\"^([+-]?)(.*)$\", sort):\n                sort_param.append(\n                    model.SortExtension(\n                        field=sortparts.group(2).strip(),\n                        direction=\"desc\" if sortparts.group(1) == \"-\" else \"asc\",\n                    )\n                )\n\n    search = model.PgSTACSearch(\n        collections=[collection_id],\n        ids=ids.split(\",\") if ids else None,\n        bbox=list(map(float, bbox.split(\",\"))) if bbox else None,\n        datetime=datetime,\n        query=json.loads(unquote_plus(query)) if query else None,\n        sortby=sort_param or None,\n    )\n\n    with pool.connection() as conn:\n        with conn.cursor(row_factory=dict_row) as cursor:\n            cursor.execute(\n                \"SELECT * FROM pgstac.get_collection(%s);\",\n                (collection_id,),\n            )\n            collection = cursor.fetchone()[\"get_collection\"]\n            if not collection:\n                raise MosaicNotFoundError(f\"CollectionId `{collection_id}` not found\")\n\n            collection_bbox = collection[\"extent\"][\"spatial\"].get(\n                \"bbox\", [[-180, -90, 180, 90]]\n            )\n            metadata = model.Metadata(\n                name=f\"Mosaic for '{collection_id}' Collection\",\n                bounds=search.bbox or collection_bbox[0],\n            )\n\n            # item-assets https://github.com/stac-extensions/item-assets\n            if \"item_assets\" in collection:\n                metadata.assets = list(collection[\"item_assets\"])\n\n            # render https://github.com/stac-extensions/render\n            if \"renders\" in collection:\n                renders = {}\n                for name, render in collection[\"renders\"].items():\n                    try:\n                        # `title` is not a parameter expected by titiler-pgstac\n                        _ = render.pop(\"title\", None)\n\n                        # TODO: add support for tilematrixset\n                        _ = render.pop(\"tilematrixsets\", None)\n\n                        # `minmax_zoom` is not a parameter expected by titiler-pgstac\n                        zooms = render.pop(\"minmax_zoom\", None)\n                        if zooms and len(zooms) == 2:\n                            render[\"minzoom\"] = zooms[0]\n                            render[\"maxzoom\"] = zooms[1]\n\n                        renders[name] = render\n\n                    except Exception as e:\n                        warnings.warn(\n                            f\"Invalid render `{name}`: {repr(e)}\",\n                            UserWarning,\n                            stacklevel=2,\n                        )\n                        continue\n\n                metadata.defaults = renders\n\n            # TODO: adapt Mosaic Backend to accept Search object directly\n            # we technically don't need to register the search request for /collections\n            try:\n                cursor.execute(\"SELECT pgstac.readonly()\")\n                if cursor.fetchone()[\"readonly\"]:\n                    raise ReadOnlyPgSTACError(\n                        \"PgSTAC instance is set to `read-only`, cannot register search query.\"\n                    )\n\n            # before pgstac 0.8.2, the read-only mode didn't exist\n            except pgErrors.UndefinedFunction:\n                conn.rollback()\n                pass\n\n            cursor.row_factory = class_row(model.Search)\n            cursor.execute(\n                \"SELECT * FROM search_query(%s, _metadata =&gt; %s);\",\n                (\n                    search.model_dump_json(by_alias=True, exclude_none=True),\n                    metadata.model_dump_json(exclude_none=True),\n                ),\n            )\n            search_info: model.Search = cursor.fetchone()\n\n    return search_info.id\n</code></pre>"},{"location":"api/titiler/pgstac/dependencies/#titiler.pgstac.dependencies.get_stac_item","title":"get_stac_item","text":"<pre><code>get_stac_item(pool: ConnectionPool, collection: str, item: str) -&gt; Item\n</code></pre> <p>Get STAC Item from PGStac.</p> Source code in <code>titiler/pgstac/dependencies.py</code> <pre><code>@cached(  # type: ignore\n    TTLCache(maxsize=cache_config.maxsize, ttl=cache_config.ttl),\n    key=lambda pool, collection, item: hashkey(collection, item),\n    lock=Lock(),\n)\n@retry(\n    tries=retry_config.retry,\n    delay=retry_config.delay,\n    exceptions=(\n        pgErrors.OperationalError,\n        pgErrors.InterfaceError,\n    ),\n)\ndef get_stac_item(pool: ConnectionPool, collection: str, item: str) -&gt; pystac.Item:\n    \"\"\"Get STAC Item from PGStac.\"\"\"\n    search = model.PgSTACSearch(ids=[item], collections=[collection])\n    with pool.connection() as conn:\n        with conn.cursor(row_factory=dict_row) as cursor:\n            cursor.execute(\n                (\"SELECT * FROM pgstac.search(%s) LIMIT 1;\"),\n                (search.model_dump_json(by_alias=True, exclude_none=True),),\n            )\n\n            resp = cursor.fetchone()[\"search\"]\n            if not resp or \"features\" not in resp or len(resp[\"features\"]) != 1:\n                raise HTTPException(\n                    status_code=404,\n                    detail=f\"No item '{item}' found in '{collection}' collection\",\n                )\n\n            return pystac.Item.from_dict(resp[\"features\"][0])\n</code></pre>"},{"location":"api/titiler/pgstac/extensions/","title":"extensions","text":""},{"location":"api/titiler/pgstac/extensions/#titiler.pgstac.extensions","title":"titiler.pgstac.extensions","text":"<p>titiler.pgstac extensions.</p>"},{"location":"api/titiler/pgstac/extensions/#titiler.pgstac.extensions.searchInfoExtension","title":"searchInfoExtension  <code>dataclass</code>","text":"<p>               Bases: <code>FactoryExtension</code></p> <p>Add /info endpoint</p>"},{"location":"api/titiler/pgstac/extensions/#titiler.pgstac.extensions.searchInfoExtension.register","title":"register","text":"<pre><code>register(factory: MosaicTilerFactory)\n</code></pre> <p>Register endpoint to the tiler factory.</p>"},{"location":"api/titiler/pgstac/factory/","title":"factory","text":""},{"location":"api/titiler/pgstac/factory/#titiler.pgstac.factory","title":"titiler.pgstac.factory","text":"<p>Custom MosaicTiler Factory for PgSTAC Mosaic Backend.</p>"},{"location":"api/titiler/pgstac/factory/#titiler.pgstac.factory.MosaicTilerFactory","title":"MosaicTilerFactory","text":"<p>               Bases: <code>MosaicTilerFactory</code></p> <p>Custom MosaicTiler for PgSTAC Mosaic Backend.</p>"},{"location":"api/titiler/pgstac/factory/#titiler.pgstac.factory.MosaicTilerFactory.part","title":"part","text":"<pre><code>part()\n</code></pre> <p>Register /bbox and /feature endpoint.</p>"},{"location":"api/titiler/pgstac/factory/#titiler.pgstac.factory.MosaicTilerFactory.register_routes","title":"register_routes","text":"<pre><code>register_routes() -&gt; None\n</code></pre> <p>This Method register routes to the router.</p>"},{"location":"api/titiler/pgstac/factory/#titiler.pgstac.factory.MosaicTilerFactory.statistics","title":"statistics","text":"<pre><code>statistics()\n</code></pre> <p>Register /statistics endpoint.</p>"},{"location":"api/titiler/pgstac/factory/#titiler.pgstac.factory.MosaicTilerFactory.tilejson","title":"tilejson","text":"<pre><code>tilejson() -&gt; None\n</code></pre> <p>register tiles routes.</p>"},{"location":"api/titiler/pgstac/factory/#titiler.pgstac.factory.MosaicTilerFactory.wmts","title":"wmts","text":"<pre><code>wmts()\n</code></pre> <p>Add wmts endpoint.</p>"},{"location":"api/titiler/pgstac/factory/#titiler.pgstac.factory._first_value","title":"_first_value","text":"<pre><code>_first_value(values: List[Any], default: Any = None)\n</code></pre> <p>Return the first not None value.</p>"},{"location":"api/titiler/pgstac/factory/#titiler.pgstac.factory.add_search_list_route","title":"add_search_list_route","text":"<pre><code>add_search_list_route(app: FastAPI, *, prefix: str = '', tags: Optional[List[str]] = None)\n</code></pre> <p>Add PgSTAC Search (of type mosaic) listing route.</p>"},{"location":"api/titiler/pgstac/factory/#titiler.pgstac.factory.add_search_register_route","title":"add_search_register_route","text":"<pre><code>add_search_register_route(app: FastAPI, *, prefix: str = '', search_dependency: Callable[..., Tuple[PgSTACSearch, Metadata]] = SearchParams, tile_dependencies: Optional[List[Callable]] = None, tags: Optional[List[str]] = None)\n</code></pre> <p>add <code>/register</code> route</p>"},{"location":"api/titiler/pgstac/model/","title":"model","text":""},{"location":"api/titiler/pgstac/model/#titiler.pgstac.model","title":"titiler.pgstac.model","text":"<p>Titiler.pgstac models.</p> <p>Note: This is mostly a copy of github.com/stac-utils/stac-fastapi/blob/master/stac_fastapi/pgstac/stac_fastapi/pgstac/types/search.py</p>"},{"location":"api/titiler/pgstac/model/#titiler.pgstac.model.Context","title":"Context","text":"<p>               Bases: <code>BaseModel</code></p> <p>Context Model.</p>"},{"location":"api/titiler/pgstac/model/#titiler.pgstac.model.Context.validate_limit","title":"validate_limit","text":"<pre><code>validate_limit(v, info: ValidationInfo)\n</code></pre> <p>validate limit.</p>"},{"location":"api/titiler/pgstac/model/#titiler.pgstac.model.Info","title":"Info","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for /info endpoint.</p>"},{"location":"api/titiler/pgstac/model/#titiler.pgstac.model.Infos","title":"Infos","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for /list endpoint.</p>"},{"location":"api/titiler/pgstac/model/#titiler.pgstac.model.Link","title":"Link","text":"<p>               Bases: <code>BaseModel</code></p> <p>Link model.</p> <p>Ref: github.com/opengeospatial/ogcapi-tiles/blob/master/openapi/schemas/common-core/link.yaml</p> <p>Code generated using koxudaxi/datamodel-code-generator</p>"},{"location":"api/titiler/pgstac/model/#titiler.pgstac.model.Metadata","title":"Metadata","text":"<p>               Bases: <code>BaseModel</code></p> <p>Metadata Model.</p>"},{"location":"api/titiler/pgstac/model/#titiler.pgstac.model.Metadata.defaults_params","title":"defaults_params  <code>property</code>","text":"<pre><code>defaults_params: Dict[str, Any]\n</code></pre> <p>Return defaults in a form compatible with TiTiler dependencies.</p>"},{"location":"api/titiler/pgstac/model/#titiler.pgstac.model.PgSTACSearch","title":"PgSTACSearch","text":"<p>               Bases: <code>BaseModel</code></p> <p>Search Query model.</p> <p>Notes/Diff with standard model:     - 'fields' is not in the Model because it's defined at the tiler level     - we don't set limit</p>"},{"location":"api/titiler/pgstac/model/#titiler.pgstac.model.PgSTACSearch.validate_bbox","title":"validate_bbox","text":"<pre><code>validate_bbox(v: BBox)\n</code></pre> <p>Validate BBOX.</p>"},{"location":"api/titiler/pgstac/model/#titiler.pgstac.model.PgSTACSearch.validate_datetime","title":"validate_datetime","text":"<pre><code>validate_datetime(v)\n</code></pre> <p>Pgstac does not require the base validator for datetime.</p>"},{"location":"api/titiler/pgstac/model/#titiler.pgstac.model.PgSTACSearch.validate_query_fields","title":"validate_query_fields","text":"<pre><code>validate_query_fields(values: Dict) -&gt; Dict\n</code></pre> <p>Pgstac does not require the base validator for query fields.</p>"},{"location":"api/titiler/pgstac/model/#titiler.pgstac.model.PgSTACSearch.validate_spatial","title":"validate_spatial","text":"<pre><code>validate_spatial(v: Optional[Geometry], info: ValidationInfo)\n</code></pre> <p>Make sure bbox is not used with Intersects.</p>"},{"location":"api/titiler/pgstac/model/#titiler.pgstac.model.RegisterMosaic","title":"RegisterMosaic","text":"<p>               Bases: <code>PgSTACSearch</code></p> <p>Model of /register endpoint input.</p>"},{"location":"api/titiler/pgstac/model/#titiler.pgstac.model.RegisterResponse","title":"RegisterResponse","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for /register endpoint.</p>"},{"location":"api/titiler/pgstac/model/#titiler.pgstac.model.Search","title":"Search","text":"<p>               Bases: <code>BaseModel</code></p> <p>PgSTAC Search entry.</p> <p>ref: github.com/stac-utils/pgstac/blob/3499daa2bfa700ae7bb07503795c169bf2ebafc7/sql/004_search.sql#L907-L915</p>"},{"location":"api/titiler/pgstac/model/#titiler.pgstac.model.Search.validate_metadata","title":"validate_metadata","text":"<pre><code>validate_metadata(v)\n</code></pre> <p>Set SearchType.search when not present in metadata.</p>"},{"location":"api/titiler/pgstac/model/#titiler.pgstac.model.SortExtension","title":"SortExtension","text":"<p>               Bases: <code>BaseModel</code></p> <p>github.com/radiantearth/stac-api-spec/tree/master/extensions/sort#sort-api-extension</p>"},{"location":"api/titiler/pgstac/reader/","title":"reader","text":""},{"location":"api/titiler/pgstac/reader/#titiler.pgstac.reader","title":"titiler.pgstac.reader","text":"<p>Custom STAC reader.</p>"},{"location":"api/titiler/pgstac/reader/#titiler.pgstac.reader.PgSTACReader","title":"PgSTACReader","text":"<p>               Bases: <code>STACReader</code></p> <p>Custom version of rio_tiler.io.STACReader.</p> <p>Only accept <code>pystac.Item</code> as input (while rio_tiler.io.STACReader accepts url or pystac.Item)</p>"},{"location":"api/titiler/pgstac/reader/#titiler.pgstac.reader.PgSTACReader.__attrs_post_init__","title":"__attrs_post_init__","text":"<pre><code>__attrs_post_init__()\n</code></pre> <p>set self.item from input.</p>"},{"location":"api/titiler/pgstac/reader/#titiler.pgstac.reader.SimpleSTACReader","title":"SimpleSTACReader","text":"<p>               Bases: <code>MultiBaseReader</code></p> <p>Simplified STAC Reader.</p> <p>Inputs should be in form of: <pre><code>{\n    \"id\": \"IAMASTACITEM\",\n    \"collection\": \"mycollection\",\n    \"bbox\": (0, 0, 10, 10),\n    \"assets\": {\n        \"COG\": {\n            \"href\": \"https://somewhereovertherainbow.io/cog.tif\"\n        }\n    }\n}\n</code></pre></p>"},{"location":"api/titiler/pgstac/reader/#titiler.pgstac.reader.SimpleSTACReader.__attrs_post_init__","title":"__attrs_post_init__","text":"<pre><code>__attrs_post_init__() -&gt; None\n</code></pre> <p>Set reader spatial infos and list of valid assets.</p>"},{"location":"api/titiler/pgstac/reader/#titiler.pgstac.reader.SimpleSTACReader._get_asset_info","title":"_get_asset_info","text":"<pre><code>_get_asset_info(asset: str) -&gt; AssetInfo\n</code></pre> <p>Validate asset names and return asset's url.</p> <p>Parameters:</p> <ul> <li> <code>asset</code>               (<code>str</code>)           \u2013            <p>STAC asset name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>AssetInfo</code> )          \u2013            <p>STAC asset href.</p> </li> </ul>"},{"location":"api/titiler/pgstac/settings/","title":"settings","text":""},{"location":"api/titiler/pgstac/settings/#titiler.pgstac.settings","title":"titiler.pgstac.settings","text":"<p>API settings.</p>"},{"location":"api/titiler/pgstac/settings/#titiler.pgstac.settings.ApiSettings","title":"ApiSettings","text":"<p>               Bases: <code>BaseSettings</code></p> <p>API settings</p>"},{"location":"api/titiler/pgstac/settings/#titiler.pgstac.settings.ApiSettings.parse_cors_origin","title":"parse_cors_origin","text":"<pre><code>parse_cors_origin(v)\n</code></pre> <p>Parse CORS origins.</p>"},{"location":"api/titiler/pgstac/settings/#titiler.pgstac.settings.CacheSettings","title":"CacheSettings","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Cache settings</p>"},{"location":"api/titiler/pgstac/settings/#titiler.pgstac.settings.CacheSettings.check_enable","title":"check_enable","text":"<pre><code>check_enable()\n</code></pre> <p>Check if cache is disabled.</p>"},{"location":"api/titiler/pgstac/settings/#titiler.pgstac.settings.PgstacSettings","title":"PgstacSettings","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Pgstac settings</p>"},{"location":"api/titiler/pgstac/settings/#titiler.pgstac.settings.PostgresSettings","title":"PostgresSettings","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Postgres-specific API settings.</p> <p>Attributes:</p> <ul> <li> <code>postgres_user</code>               (<code>Optional[str]</code>)           \u2013            <p>postgres username.</p> </li> <li> <code>postgres_pass</code>               (<code>Optional[str]</code>)           \u2013            <p>postgres password.</p> </li> <li> <code>postgres_host</code>               (<code>Optional[str]</code>)           \u2013            <p>database hostname.</p> </li> <li> <code>postgres_port</code>               (<code>Optional[int]</code>)           \u2013            <p>database port.</p> </li> <li> <code>postgres_dbname</code>               (<code>Optional[str]</code>)           \u2013            <p>database name.</p> </li> </ul>"},{"location":"api/titiler/pgstac/settings/#titiler.pgstac.settings.PostgresSettings.assemble_db_connection","title":"assemble_db_connection","text":"<pre><code>assemble_db_connection(v: Optional[str], info: ValidationInfo) -&gt; Any\n</code></pre> <p>Validate database config.</p>"},{"location":"api/titiler/pgstac/settings/#titiler.pgstac.settings._RetrySettings","title":"_RetrySettings","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Retry settings</p>"},{"location":"api/titiler/pgstac/settings/#titiler.pgstac.settings.RetrySettings","title":"RetrySettings  <code>cached</code>","text":"<pre><code>RetrySettings() -&gt; _RetrySettings\n</code></pre> <p>This function returns a cached instance of the RetrySettings object.</p>"},{"location":"api/titiler/pgstac/utils/","title":"utils","text":""},{"location":"api/titiler/pgstac/utils/#titiler.pgstac.utils","title":"titiler.pgstac.utils","text":"<p>titiler.pgstac utilities.</p>"},{"location":"api/titiler/pgstac/utils/#titiler.pgstac.utils.retry","title":"retry","text":"<pre><code>retry(tries: int, exceptions: Union[Type[Exception], Sequence[Type[Exception]]] = Exception, delay: float = 0.0)\n</code></pre> <p>Retry Decorator</p>"},{"location":"endpoints/","title":"Endpoints","text":"<p>By default the main application (<code>titiler.pgstac.main.app</code>) provides three sets of endpoints of access raster dataset:</p> <ul> <li>Searches: Dynamic mosaic tiler based on PgSTAC Search Query</li> <li>Collections: Dynamic mosaic tiler based on STAC Collection</li> <li>Items: Dynamic tiler for single STAC item (stored in PgSTAC)</li> </ul> <p>Some optional endpoints:</p> <ul> <li>Assets (external link): Dynamic tiler a single STAC Asset (stored in PgSTAC), enabled setting <code>TITILER_PGSTAC_API_ENABLE_ASSETS_ENDPOINTS=TRUE</code></li> <li>External Dataset (external link): Dynamic tiler a single Cloud Optimized dataset, enabled setting <code>TITILER_PGSTAC_API_ENABLE_EXTERNAL_DATASET_ENDPOINTS=TRUE</code></li> </ul> <p>And some <code>metadata</code> endpoints:</p> <ul> <li>TileMatrixSets: Available TileMatrixSets for the service</li> <li>Algorithms (external link): Available Algorithms for the service</li> <li>Colormaps (external link): Available Colormaps for the service</li> </ul>"},{"location":"endpoints/collections_endpoints/","title":"Collections","text":""},{"location":"endpoints/collections_endpoints/#stac-collections-endpoints","title":"STAC Collections endpoints","text":"Method URL Output Description <code>GET</code> <code>/collections/{collection_id}/tiles</code> JSON List of OGC Tilesets available <code>GET</code> <code>/collections/{collection_id}/tiles/{tileMatrixSetId}</code> JSON OGC Tileset metadata <code>GET</code> <code>/collections/{collection_id}/tiles/{TileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin Create a web map tile image for a collection and a tile index <code>GET</code> <code>/collections/{collection_id}/{TileMatrixSetId}/map.html</code> HTML simple map viewer <code>GET</code> <code>/collections/{collection_id}/{TileMatrixSetId}/tilejson.json</code> JSON (TileJSON) Return a Mapbox TileJSON document <code>GET</code> <code>/collections/{collection_id}/{TileMatrixSetId}/WMTSCapabilities.xml</code> XML return OGC WMTS Get Capabilities <code>POST</code> <code>/collections/{collection_id}/statistics</code> GeoJSON (Statistics) Return statistics for geojson features <code>GET</code> <code>/collections/{collection_id}/bbox/{minx},{miny},{maxx},{maxy}[/{width}x{height}].{format}</code> image/bin Create an image from part of a dataset <code>POST</code> <code>/collections/{collection_id}/feature[/{width}x{height}][.{format}]</code> image/bin Create an image from a GeoJSON feature <code>GET</code> <code>/collections/{collection_id}/point/{lon},{lat}</code> JSON (Point) Return pixel values from assets intersecting with a given point <code>GET</code> <code>/collections/{collection_id}/point/{lon},{lat}/assets</code> JSON Return a list of assets which overlap a given point <code>GET</code> <code>/collections/{collection_id}/bbox/{minx},{miny},{maxx},{maxy}/assets</code> JSON Return a list of assets which overlap a given bounding box <code>GET</code> <code>/collections/{collection_id}/tiles/{TileMatrixSetId}/{z}/{x}/{Y}/assets</code> JSON Return a list of assets which overlap a given tile <code>GET</code> <code>/collections/{collection_id}/info</code> JSON ([Info][info_model]) Return Search query infos from <code>collection_id</code>"},{"location":"endpoints/collections_endpoints/#tiles","title":"Tiles","text":"<p><code>:endpoint:/collections/{collection_id}/tiles/{TileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id: STAC Collection Identifier.</li> <li>TileMatrixSetId: TileMatrixSet name.</li> <li>z: Tile's zoom level.</li> <li>x: Tile's column.</li> <li>y: Tile's row.</li> <li>scale: Tile size scale, default is set to 1 (256x256). OPTIONAL</li> <li>format: Output image format, default is set to None and will be either JPEG or PNG depending on masked value. OPTIONAL</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band index (e.g <code>Asset1|1;2;3</code>).</li> <li>nodata: Overwrite internal Nodata value. OPTIONAL</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Buffer on each side of the given tile. It must be a multiple of <code>0.5</code>. Output tilesize will be expanded to <code>tilesize + 2 * buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258).</li> <li>padding (int): Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to <code>0</code></li> <li>pixel_selection (str): Pixel selection method (cogeotiff.github.io/rio-tiler/mosaic/).</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> <li>ids (str): Array of Item ids to show.</li> <li>bbox (str): Filters items intersecting this bounding box.</li> <li>datetime (str):Filters items that have a temporal property that intersects this value. Either a date-time or an interval, open or closed.</li> <li>query (str): Filters items based on property values.</li> <li>sortby (str): Comma \",\" delimited property names, prefixed by either '+' for ascending or '-' for descending. If no prefix is provided, '+' is assumed.</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/my-collection/tiles/WebMercatorQuad/1/2/3?assets=B01</code></li> <li><code>https://myendpoint/collections/my-collection/tiles/WebMercatorQuad/1/2/3.jpg?assets=B01</code></li> <li><code>https://myendpoint/collections/my-collection/tiles/WorldCRS84Quad/1/2/3@2x.png?assets=B01&amp;assets=B02&amp;assets=B03</code></li> <li><code>https://myendpoint/collections/my-collection/tiles/WorldCRS84Quad/1/2/3?assets=B01&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul>"},{"location":"endpoints/collections_endpoints/#tilesjson","title":"TilesJSON","text":"<p><code>:endpoint:/collections/{collection_id}/{TileMatrixSetId}/tilejson.json</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id: STAC Collection Identifier.</li> <li>TileMatrixSetId: TileMatrixSet name.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>tile_format: Output image format, default is set to None and will be either JPEG or PNG depending on masked value.</li> <li>tile_scale: Tile size scale, default is set to 1 (256x256). OPTIONAL</li> <li>minzoom: Overwrite default minzoom. OPTIONAL</li> <li>maxzoom: Overwrite default maxzoom. OPTIONAL</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band index (e.g <code>Asset1|1;2;3</code>).</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Buffer on each side of the given tile. It must be a multiple of <code>0.5</code>. Output tilesize will be expanded to <code>tilesize + 2 * buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258).</li> <li>padding (int): Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to <code>0</code></li> <li>pixel_selection (str): Pixel selection method (cogeotiff.github.io/rio-tiler/mosaic/).</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> <li>ids (str): Array of Item ids to show.</li> <li>bbox (str): Filters items intersecting this bounding box.</li> <li>datetime (str):Filters items that have a temporal property that intersects this value. Either a date-time or an interval, open or closed.</li> <li>query (str): Filters items based on property values.</li> <li>sortby (str): Comma \",\" delimited property names, prefixed by either '+' for ascending or '-' for descending. If no prefix is provided, '+' is assumed.</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/my-collection/WebMercatorQuad/tilejson.json?assets=B01</code></li> <li><code>https://myendpoint/collections/my-collection/WebMercatorQuad/tilejson.json?assets=B01&amp;tile_format=png</code></li> <li><code>https://myendpoint/collections/my-collection/WorldCRS84Quad/tilejson.json?assets=B01&amp;tile_scale=2</code></li> </ul>"},{"location":"endpoints/collections_endpoints/#wmts","title":"WMTS","text":"<p><code>:endpoint:/collections/{collection_id}/{TileMatrixSetId}/WMTSCapabilities.xml</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id: STAC Collection Identifier.</li> <li>TileMatrixSetId: TileMatrixSet name.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>tile_format: Output image format, default is set to PNG.</li> <li>tile_scale: Tile size scale, default is set to 1 (256x256). OPTIONAL</li> <li>minzoom: Overwrite default minzoom. OPTIONAL</li> <li>maxzoom: Overwrite default maxzoom. OPTIONAL</li> <li>ids (str): Array of Item ids to show.</li> <li>bbox (str): Filters items intersecting this bounding box.</li> <li>datetime (str):Filters items that have a temporal property that intersects this value. Either a date-time or an interval, open or closed.</li> <li>query (str): Filters items based on property values.</li> <li>sortby (str): Comma \",\" delimited property names, prefixed by either '+' for ascending or '-' for descending. If no prefix is provided, '+' is assumed.</li> </ul> </li> </ul> <p>Important</p> <p>additional query-parameters will be forwarded to the <code>tile</code> URL. If no <code>defaults</code> mosaic metadata, assets OR expression will be required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/my-collection/WebMercatorQuad/WMTSCapabilities.xml?assets=B01</code></li> <li><code>https://myendpoint/collections/my-collection/WebMercatorQuad/WMTSCapabilities.xml?assets=B01&amp;tile_format=png</code></li> <li><code>https://myendpoint/collections/my-collection/WorldCRS84Quad/WMTSCapabilities.xml?assets=B01&amp;tile_scale=2</code></li> </ul>"},{"location":"endpoints/collections_endpoints/#assets-for-point-or-tile-or-bbox","title":"Assets for Point or Tile or bbox","text":"<p><code>:endpoint:/collections/{collection_id}/tiles/{TileMatrixSetId}/{z}/{x}/{y}/assets</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id: STAC Collection Identifier.</li> <li>TileMatrixSetId: TileMatrixSet name.</li> <li>z: Tile's zoom level.</li> <li>x: Tile's column.</li> <li>y: Tile's row.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> <li>ids (str): Array of Item ids to show.</li> <li>bbox (str): Filters items intersecting this bounding box.</li> <li>datetime (str):Filters items that have a temporal property that intersects this value. Either a date-time or an interval, open or closed.</li> <li>query (str): Filters items based on property values.</li> <li>sortby (str): Comma \",\" delimited property names, prefixed by either '+' for ascending or '-' for descending. If no prefix is provided, '+' is assumed.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/my-collection/tiles/WebMercatorQuad/0/0/0/assets</code></li> </ul> <p><code>:endpoint:/collections/{collection_id}/point/{lon},{lat}/assets</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id: STAC Collection Identifier.</li> <li>lon: Longitude (in WGS84 CRS).</li> <li>lat: Latitude (in WGS84 CRS).</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> <li>ids (str): Array of Item ids to show.</li> <li>bbox (str): Filters items intersecting this bounding box.</li> <li>datetime (str):Filters items that have a temporal property that intersects this value. Either a date-time or an interval, open or closed.</li> <li>query (str): Filters items based on property values.</li> <li>sortby (str): Comma \",\" delimited property names, prefixed by either '+' for ascending or '-' for descending. If no prefix is provided, '+' is assumed.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/my-collection/point/0.0,0.0/assets</code></li> </ul> <p><code>:endpoint:/collections/{collection_id}/bbox/{minx},{miny},{maxx},{maxy}/assets</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id: STAC Collection Identifier.</li> <li>minx,miny,maxx,maxy (str): Comma (',') delimited bounding box</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>coord_crs (str): Coordinate Reference System of the input coordinates. Default to <code>epsg:4326</code>.</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> <li>ids (str): Array of Item ids to show.</li> <li>bbox (str): Filters items intersecting this bounding box.</li> <li>datetime (str):Filters items that have a temporal property that intersects this value. Either a date-time or an interval, open or closed.</li> <li>query (str): Filters items based on property values.</li> <li>sortby (str): Comma \",\" delimited property names, prefixed by either '+' for ascending or '-' for descending. If no prefix is provided, '+' is assumed.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/my-collection/bbox/0,0,0,0/assets</code></li> </ul>"},{"location":"endpoints/collections_endpoints/#statistics","title":"Statistics","text":"<p><code>:endpoint:/collections/{collection_id}/statistics - [POST]</code></p> <ul> <li> <p>Body:</p> <ul> <li>feature (JSON): A valid GeoJSON feature or FeatureCollection</li> </ul> </li> <li> <p>PathParams:</p> <ul> <li>collection_id: STAC Collection Identifier.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band index (e.g <code>Asset1|1;2;3</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input geometry. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size from which to calculate statistics.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>nodata: Overwrite internal Nodata value. OPTIONAL</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds.</li> <li>pixel_selection (str): Pixel selection method (cogeotiff.github.io/rio-tiler/mosaic/).</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> <li>ids (str): Array of Item ids to show.</li> <li>bbox (str): Filters items intersecting this bounding box.</li> <li>datetime (str):Filters items that have a temporal property that intersects this value. Either a date-time or an interval, open or closed.</li> <li>query (str): Filters items based on property values.</li> <li>sortby (str): Comma \",\" delimited property names, prefixed by either '+' for ascending or '-' for descending. If no prefix is provided, '+' is assumed.</li> </ul> </li> </ul> <p>Important</p> <p>if height or width is provided max_size will be ignored.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/my-collection/statistics?assets=B01</code></li> </ul>"},{"location":"endpoints/collections_endpoints/#bbox","title":"Bbox","text":"<p><code>:endpoint:/collections/{collection_id}/bbox/{minx},{miny},{maxx},{maxy}.{format}</code></p> <p><code>:endpoint:/collections/{collection_id}/bbox/{minx},{miny},{maxx},{maxy}/{width}x{height}.{format}</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id: STAC Collection Identifier.</li> <li>minx,miny,maxx,maxy (str): Comma (',') delimited bounding box in WGS84.</li> <li>format (str): Output image format.</li> <li>height (int): Force output image height.</li> <li>width (int): Force output image width.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band index (e.g <code>Asset1|1;2;3</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input coordinates. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size.</li> <li>nodata: Overwrite internal Nodata value. OPTIONAL</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>pixel_selection (str): Pixel selection method (cogeotiff.github.io/rio-tiler/mosaic/).</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> <li>ids (str): Array of Item ids to show.</li> <li>bbox (str): Filters items intersecting this bounding box.</li> <li>datetime (str):Filters items that have a temporal property that intersects this value. Either a date-time or an interval, open or closed.</li> <li>query (str): Filters items based on property values.</li> <li>sortby (str): Comma \",\" delimited property names, prefixed by either '+' for ascending or '-' for descending. If no prefix is provided, '+' is assumed.</li> </ul> </li> </ul> <p>Important</p> <p>if height or width is provided max_size will be ignored.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/my-collection/bbox/0,0,10,10.png?assets=B01</code></li> <li><code>https://myendpoint/collections/my-collection/bbox/0,0,10,10/400x300.png?assets=B01</code></li> </ul>"},{"location":"endpoints/collections_endpoints/#feature","title":"Feature","text":"<p><code>:endpoint:/collections/{collection_id}/feature - [POST]</code></p> <p><code>:endpoint:/collections/{collection_id}/feature.{format} - [POST]</code></p> <p><code>:endpoint:/collections/{collection_id}/feature/{width}x{height}.{format} - [POST]</code></p> <ul> <li> <p>Body:</p> <ul> <li>feature (JSON): A valid GeoJSON feature (Polygon or MultiPolygon)</li> </ul> </li> <li> <p>PathParams:</p> <ul> <li>collection_id: STAC Collection Identifier.</li> <li>height (int): Force output image height. Optional</li> <li>width (int): Force output image width. Optional</li> <li>format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band index (e.g <code>Asset1|1;2;3</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input geometry. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size.</li> <li>nodata: Overwrite internal Nodata value. OPTIONAL</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>pixel_selection (str): Pixel selection method (cogeotiff.github.io/rio-tiler/mosaic/).</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> <li>ids (str): Array of Item ids to show.</li> <li>bbox (str): Filters items intersecting this bounding box.</li> <li>datetime (str):Filters items that have a temporal property that intersects this value. Either a date-time or an interval, open or closed.</li> <li>query (str): Filters items based on property values.</li> <li>sortby (str): Comma \",\" delimited property names, prefixed by either '+' for ascending or '-' for descending. If no prefix is provided, '+' is assumed.</li> </ul> </li> </ul> <p>Important</p> <p>if height or width is provided max_size will be ignored.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/my-collection/feature?assets=B01</code></li> <li><code>https://myendpoint/collections/my-collection/feature.png?assets=B01f</code></li> <li><code>https://myendpoint/collections/my-collection/feature/100x100.png?assets=B01</code></li> </ul>"},{"location":"endpoints/collections_endpoints/#point","title":"Point","text":"<p><code>:endpoint:/collections/{collection_id}/point/{lon},{lat}</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id: STAC Collection Identifier.</li> <li>lon: Longitude (in <code>coord-crs</code>, defaults to <code>WGS84</code>).</li> <li>lat: Latitude (in <code>coord-crs</code>, defaults to <code>WGS84</code>).</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band index (e.g <code>Asset1|1;2;3</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input geometry. Default to <code>epsg:4326</code>.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> <li>ids (str): Array of Item ids to show.</li> <li>bbox (str): Filters items intersecting this bounding box.</li> <li>datetime (str):Filters items that have a temporal property that intersects this value. Either a date-time or an interval, open or closed.</li> <li>query (str): Filters items based on property values.</li> <li>sortby (str): Comma \",\" delimited property names, prefixed by either '+' for ascending or '-' for descending. If no prefix is provided, '+' is assumed.</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/my-collection/point/0,0?assets=B01</code></li> </ul>"},{"location":"endpoints/collections_endpoints/#collection-search-infos","title":"Collection Search infos","text":"<p><code>:endpoint:/collections/{collection_id}/info - [GET]</code></p> <ul> <li>PathParams:<ul> <li>collection_id: STAC Collection Identifier.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/my-collection/info</code></li> </ul> <pre><code>curl 'http://myendpoint/collections/my-collection/info' | jq\n&gt;&gt; {\n  \"search\": {\n    \"hash\": \"37c6ebb942cc5393a9eb408ad8431f62\",\n    \"search\": {\n      \"collections\": [\n        \"my-collection\"\n      ]\n    },\n    \"_where\": \"collection = ANY ('{my-collection}') \",\n    \"orderby\": \"datetime DESC, id DESC\",\n    \"lastused\": \"2024-05-17T06:44:45.980518Z\",\n    \"usecount\": 1,\n    \"metadata\": {\n      \"type\": \"mosaic\",\n      \"bounds\": [\n        91.831615,\n        19.982078842323997,\n        92.97426268500965,\n        21.666101\n      ],\n      \"name\": \"Mosaic for 'my-collection' Collection\",\n      \"assets\": [\n        \"visual\",\n        \"data-mask\",\n        \"ms_analytic\",\n        \"pan_analytic\"\n      ],\n      \"defaults\": {\n        \"color\": {\n          \"assets\": [\n            \"visual\"\n          ],\n          \"colormap\": {\n            \"1\": [\n              0,\n              0,\n              0,\n              255\n            ],\n            \"1000\": [\n              255,\n              255,\n              255,\n              255\n            ]\n          },\n          \"asset_bidx\": [\"visual|1\"]\n        },\n        \"visual\": {\n          \"assets\": [\n            \"visual\"\n          ],\n          \"maxzoom\": 22,\n          \"minzoom\": 8,\n          \"asset_bidx\": [\"visual|1,2,3\"]\n        },\n        \"visualr\": {\n          \"assets\": [\n            \"visual\"\n          ],\n          \"rescale\": [\n            [\n              0,\n              100\n            ]\n          ],\n          \"asset_bidx\": [\"visual|1\"]\n        }\n      }\n    }\n  },\n  \"links\": [\n    {\n      \"href\": \"http://myendpoint/collections/my-collection/info\",\n      \"rel\": \"self\",\n      \"title\": \"Mosaic metadata\"\n    },\n    {\n      \"href\": \"http://myendpoint/collections/my-collection/{tileMatrixSetId}/tilejson.json\",\n      \"rel\": \"tilejson\",\n      \"templated\": true,\n      \"title\": \"TileJSON link (Template URL).\"\n    },\n    {\n      \"href\": \"http://myendpoint/collections/my-collection/{tileMatrixSetId}/tilejson.json?colormap=%7B%221%22%3A+%5B0%2C+0%2C+0%2C+255%5D%2C+%221000%22%3A+%5B255%2C+255%2C+255%2C+255%5D%7D&amp;assets=visual&amp;asset_bidx=visual%7C1\",\n      \"rel\": \"tilejson\",\n      \"templated\": true,\n      \"title\": \"TileJSON link for `color` layer (Template URL).\"\n    },\n    {\n      \"href\": \"http://myendpoint/collections/my-collection/{tileMatrixSetId}/tilejson.json?maxzoom=22&amp;minzoom=8&amp;assets=visual&amp;asset_bidx=visual%7C1%2C2%2C3\",\n      \"rel\": \"tilejson\",\n      \"templated\": true,\n      \"title\": \"TileJSON link for `visual` layer (Template URL).\"\n    },\n    {\n      \"href\": \"http://myendpoint/collections/my-collection/{tileMatrixSetId}/tilejson.json?rescale=0%2C100&amp;assets=visual&amp;asset_bidx=visual%7C1\",\n      \"rel\": \"tilejson\",\n      \"templated\": true,\n      \"title\": \"TileJSON link for `visualr` layer (Template URL).\"\n    },\n    {\n      \"href\": \"http://myendpoint/collections/my-collection/{tileMatrixSetId}/map.html\",\n      \"rel\": \"map\",\n      \"templated\": true,\n      \"title\": \"Map viewer link (Template URL).\"\n    },\n    {\n      \"href\": \"http://myendpoint/collections/my-collection/{tileMatrixSetId}/map.html?colormap=%7B%221%22%3A+%5B0%2C+0%2C+0%2C+255%5D%2C+%221000%22%3A+%5B255%2C+255%2C+255%2C+255%5D%7D&amp;assets=visual&amp;asset_bidx=visual%7C1\",\n      \"rel\": \"map\",\n      \"templated\": true,\n      \"title\": \"Map viewer link for `color` layer (Template URL).\"\n    },\n    {\n      \"href\": \"http://myendpoint/collections/my-collection/{tileMatrixSetId}/map.html?maxzoom=22&amp;minzoom=8&amp;assets=visual&amp;asset_bidx=visual%7C1%2C2%2C3\",\n      \"rel\": \"map\",\n      \"templated\": true,\n      \"title\": \"Map viewer link for `visual` layer (Template URL).\"\n    },\n    {\n      \"href\": \"http://myendpoint/collections/my-collection/{tileMatrixSetId}/map.html?rescale=0%2C100&amp;assets=visual&amp;asset_bidx=visual%7C1\",\n      \"rel\": \"map\",\n      \"templated\": true,\n      \"title\": \"Map viewer link for `visualr` layer (Template URL).\"\n    },\n    {\n      \"href\": \"http://myendpoint/collections/my-collection/{tileMatrixSetId}/WMTSCapabilities.xml\",\n      \"rel\": \"wmts\",\n      \"templated\": true,\n      \"title\": \"WMTS link (Template URL)\"\n    }\n  ]\n}\n</code></pre>"},{"location":"endpoints/items_endpoints/","title":"Items","text":""},{"location":"endpoints/items_endpoints/#stac-items-endpoints","title":"STAC Items endpoints","text":"<p>The <code>Item</code> endpoints are created using TiTiler's MultiBaseTilerFactory</p> Method URL Output Description <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/bounds</code> JSON (Bounds) return dataset's bounds <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/assets</code> JSON return the list of available assets <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/info</code> JSON (Info) return assets basic info <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/info.geojson</code> GeoJSON (InfoGeoJSON) return assets basic info as a GeoJSON feature <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/asset_statistics</code> JSON (Statistics) return per asset statistics <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/statistics</code> JSON (Statistics) return assets statistics (merged) <code>POST</code> <code>/collections/{collection_id}/items/{item_id}/statistics</code> GeoJSON (Statistics) return assets statistics for a GeoJSON (merged) <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/tiles[/{TileMatrixSetId}]/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin create a web map tile image from assets <code>GET</code> <code>/collections/{collection_id}/items/{item_id}[/{TileMatrixSetId}]/tilejson.json</code> JSON (TileJSON) return a Mapbox TileJSON document <code>GET</code> <code>/collections/{collection_id}/items/{item_id}[/{TileMatrixSetId}]/WMTSCapabilities.xml</code> XML return OGC WMTS Get Capabilities <code>GET</code> <code>/collections/{collection_id}/items/{item_id}[/{TileMatrixSetId}]/map.html</code> HTML simple map viewer <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/point/{lon},{lat}</code> JSON (Point) return pixel values from assets <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/preview[.{format}]</code> image/bin create a preview image from assets <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/bbox/{minx},{miny},{maxx},{maxy}[/{width}x{height}].{format}</code> image/bin create an image from part of assets <code>POST</code> <code>/collections/{collection_id}/items/{item_id}/feature[/{width}x{height}][.{format}]</code> image/bin create an image from a geojson feature intersecting assets"},{"location":"endpoints/items_endpoints/#tiles","title":"Tiles","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/tiles[/{TileMatrixSetId}]/{z}/{x}/{y}[@{scale}x][.{format}]</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection Identifier.</li> <li>item_id (str): STAC Item Identifier.</li> <li>TileMatrixSetId (str): TileMatrixSet name, default is <code>WebMercatorQuad</code>. Optional</li> <li>z (int): TMS tile's zoom level.</li> <li>x (int): TMS tile's column.</li> <li>y (int): TMS tile's row.</li> <li>scale (int): Tile size scale, default is set to 1 (256x256). Optional</li> <li>format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Buffer on each side of the given tile. It must be a multiple of <code>0.5</code>. Output tilesize will be expanded to <code>tilesize + 2 * buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258).</li> <li>padding (int): Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to <code>0</code></li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/tiles/1/2/3?assets=B01&amp;assets=B00</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/tiles/1/2/3.jpg?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/tiles/WorldCRS84Quad/1/2/3@2x.png?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/tiles/WorldCRS84Quad/1/2/3?expression=B01/B02&amp;rescale=0,1000&amp;colormap_name=cfastie&amp;asset_as_band=True</code></li> </ul>"},{"location":"endpoints/items_endpoints/#preview","title":"Preview","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/preview[.{format}]</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection Identifier.</li> <li>item_id (str): STAC Item Identifier.</li> <li>format: Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>max_size (int): Max image size, default is 1024.</li> <li>height (int): Force output image height.</li> <li>width (int): Force output image width.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to dataset's CRS.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Important</p> <ul> <li> <p>assets OR expression is required</p> </li> <li> <p>if height and width are provided max_size will be ignored.</p> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/preview?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/preview.jpg?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/preview?assets=B01&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul>"},{"location":"endpoints/items_endpoints/#bboxfeature","title":"BBOX/Feature","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/bbox/{minx},{miny},{maxx},{maxy}.{format}</code> <code>:endpoint:/collections/{collection_id}/items/{item_id}/bbox/{minx},{miny},{maxx},{maxy}/{width}x{height}.{format}</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection Identifier.</li> <li>item_id (str): STAC Item Identifier.</li> <li>minx,miny,maxx,maxy (str): Comma (',') delimited bounding box in WGS84.</li> <li>height (int): Force output image height. Optional</li> <li>width (int): Force output image width. Optional</li> <li>format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>max_size (int): Max image size.</li> <li>coord_crs (str): Coordinate Reference System of the input coordinates. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Important</p> <ul> <li> <p>assets OR expression is required</p> </li> <li> <p>if height and width are provided max_size will be ignored.</p> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/bbox/0,0,10,10.png?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/bbox/0,0,10,10.png?assets=B01&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul> <p><code>:endpoint:/collections/{collection_id}/items/{item_id}/feature[/{width}x{height}][].{format}] - [POST]</code></p> <ul> <li> <p>Body:</p> <ul> <li>feature (JSON): A valid GeoJSON feature (Polygon or MultiPolygon)</li> </ul> </li> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection Identifier.</li> <li>item_id (str): STAC Item Identifier.</li> <li>height (int): Force output image height. Optional</li> <li>width (int): Force output image width. Optional</li> <li>format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>max_size (int): Max image size.</li> <li>coord_crs (str): Coordinate Reference System of the input coordinates. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Important</p> <ul> <li> <p>assets OR expression is required</p> </li> <li> <p>if height and width are provided max_size will be ignored.</p> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/crop?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/crop.png?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/100x100.png?assets=B01&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul>"},{"location":"endpoints/items_endpoints/#point","title":"Point","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/point/{lon},{lat}</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection Identifier.</li> <li>item_id (str): STAC Item Identifier.</li> <li>lon,lat, (str): Comma (',') delimited point Longitude and Latitude WGS84.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/point/0,0?assets=B01</code></li> </ul>"},{"location":"endpoints/items_endpoints/#tilesjson","title":"TilesJSON","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}[/{TileMatrixSetId}]/tilejson.json</code> tileJSON document</p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection Identifier.</li> <li>item_id (str): STAC Item Identifier.</li> <li>TileMatrixSetId: TileMatrixSet name, default is <code>WebMercatorQuad</code>.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>tile_format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value.</li> <li>tile_scale (int): Tile size scale, default is set to 1 (256x256).</li> <li>minzoom (int): Overwrite default minzoom.</li> <li>maxzoom (int): Overwrite default maxzoom.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Buffer on each side of the given tile. It must be a multiple of <code>0.5</code>. Output tilesize will be expanded to <code>tilesize + 2 * buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258).</li> <li>padding (int): Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to <code>0</code></li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/tilejson.json?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/tilejson.json?assets=B01&amp;tile_format=png</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/WorldCRS84Quad/tilejson.json?tile_scale=2&amp;expression=B01/B02&amp;asset_as_band=True</code></li> </ul>"},{"location":"endpoints/items_endpoints/#bounds","title":"Bounds","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/bounds</code> - Return the bounds of the STAC item.</p> <ul> <li>PathParams:<ul> <li>collection_id (str): STAC Collection Identifier.</li> <li>item_id (str): STAC Item Identifier.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/bounds</code></li> </ul>"},{"location":"endpoints/items_endpoints/#info","title":"Info","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/info</code> - Return basic info on STAC item's COG.</p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection Identifier.</li> <li>item_id (str): STAC Item Identifier.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names. Default to all available assets.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/info?assets=B01</code></li> </ul> <p><code>:endpoint:/collections/{collection_id}/items/{item_id}/info.geojson</code> - Return basic info on STAC item's COG as a GeoJSON feature</p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection Identifier.</li> <li>item_id (str): STAC Item Identifier.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>collection (str): STAC Collection Identifier. Required</li> <li>item (str): STAC Item Identifier. Required</li> <li>assets (array[str]): asset names. Default to all available assets.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/info.geojson?assets=B01</code></li> </ul> <p><code>:endpoint:/collections/{collection_id}/items/{item_id}/assets</code> - Return the list of available assets</p>"},{"location":"endpoints/items_endpoints/#available-assets","title":"Available Assets","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/assets</code> - Return a list of available assets</p> <ul> <li>PathParams:<ul> <li>collection_id (str): STAC Collection Identifier.</li> <li>item_id (str): STAC Item Identifier.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/assets</code></li> </ul>"},{"location":"endpoints/items_endpoints/#statistics","title":"Statistics","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/asset_statistics - [GET]</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection Identifier.</li> <li>item_id (str): STAC Item Identifier.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>collection (str): STAC Collection Identifier. Required</li> <li>item (str): STAC Item Identifier. Required</li> <li>assets (array[str]): asset names. Default to all available assets.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>asset_expression (array[str]): Per asset band math expression (e.g <code>Asset1|b1\\*b2</code>).</li> <li>max_size (int): Max image size from which to calculate statistics, default is 1024.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/statistics?assets=B01&amp;categorical=true&amp;c=1&amp;c=2&amp;c=3&amp;p=2&amp;p98</code></li> </ul> <p><code>:endpoint:/collections/{collection_id}/items/{item_id}/statistics - [GET]</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection Identifier.</li> <li>item_id (str): STAC Item Identifier.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>collection (str): STAC Collection Identifier. Required</li> <li>item (str): STAC Item Identifier. Required</li> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>max_size (int): Max image size from which to calculate statistics, default is 1024.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/statistics?assets=B01&amp;categorical=true&amp;c=1&amp;c=2&amp;c=3&amp;p=2&amp;p98</code></li> </ul> <p><code>:endpoint:/collections/{collection_id}/items/{item_id}/statistics - [POST]</code></p> <ul> <li> <p>Body:</p> <ul> <li>feature (JSON): A valid GeoJSON feature or FeatureCollection</li> </ul> </li> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection Identifier.</li> <li>item_id (str): STAC Item Identifier.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>max_size (int): Max image size from which to calculate statistics.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>coord_crs (str): Coordinate Reference System of the input coordinates. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/statistics?assets=B01&amp;categorical=true&amp;c=1&amp;c=2&amp;c=3&amp;p=2&amp;p98</code></li> </ul>"},{"location":"endpoints/searches_endpoints/","title":"Searches","text":""},{"location":"endpoints/searches_endpoints/#stac-searches-endpoints","title":"STAC Searches endpoints","text":"Method URL Output Description <code>GET</code> <code>/searches/{search_id}/tiles</code> JSON List of OGC Tilesets available <code>GET</code> <code>/searches/{search_id}/tiles/{tileMatrixSetId}</code> JSON OGC Tileset metadata <code>GET</code> <code>/searches/{search_id}/tiles/{TileMatrixSetId}/{z}/{x}/{Y}/assets</code> JSON Return a list of assets which overlap a given tile <code>GET</code> <code>/searches/{search_id}/tiles/{TileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin Create a web map tile image for a search query and a tile index <code>GET</code> <code>/searches/{search_id}/{TileMatrixSetId}/map</code> HTML simple map viewer <code>GET</code> <code>/searches/{search_id}/{TileMatrixSetId}/tilejson.json</code> JSON (TileJSON) Return a Mapbox TileJSON document <code>GET</code> <code>/searches/{search_id}/{TileMatrixSetId}/WMTSCapabilities.xml</code> XML return OGC WMTS Get Capabilities <code>GET</code> <code>/searches/{search_id}/bbox/{minx},{miny},{maxx},{maxy}[/{width}x{height}].{format}</code> image/bin Create an image from part of a dataset <code>POST</code> <code>/searches/{search_id}/feature[/{width}x{height}][.{format}]</code> image/bin Create an image from a GeoJSON feature <code>GET</code> <code>/searches/{search_id}/point/{lon},{lat}</code> JSON (Point) Return pixel values from assets intersecting with a given point <code>GET</code> <code>/searches/{search_id}/point/{lon},{lat}/assets</code> JSON Return a list of assets which overlap a given point <code>POST</code> <code>/searches/{search_id}/statistics</code> GeoJSON (Statistics) Return statistics for geojson features <code>GET</code> <code>/searches/{search_id}/info</code> JSON (Info) Return Search query infos <code>POST</code> <code>/searches/register</code> JSON (Register) Register Search query <code>GET</code> <code>/searches/list</code> JSON (Infos) Return list of Search entries with <code>Mosaic</code> type"},{"location":"endpoints/searches_endpoints/#tiles","title":"Tiles","text":"<p><code>:endpoint:/searches/{search_id}/tiles/{TileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>search_id: PgSTAC Search Identifier (Hash).</li> <li>TileMatrixSetId: TileMatrixSet name.</li> <li>x: Tile's column.</li> <li>y: Tile's row.</li> <li>scale: Tile size scale, default is set to 1 (256x256). OPTIONAL</li> <li>format: Output image format, default is set to None and will be either JPEG or PNG depending on masked value. OPTIONAL</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band index (e.g <code>Asset1|1;2;3</code>).</li> <li>nodata: Overwrite internal Nodata value. OPTIONAL</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Buffer on each side of the given tile. It must be a multiple of <code>0.5</code>. Output tilesize will be expanded to <code>tilesize + 2 * buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258).</li> <li>padding (int): Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to <code>0</code></li> <li>pixel_selection (str): Pixel selection method (cogeotiff.github.io/rio-tiler/mosaic/).</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/searches/f1ed59f0a6ad91ed80ae79b7b52bc707/tiles/WebMercatorQuad/1/2/3?assets=B01</code></li> <li><code>https://myendpoint/searches/f1ed59f0a6ad91ed80ae79b7b52bc707/tiles/WebMercatorQuad/1/2/3.jpg?assets=B01</code></li> <li><code>https://myendpoint/searches/f1ed59f0a6ad91ed80ae79b7b52bc707/tiles/WorldCRS84Quad/1/2/3@2x.png?assets=B01&amp;assets=B02&amp;assets=B03</code></li> <li><code>https://myendpoint/searches/f1ed59f0a6ad91ed80ae79b7b52bc707/tiles/WorldCRS84Quad/1/2/3?assets=B01&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul>"},{"location":"endpoints/searches_endpoints/#tilesjson","title":"TilesJSON","text":"<p><code>:endpoint:/searches/{search_id}/{TileMatrixSetId}/tilejson.json</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>search_id: PgSTAC Search Identifier (Hash).</li> <li>TileMatrixSetId: TileMatrixSet name.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>tile_format: Output image format, default is set to None and will be either JPEG or PNG depending on masked value.</li> <li>tile_scale: Tile size scale, default is set to 1 (256x256). OPTIONAL</li> <li>minzoom: Overwrite default minzoom. OPTIONAL</li> <li>maxzoom: Overwrite default maxzoom. OPTIONAL</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band index (e.g <code>Asset1|1;2;3</code>).</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Buffer on each side of the given tile. It must be a multiple of <code>0.5</code>. Output tilesize will be expanded to <code>tilesize + 2 * buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258).</li> <li>padding (int): Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to <code>0</code></li> <li>pixel_selection (str): Pixel selection method (cogeotiff.github.io/rio-tiler/mosaic/).</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/searches/f1ed59f0a6ad91ed80ae79b7b52bc707/WebMercatorQuad/tilejson.json?assets=B01</code></li> <li><code>https://myendpoint/searches/f1ed59f0a6ad91ed80ae79b7b52bc707/WebMercatorQuad/tilejson.json?assets=B01&amp;tile_format=png</code></li> <li><code>https://myendpoint/searches/f1ed59f0a6ad91ed80ae79b7b52bc707/WorldCRS84Quad/tilejson.json?assets=B01&amp;tile_scale=2</code></li> </ul>"},{"location":"endpoints/searches_endpoints/#wmts","title":"WMTS","text":"<p><code>:endpoint:/searches/{search_id}/{TileMatrixSetId}/WMTSCapabilities.xml</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>search_id: PgSTAC Search Identifier (Hash).</li> <li>TileMatrixSetId: TileMatrixSet name.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>tile_format: Output image format, default is set to PNG.</li> <li>tile_scale: Tile size scale, default is set to 1 (256x256). OPTIONAL</li> <li>minzoom: Overwrite default minzoom. OPTIONAL</li> <li>maxzoom: Overwrite default maxzoom. OPTIONAL</li> </ul> </li> </ul> <p>Important</p> <p>additional query-parameters will be forwarded to the <code>tile</code> URL. If no <code>defaults</code> mosaic metadata, assets OR expression will be required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/searches/f1ed59f0a6ad91ed80ae79b7b52bc707/WebMercatorQuad/WMTSCapabilities.xml?assets=B01</code></li> <li><code>https://myendpoint/searches/f1ed59f0a6ad91ed80ae79b7b52bc707/WebMercatorQuad/WMTSCapabilities.xml?assets=B01&amp;tile_format=png</code></li> <li><code>https://myendpoint/searches/f1ed59f0a6ad91ed80ae79b7b52bc707/WorldCRS84Quad/WMTSCapabilities.xml?assets=B01&amp;tile_scale=2</code></li> </ul>"},{"location":"endpoints/searches_endpoints/#assets-for-point-or-tile","title":"Assets for Point or Tile","text":"<p><code>:endpoint:/searches/{search_id}/tiles/{TileMatrixSetId}/{z}/{x}/{y}/assets</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>search_id: PgSTAC Search Identifier (Hash).</li> <li>TileMatrixSetId: TileMatrixSet name.</li> <li>z: Tile's zoom level.</li> <li>x: Tile's column.</li> <li>y: Tile's row.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/searches/f1ed59f0a6ad91ed80ae79b7b52bc707/tiles/WebMercatorQuad/0/0/0/assets</code></li> </ul> <p><code>:endpoint:/searches/{search_id}/point/{lon},{lat}/assets</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>search_id: PgSTAC Search Identifier (Hash).</li> <li>lon: Longitude (in WGS84 CRS).</li> <li>lat: Latitude (in WGS84 CRS).</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/searches/f1ed59f0a6ad91ed80ae79b7b52bc707/point/0.0,0.0/assets</code></li> </ul>"},{"location":"endpoints/searches_endpoints/#statistics","title":"Statistics","text":"<p><code>:endpoint:/searches/{search_id}/statistics - [POST]</code></p> <ul> <li> <p>Body:</p> <ul> <li>feature (JSON): A valid GeoJSON feature or FeatureCollection</li> </ul> </li> <li> <p>PathParams:</p> <ul> <li>search_id: PgSTAC Search Identifier (Hash).</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band index (e.g <code>Asset1|1;2;3</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input geometry. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size from which to calculate statistics.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>nodata: Overwrite internal Nodata value. OPTIONAL</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds.</li> <li>pixel_selection (str): Pixel selection method (cogeotiff.github.io/rio-tiler/mosaic/).</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> </ul> </li> </ul> <p>Important</p> <p>if height and width are provided max_size will be ignored.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/searches/f1ed59f0a6ad91ed80ae79b7b52bc707/statistics?assets=B01</code></li> </ul>"},{"location":"endpoints/searches_endpoints/#bboxfeature","title":"BBOX/Feature","text":"<p><code>:endpoint:/searches/{search_id}/bbox/{minx},{miny},{maxx},{maxy}.{format}</code></p> <p><code>:endpoint:/searches/{search_id}/bbox/{minx},{miny},{maxx},{maxy}/{width}x{height}.{format}</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>search_id: PgSTAC Search Identifier (Hash).</li> <li>minx,miny,maxx,maxy (str): Comma (',') delimited bounding box in WGS84.</li> <li>format (str): Output image format.</li> <li>height (int): Force output image height.</li> <li>width (int): Force output image width.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band index (e.g <code>Asset1|1;2;3</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input coordinates. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size.</li> <li>nodata: Overwrite internal Nodata value. OPTIONAL</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>pixel_selection (str): Pixel selection method (cogeotiff.github.io/rio-tiler/mosaic/).</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> </ul> </li> </ul> <p>Important</p> <p>if height and width are provided max_size will be ignored.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/searches/f1ed59f0a6ad91ed80ae79b7b52bc707/bbox/0,0,10,10.png?assets=B01</code></li> <li><code>https://myendpoint/searches/f1ed59f0a6ad91ed80ae79b7b52bc707/bbox/0,0,10,10/400x300.png?assets=B01</code></li> </ul> <p><code>:endpoint:/searches/{search_id}/feature[/{width}x{height}][].{format}] - [POST]</code></p> <ul> <li> <p>Body:</p> <ul> <li>feature (JSON): A valid GeoJSON feature (Polygon or MultiPolygon)</li> </ul> </li> <li> <p>PathParams:</p> <ul> <li>search_id: PgSTAC Search Identifier (Hash).</li> <li>height (int): Force output image height. Optional</li> <li>width (int): Force output image width. Optional</li> <li>format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band index (e.g <code>Asset1|1;2;3</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input geometry. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size.</li> <li>nodata: Overwrite internal Nodata value. OPTIONAL</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>pixel_selection (str): Pixel selection method (cogeotiff.github.io/rio-tiler/mosaic/).</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> </ul> </li> </ul> <p>Important</p> <p>if height and width are provided max_size will be ignored.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/searches/f1ed59f0a6ad91ed80ae79b7b52bc707/feature?assets=B01</code></li> <li><code>https://myendpoint/searches/f1ed59f0a6ad91ed80ae79b7b52bc707/feature.png?assets=B01f</code></li> <li><code>https://myendpoint/searches/f1ed59f0a6ad91ed80ae79b7b52bc707/feature/100x100.png?assets=B01</code></li> </ul>"},{"location":"endpoints/searches_endpoints/#point","title":"Point","text":"<p><code>:endpoint:/searches/{search_id}/point/{lon},{lat}</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>search_id: PgSTAC Search Identifier (Hash).</li> <li>lon: Longitude (in <code>coord-crs</code>, defaults to <code>WGS84</code>).</li> <li>lat: Latitude (in <code>coord-crs</code>, defaults to <code>WGS84</code>).</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band index (e.g <code>Asset1|1;2;3</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input geometry. Default to <code>epsg:4326</code>.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/searches/f1ed59f0a6ad91ed80ae79b7b52bc707/point/0,0?assets=B01</code></li> </ul>"},{"location":"endpoints/searches_endpoints/#register-a-search-request","title":"Register a Search Request","text":"<p><code>:endpoint:/searches/register - [POST]</code></p> <ul> <li>Body (a combination of Search+Metadata): A JSON body composed of a valid STAC Search query (see: github.com/radiantearth/stac-api-spec/tree/master/item-search) and Mosaic's metadata.</li> </ul> <pre><code>// titiler-pgstac search body example\n{\n  // STAC search query\n  \"collections\": [\n    \"string\"\n  ],\n  \"ids\": [\n    \"string\"\n  ],\n  \"bbox\": [\n    \"number\",\n    \"number\",\n    \"number\",\n    \"number\"\n  ],\n  \"intersects\": {\n    \"type\": \"Point\",\n    \"coordinates\": [\n      \"number\",\n      \"number\"\n    ]\n  },\n  \"query\": {\n    \"additionalProp1\": {},\n    \"additionalProp2\": {},\n    \"additionalProp3\": {}\n  },\n  \"filter\": {},\n  \"datetime\": \"string\",\n  \"sortby\": \"string\",\n  \"filter-lang\": \"cql-json\",\n  // titiler-pgstac mosaic metadata\n  \"metadata\": {\n    \"type\": \"mosaic\",\n    \"bounds\": [\n      \"number\",\n      \"number\",\n      \"number\",\n      \"number\"\n    ],\n    \"minzoom\": \"number\",\n    \"maxzoom\": \"number\",\n    \"name\": \"string\",\n    \"assets\": [\n      \"string\",\n      \"string\",\n    ],\n    \"defaults\": {}\n  }\n}\n</code></pre> <p>Important</p> <p>In <code>titiler-pgstac</code> we extended the regular <code>stac</code> search to add a metadata entry. Metadata defaults to <code>{\"type\": \"mosaic\"}</code>.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/searches/register</code></li> </ul> <pre><code>curl -X 'POST' 'http://127.0.0.1:8081/searches/register' -H 'accept: application/json' -H 'Content-Type: application/json' -d '{\"collections\":[\"landsat-c2l2-sr\"], \"bbox\":[-123.75,34.30714385628804,-118.125,38.82259097617712], \"filter-lang\": \"cql-json\"}' | jq\n&gt;&gt; {\n  \"id\": \"5a1b82d38d53a5d200273cbada886bd7\",\n  \"links\": [\n    {\n      \"rel\": \"metadata\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/searches/5a1b82d38d53a5d200273cbada886bd7/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"templated\": true,\n      \"href\": \"http://127.0.0.1:8081/searches/5a1b82d38d53a5d200273cbada886bd7/{TileMatrixSetId}/tilejson.json\"\n    }\n  ]\n}\n\n# or using CQL2\ncurl -X 'POST' 'http://127.0.0.1:8081/searches/register' -H 'accept: application/json' -H 'Content-Type: application/json' -d '{\"filter\": {\"op\": \"=\", \"args\": [{\"property\": \"collection\"}, \"landsat-c2l2-sr\"]}}'\n\n# or using CQL2 with metadata\ncurl -X 'POST' 'http://127.0.0.1:8081/searches/register' -H 'accept: application/json' -H 'Content-Type: application/json' -d '{\"filter\": {\"op\": \"=\", \"args\": [{\"property\": \"collection\"}, \"landsat-c2l2-sr\"]}, \"metadata\": {\"name\": \"landsat mosaic\"}}'\n</code></pre>"},{"location":"endpoints/searches_endpoints/#search-infos","title":"Search infos","text":"<p><code>:endpoint:/searches/{search_id}/info - [GET]</code></p> <ul> <li>PathParams:<ul> <li>search_id: PgSTAC Search Identifier (Hash).</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/searches/5a1b82d38d53a5d200273cbada886bd7/info</code></li> </ul> <pre><code>curl 'http://127.0.0.1:8081/searches/5a1b82d38d53a5d200273cbada886bd7/info' | jq\n&gt;&gt; {\n  \"search\": {\n    \"hash\": \"5a1b82d38d53a5d200273cbada886bd7\",\n    \"search\": {\n      \"bbox\": [\n        -123.75,\n        34.30714385628804,\n        -118.125,\n        38.82259097617712\n      ],\n      \"collections\": [\n        \"landsat-c2l2-sr\"\n      ],\n      \"filter-lang\": \"cql-json\"\n    },\n    \"_where\": \"(  TRUE  )  AND collection_id = ANY ('{landsat-c2l2-sr}')  AND geometry &amp;&amp; '0103000020E610000001000000050000000000000000F05EC055F6687D502741400000000000F05EC02D553EA94A6943400000000000885DC02D553EA94A6943400000000000885DC055F6687D502741400000000000F05EC055F6687D50274140' \",\n    \"orderby\": \"datetime DESC, id DESC\",\n    \"lastused\": \"2022-03-03T11:42:07.213313+00:00\",\n    \"usecount\": 2,\n    \"metadata\": {\n      \"type\": \"mosaic\"\n    }\n  },\n  \"links\": [\n    {\n      \"rel\": \"self\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/searches/5a1b82d38d53a5d200273cbada886bd7/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"templated\": true,\n      \"href\": \"http://127.0.0.1:8081/searches/5a1b82d38d53a5d200273cbada886bd7/{TileMatrixSetId}/tilejson.json\"\n    }\n  ]\n}\n</code></pre>"},{"location":"endpoints/searches_endpoints/#list-searches","title":"List Searches","text":"<p><code>:endpoint:/searches/list - [GET]</code></p> <ul> <li>QueryParams:<ul> <li>limit (int): Page size limit, Default is <code>10</code>.</li> <li>offset (int): Page offset.</li> <li>sortby (str): Sort the searches by Metadata properties (ascending (default) or descending (<code>-</code>)).</li> </ul> </li> </ul> <p>Important</p> <p>Additional query-parameters (form <code>PROP=VALUE</code>) will be considered as a property filter.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/searches/list</code></li> <li><code>https://myendpoint/searches/list?limit=100</code></li> <li><code>https://myendpoint/searches/list?limit=10&amp;offset=10</code> (page 2)</li> <li><code>https://myendpoint/searches/list?data=noaa</code> (only show mosaics with <code>metadata.data == noaa</code>)</li> <li><code>https://myendpoint/searches/list?sortby=lastused</code> (sort mosaic by <code>lastused</code> pgstac search property)</li> <li><code>https://myendpoint/searches/list?sortby=-prop</code> (sort mosaic (descending) by <code>metadata.prop</code> values)</li> </ul>"},{"location":"endpoints/tms_endpoints/","title":"TileMatrixSet","text":"Method URL Output Description <code>GET</code> <code>/tileMatrixSets</code> JSON (TMS list) return the list of supported TileMatrixSet <code>GET</code> <code>/tileMatrixSets/{TileMatrixSetId}</code> JSON (TileMatrixSet) return the TileMatrixSet JSON document"},{"location":"endpoints/tms_endpoints/#list-tms","title":"List TMS","text":"<p><code>:endpoint:/tileMatrixSets</code> - Get the list of supported TileMatrixSet</p> <pre><code>curl https://myendpoint/tileMatrixSets | jq\n&gt;&gt; {\n  \"tileMatrixSets\": [\n    {\n      \"id\": \"LINZAntarticaMapTilegrid\",\n      \"title\": \"LINZ Antarctic Map Tile Grid (Ross Sea Region)\",\n      \"links\": [\n        {\n          \"href\": \"https://myendpoint/tileMatrixSets/LINZAntarticaMapTilegrid\",\n          \"rel\": \"item\",\n          \"type\": \"application/json\"\n        }\n      ]\n    },\n    ...\n  ]\n}\n</code></pre>"},{"location":"endpoints/tms_endpoints/#get-tms-info","title":"Get TMS info","text":"<p><code>:endpoint:/tileMatrixSets/{TileMatrixSetId}</code> - Get the TileMatrixSet JSON document</p> <ul> <li>PathParams:<ul> <li>TileMatrixSetId: TileMatrixSet name</li> </ul> </li> </ul> <pre><code>curl http://127.0.0.1:8000/tileMatrixSets/WebMercatorQuad | jq\n&gt;&gt; {\n  \"type\": \"TileMatrixSetType\",\n  \"title\": \"Google Maps Compatible for the World\",\n  \"identifier\": \"WebMercatorQuad\",\n  \"supportedCRS\": \"http://www.opengis.net/def/crs/EPSG/0/3857\",\n  \"wellKnownScaleSet\": \"http://www.opengis.net/def/wkss/OGC/1.0/GoogleMapsCompatible\",\n  \"boundingBox\": {\n    \"type\": \"BoundingBoxType\",\n    \"crs\": \"http://www.opengis.net/def/crs/EPSG/0/3857\",\n    \"lowerCorner\": [\n      -20037508.3427892,\n      -20037508.3427892\n    ],\n    \"upperCorner\": [\n      20037508.3427892,\n      20037508.3427892\n    ]\n  },\n  \"tileMatrix\": [\n    {\n      \"type\": \"TileMatrixType\",\n      \"identifier\": \"0\",\n      \"scaleDenominator\": 559082264.028717,\n      \"topLeftCorner\": [\n        -20037508.3427892,\n        20037508.3427892\n      ],\n      \"tileWidth\": 256,\n      \"tileHeight\": 256,\n      \"matrixWidth\": 1,\n      \"matrixHeight\": 1\n    },\n    ...\n</code></pre>"},{"location":"migrations/v1_migration/","title":"v0.8 -> v1.0","text":"<p><code>titiler-pgstac</code> version 1.0 introduced many breaking changes. This document aims to help with migrating your code and client application to use <code>titiler-pgstac~=1.0</code>.</p>"},{"location":"migrations/v1_migration/#endpoints","title":"Endpoints","text":""},{"location":"migrations/v1_migration/#new-collectionscollection_id-endpoints","title":"New <code>/collections/{collection_id}</code> endpoints","text":"<p>With this new set of endpoints, there is no more need to register a PgSTAC Search in advance. The tiler will do it dynamically at request time.</p> <pre><code># Simplified version of the CollectionIdParams\n# https://github.com/stac-utils/titiler-pgstac/blob/7da390e42d3abaace5ca9a7172c799289e4cacf7/titiler/pgstac/dependencies.py#L37-L91\ndef CollectionIdParams(\n    request: Request,\n    collection_id: Annotated[\n        str,\n        Path(description=\"STAC Collection Identifier\"),\n    ],\n) -&gt; str:\n    \"\"\"collection_id Path Parameter\"\"\"\n    search = model.PgSTACSearch(collections=[collection_id])\n\n    with request.app.state.dbpool.connection() as conn:\n        with conn.cursor(row_factory=class_row(model.Search)) as cursor:\n\n            metadata = model.Metadata(\n                name=f\"Mosaic for '{collection_id}' Collection\",\n            )\n            cursor.execute(\n                \"SELECT * FROM search_query(%s, _metadata =&gt; %s);\",\n                (\n                    search.model_dump_json(by_alias=True, exclude_none=True),\n                    metadata.model_dump_json(exclude_none=True),\n                ),\n            )\n            search_info = cursor.fetchone()\n\n    return search_info.id\n</code></pre>"},{"location":"migrations/v1_migration/#mosaicsearchid-searchessearch_id","title":"<code>/mosaic/{searchid}</code> -&gt; <code>/searches/{search_id}</code>","text":"<p>We chose to rename the prefix of the PgSTAC Searches endpoints from <code>/mosaic</code> to <code>/searches</code> to match the collections and items endpoint prefixes.</p> <p>Note: We also renamed <code>searchid</code> to <code>search_id</code> but this should be seamless for users.</p> <pre><code># before\nresp = httpx.get(\"/mosaic/{{ searchid }}/info\")\n\n# now\nresp = httpx.get(\"/searches/{{ search_id }}/info\")\n</code></pre> <p>Important</p> <p>You can change the prefix for the <code>MosaicTilerFactory</code>'s endpoints and could easily revert this change in your own application.</p> <pre><code>from fastapi import FastAPI\n\nfrom titiler.pgstac.factory import (\n    MosaicTilerFactory,\n    add_search_list_route,\n    add_search_register_route,\n)\nfrom titiler.pgstac.dependencies import SearchIdParams\nfrom titiler.pgstac.extensions import searchInfoExtension\n\napp = FastAPI()\n\n# STAC Search Endpoints\nsearches = MosaicTilerFactory(\n    path_dependency=SearchIdParams,\n    router_prefix=\"/mosaic/{search_id}\",\n    add_statistics=True,\n    add_viewer=True,\n    add_part=True,\n    extensions=[\n        searchInfoExtension(),\n    ],\n)\napp.include_router(\n    searches.router, tags=[\"STAC Search\"], prefix=\"/mosaic/{search_id}\"\n)\nadd_search_register_route(\n    app,\n    prefix=\"/mosaic\",\n    tile_dependencies=[\n        searches.layer_dependency,\n        searches.dataset_dependency,\n        searches.pixel_selection_dependency,\n        searches.process_dependency,\n        searches.rescale_dependency,\n        searches.colormap_dependency,\n        searches.render_dependency,\n        searches.pgstac_dependency,\n        searches.reader_dependency,\n        searches.backend_dependency,\n    ],\n    tags=[\"STAC Search\"],\n)\nadd_search_list_route(app, prefix=\"/mosaic\", tags=[\"STAC Search\"])\n</code></pre>"},{"location":"migrations/v1_migration/#searchid-id","title":"<code>searchid</code> -&gt; <code>id</code>","text":"<p>In <code>titiler.pgstac.model.RegisterResponse</code>, model used in <code>/register</code> endpoint, we renamed <code>searchid</code> by <code>id</code>.</p> <pre><code># before\nresp = httpx.post(\"/mosaic/register\", body={\"collections\": [\"my-collection\"], \"filter-lang\": \"cql-json\"})\nassert resp.json()[\"searchid\"]\n\n# now\nresp = httpx.post(\"/searches/register\", body={\"collections\": [\"my-collection\"], \"filter-lang\": \"cql-json\"})\nassert resp.json()[\"id\"]\n</code></pre>"},{"location":"migrations/v1_migration/#api","title":"API","text":""},{"location":"migrations/v1_migration/#pathparams-itempathparams-searchidparams-itemidparams","title":"<code>PathParams / ItemPathParams</code> -&gt; <code>SearchIdParams / ItemIdParams</code>","text":"<p>We renamed both <code>PathParams</code> and <code>ItemPathParams</code> classes to <code>SearchIdParams</code> and <code>ItemIdParams</code> to better match with the <code>CollectionIdParams</code> dependency.</p>"},{"location":"migrations/v1_migration/#remove-search_id-prefix-in-mosaictilerfactory","title":"remove <code>/{search_id}</code> prefix in <code>MosaicTilerFactory</code>","text":"<p>In order to re-use the <code>MosaicTilerFactory</code> for collections we had to remove the <code>/{search_id}</code> prefix which was hardcoded in each endpoint routes. This is now added to the <code>router_prefix</code>.</p> <pre><code># Before\napp = FastAPI()\nmosaic = MosaicTilerFactory(\n    ...,\n    router_prefix=\"/mosaics\"\n)\napp.include_router(mosaic.router, prefix=\"/mosaics\")\n\n# Now\napp = FastAPI()\nmosaic = MosaicTilerFactory(\n    ...\n    router_prefix=\"/mosaics/{search_id}\"\n)\napp.include_router(mosaic.router, prefix=\"/mosaics/{search_id}\")\n</code></pre>"},{"location":"migrations/v1_migration/#path_dependency-required-input-for-mosaictilerfactory-class","title":"<code>path_dependency</code> required input for <code>MosaicTilerFactory</code> class","text":"<p>With the introduction of the collections endpoints, and because we removed the default <code>{search_id}</code> prefix, we cannot default to <code>SearchIdParams</code> for the <code>path_dependency</code> (the dependency which sends the PgSTAC search identifier to the Mosaic Reader) and thus is now a required attribute when initializing the endpoints.</p> <pre><code># before\napp = FastAPI()\nmosaic = MosaicTilerFactory(...)\napp.include_router(mosaic.router)\n\n# now\napp = FastAPI()\nmosaic = MosaicTilerFactory(\n    ...,\n    path_dependency=lambda: \"aaaaaaaaaaaaaa\"\n)\napp.include_router(mosaic.router)\n</code></pre>"},{"location":"migrations/v1_migration/#searchinfoextension","title":"<code>searchInfoExtension</code>","text":"<p>We moved the <code>MosaicTilerFactory</code> info endpoint outside the class to its own extension.</p> <pre><code># Before\napp = FastAPI()\nmosaic = MosaicTilerFactory(...)\napp.include_router(mosaic.router)\n\n# Now\napp = FastAPI()\nmosaic = MosaicTilerFactory(\n    ...\n    extensions=[\n        searchInfoExtension(),\n    ]\n)\napp.include_router(mosaic.router)\n</code></pre>"},{"location":"migrations/v1_migration/#register-and-list-endpoints","title":"<code>Register</code> and <code>List</code> endpoints","text":"<p>we moved the <code>/register</code> and <code>/list</code> endpoints creation outside the <code>MosaicTilerFactory</code> class because they are not usable for the collection's endpoint and do not need the <code>/{search_id}</code> prefix.</p> <pre><code># before\nfrom titiler.pgstac.factory import MosaicTilerFactory\n\nmosaic = MosaicTilerFactory(\n    ...,\n    router_prefix=\"/{search_id}\",\n)\napp.include_router(mosaic.router, prefix=\"/{search_id}\")\n\n# Now\nfrom titiler.pgstac.factory import (\n    MosaicTilerFactory,\n    add_search_register_route,\n    add_search_list_route,\n)\n\nmosaic = MosaicTilerFactory(\n    ...,\n    router_prefix=\"/{search_id}\",\n)\napp.include_router(mosaic.router, prefix=\"/{search_id}\")\n\n# add /register endpoint\nadd_search_register_route(\n    app,\n    # any dependency we want to validate\n    # when creating the tilejson/map links\n    tile_dependencies=[\n        mosaic.layer_dependency,\n        mosaic.dataset_dependency,\n        mosaic.pixel_selection_dependency,\n        mosaic.process_dependency,\n        mosaic.rescale_dependency,\n        mosaic.colormap_dependency,\n        mosaic.render_dependency,\n        mosaic.pgstac_dependency,\n        mosaic.reader_dependency,\n        mosaic.backend_dependency,\n    ],\n)\n# add /list endpoint\nadd_search_list_route(app)\n</code></pre>"},{"location":"notebooks/demo/","title":"demo","text":"In\u00a0[1]: Copied! <pre>import json\nimport httpx\nfrom folium import Map, TileLayer, GeoJson\n\nfrom geojson_pydantic import Feature, Polygon\n\nendpoint = \"http://127.0.0.1:8081\"\n\nprint(httpx.get(f\"{endpoint}/healthz\").json())\n</pre> import json import httpx from folium import Map, TileLayer, GeoJson  from geojson_pydantic import Feature, Polygon  endpoint = \"http://127.0.0.1:8081\"  print(httpx.get(f\"{endpoint}/healthz\").json()) <pre>{'database_online': True}\n</pre> In\u00a0[2]: Copied! <pre># bounds of the noaa-eri-nashville2020.json items\nbounds = (-87.0251, 36.0999, -85.4249, 36.2251)\n\npoly = Polygon.from_bounds(*bounds)\ngeojson = Feature(type=\"Feature\", geometry=poly, properties=None).model_dump(\n    exclude_none=True\n)\n\nm = Map(\n    tiles=\"OpenStreetMap\",\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),\n    zoom_start=8,\n)\n\ngeo_json = GeoJson(\n    data=geojson,\n    style_function=lambda x: {\n        \"opacity\": 1,\n        \"dashArray\": \"1\",\n        \"fillOpacity\": 0,\n        \"weight\": 1,\n    },\n)\ngeo_json.add_to(m)\nm\n</pre> # bounds of the noaa-eri-nashville2020.json items bounds = (-87.0251, 36.0999, -85.4249, 36.2251)  poly = Polygon.from_bounds(*bounds) geojson = Feature(type=\"Feature\", geometry=poly, properties=None).model_dump(     exclude_none=True )  m = Map(     tiles=\"OpenStreetMap\",     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),     zoom_start=8, )  geo_json = GeoJson(     data=geojson,     style_function=lambda x: {         \"opacity\": 1,         \"dashArray\": \"1\",         \"fillOpacity\": 0,         \"weight\": 1,     }, ) geo_json.add_to(m) m Out[2]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[6]: Copied! <pre>search_request = {\n    # Filter collection\n    \"collections\": [\"noaa-emergency-response\"],\n    # limit bounds of the known items (note: the bbox will also be used in the tilejson response)\n    \"bbox\": bounds,\n    \"filter-lang\": \"cql-json\",\n}\n\nresponse = httpx.post(\n    f\"{endpoint}/searches/register\",\n    json=search_request,\n).json()\nprint(response)\n\nsearchid = response[\"id\"]\n</pre> search_request = {     # Filter collection     \"collections\": [\"noaa-emergency-response\"],     # limit bounds of the known items (note: the bbox will also be used in the tilejson response)     \"bbox\": bounds,     \"filter-lang\": \"cql-json\", }  response = httpx.post(     f\"{endpoint}/searches/register\",     json=search_request, ).json() print(response)  searchid = response[\"id\"] <pre>{'id': '6d436413d0eed760acc2f6bd16ca77a5', 'links': [{'href': 'http://127.0.0.1:8081/searches/6d436413d0eed760acc2f6bd16ca77a5/info', 'rel': 'metadata', 'title': 'Mosaic metadata'}, {'href': 'http://127.0.0.1:8081/searches/6d436413d0eed760acc2f6bd16ca77a5/{tileMatrixSetId}/tilejson.json', 'rel': 'tilejson', 'templated': True, 'title': 'Link for TileJSON (Template URL)'}, {'href': 'http://127.0.0.1:8081/searches/6d436413d0eed760acc2f6bd16ca77a5/{tileMatrixSetId}/map', 'rel': 'map', 'templated': True, 'title': 'Link for Map viewer (Template URL)'}, {'href': 'http://127.0.0.1:8081/searches/6d436413d0eed760acc2f6bd16ca77a5/{tileMatrixSetId}/WMTSCapabilities.xml', 'rel': 'wmts', 'templated': True, 'title': 'Link for WMTS (Template URL)'}]}\n</pre> In\u00a0[12]: Copied! <pre>response = httpx.get(f\"{endpoint}/searches/list\").json()\nprint(\n    json.dumps(\n        [\n            (search[\"search\"][\"hash\"], search[\"search\"][\"metadata\"].get(\"name\"))\n            for search in response[\"searches\"]\n        ],\n        indent=4,\n    )\n)\n</pre> response = httpx.get(f\"{endpoint}/searches/list\").json() print(     json.dumps(         [             (search[\"search\"][\"hash\"], search[\"search\"][\"metadata\"].get(\"name\"))             for search in response[\"searches\"]         ],         indent=4,     ) ) <pre>[\n    [\n        \"37c6ebb942cc5393a9eb408ad8431f62\",\n        \"Mosaic for 'MAXAR_BayofBengal_Cyclone_Mocha_May_23' Collection\"\n    ],\n    [\n        \"0152ee7c4a9d7e672d15e318c92046df\",\n        \"Mosaic for 'MAXAR_BayofBengal_Cyclone_Mocha_May_23' Collection\"\n    ],\n    [\n        \"9c8888d0bbc70ceaff403255442634a3\",\n        \"Mosaic for 'MAXAR_BayofBengal_Cyclone_Mocha_May_23' Collection\"\n    ],\n    [\n        \"492e7cd904d75979afa38d8a5b6e2b83\",\n        \"Mosaic for 'MAXAR_BayofBengal_Cyclone_Mocha_May_23' Collection\"\n    ],\n    [\n        \"8410ce526b9644e177db97f275db172c\",\n        \"Mosaic for 'noaa-emergency-response' Collection\"\n    ],\n    [\n        \"ca495d2ef671c17cc743966be61fa346\",\n        \"Mosaic for 'noaa-emergency-response' Collection\"\n    ],\n    [\n        \"f2ed44110ac820d456ac53e44f42daeb\",\n        \"Mosaic for 'noaa-emergency-response' Collection\"\n    ],\n    [\n        \"3f7bd36cbeddbfc49921b9b127283478\",\n        \"Mosaic for 'noaa-emergency-response' Collection\"\n    ],\n    [\n        \"f3049b538d2c4189a057f809a90a6a13\",\n        \"Mosaic for 'noaa-emergency-response' Collection\"\n    ],\n    [\n        \"4530a5f9f38e8721c6a1b1dfb974fac2\",\n        \"Mosaic for 'noaa-emergency-response' Collection\"\n    ]\n]\n</pre> In\u00a0[13]: Copied! <pre>info_response = httpx.get(f\"{endpoint}/searches/{searchid}/info\").json()\nprint(json.dumps(info_response, indent=4))\n</pre> info_response = httpx.get(f\"{endpoint}/searches/{searchid}/info\").json() print(json.dumps(info_response, indent=4)) <pre>{\n    \"search\": {\n        \"hash\": \"6d436413d0eed760acc2f6bd16ca77a5\",\n        \"search\": {\n            \"bbox\": [\n                -87.0251,\n                36.0999,\n                -85.4249,\n                36.2251\n            ],\n            \"collections\": [\n                \"noaa-emergency-response\"\n            ],\n            \"filter-lang\": \"cql-json\"\n        },\n        \"_where\": \"collection = ANY ('{noaa-emergency-response}')  AND st_intersects(geometry, '0103000020E610000001000000050000004BC8073D9BC155C0696FF085C90C42404BC8073D9BC155C0302AA913D01C42408104C58F315B55C0302AA913D01C42408104C58F315B55C0696FF085C90C42404BC8073D9BC155C0696FF085C90C4240')\",\n        \"orderby\": \"datetime DESC, id DESC\",\n        \"lastused\": \"2024-11-28T11:21:15.887027Z\",\n        \"usecount\": 2,\n        \"metadata\": {\n            \"type\": \"mosaic\"\n        }\n    },\n    \"links\": [\n        {\n            \"href\": \"http://127.0.0.1:8081/searches/6d436413d0eed760acc2f6bd16ca77a5/info\",\n            \"rel\": \"self\",\n            \"title\": \"Mosaic metadata\"\n        },\n        {\n            \"href\": \"http://127.0.0.1:8081/searches/6d436413d0eed760acc2f6bd16ca77a5/{tileMatrixSetId}/tilejson.json\",\n            \"rel\": \"tilejson\",\n            \"templated\": true,\n            \"title\": \"TileJSON link (Template URL).\"\n        },\n        {\n            \"href\": \"http://127.0.0.1:8081/searches/6d436413d0eed760acc2f6bd16ca77a5/{tileMatrixSetId}/map\",\n            \"rel\": \"map\",\n            \"templated\": true,\n            \"title\": \"Map viewer link (Template URL).\"\n        },\n        {\n            \"href\": \"http://127.0.0.1:8081/searches/6d436413d0eed760acc2f6bd16ca77a5/{tileMatrixSetId}/WMTSCapabilities.xml\",\n            \"rel\": \"wmts\",\n            \"templated\": true,\n            \"title\": \"WMTS link (Template URL)\"\n        }\n    ]\n}\n</pre> In\u00a0[16]: Copied! <pre>tj_response = httpx.get(\n    f\"{endpoint}/searches/{searchid}/WebMercatorQuad/tilejson.json?assets=cog\"\n).json()\nprint(json.dumps(tj_response, indent=4))\n</pre> tj_response = httpx.get(     f\"{endpoint}/searches/{searchid}/WebMercatorQuad/tilejson.json?assets=cog\" ).json() print(json.dumps(tj_response, indent=4)) <pre>{\n    \"tilejson\": \"2.2.0\",\n    \"name\": \"6d436413d0eed760acc2f6bd16ca77a5\",\n    \"version\": \"1.0.0\",\n    \"scheme\": \"xyz\",\n    \"tiles\": [\n        \"http://127.0.0.1:8081/searches/6d436413d0eed760acc2f6bd16ca77a5/tiles/WebMercatorQuad/{z}/{x}/{y}?assets=cog\"\n    ],\n    \"minzoom\": 0,\n    \"maxzoom\": 24,\n    \"bounds\": [\n        -87.0251,\n        36.0999,\n        -85.4249,\n        36.2251\n    ],\n    \"center\": [\n        -86.225,\n        36.162499999999994,\n        0\n    ]\n}\n</pre> In\u00a0[17]: Copied! <pre>m = Map(\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=14\n)\n\ngeo_json = GeoJson(\n    data=geojson,\n    style_function=lambda x: {\n        \"opacity\": 1,\n        \"dashArray\": \"1\",\n        \"fillOpacity\": 0,\n        \"weight\": 1,\n    },\n)\ngeo_json.add_to(m)\n\naod_layer = TileLayer(\n    tiles=tj_response[\"tiles\"][0],\n    attr=\"Mosaic\",\n    min_zoom=14,\n    max_zoom=18,\n    max_native_zoom=18,\n)\naod_layer.add_to(m)\nm\n</pre> m = Map(     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=14 )  geo_json = GeoJson(     data=geojson,     style_function=lambda x: {         \"opacity\": 1,         \"dashArray\": \"1\",         \"fillOpacity\": 0,         \"weight\": 1,     }, ) geo_json.add_to(m)  aod_layer = TileLayer(     tiles=tj_response[\"tiles\"][0],     attr=\"Mosaic\",     min_zoom=14,     max_zoom=18,     max_native_zoom=18, ) aod_layer.add_to(m) m Out[17]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[19]: Copied! <pre>search_request = {\n    # Filter collection\n    \"collections\": [\"noaa-emergency-response\"],\n    # limit bounds of the known items (note: the bbox will also be used in the tilejson response)\n    \"bbox\": bounds,\n    \"filter-lang\": \"cql-json\",\n    \"metadata\": {\n        \"bounds\": [\n            -87.0251,\n            36.0999,\n            -85.4249,\n            36.2251,\n        ],  # This is redondant because it's in the bbox filter\n        \"minzoom\": 14,\n        \"maxzoom\": 18,\n        \"assets\": [\"cog\"],\n        \"defaults\": {\n            \"true_color\": {\n                \"bidx\": [1, 2, 3],\n            },\n        },\n    },\n}\n\nresponse = httpx.post(\n    f\"{endpoint}/searches/register\",\n    json=search_request,\n).json()\nprint(json.dumps(response, indent=4))\n\nsearchid = response[\"id\"]\n</pre> search_request = {     # Filter collection     \"collections\": [\"noaa-emergency-response\"],     # limit bounds of the known items (note: the bbox will also be used in the tilejson response)     \"bbox\": bounds,     \"filter-lang\": \"cql-json\",     \"metadata\": {         \"bounds\": [             -87.0251,             36.0999,             -85.4249,             36.2251,         ],  # This is redondant because it's in the bbox filter         \"minzoom\": 14,         \"maxzoom\": 18,         \"assets\": [\"cog\"],         \"defaults\": {             \"true_color\": {                 \"bidx\": [1, 2, 3],             },         },     }, }  response = httpx.post(     f\"{endpoint}/searches/register\",     json=search_request, ).json() print(json.dumps(response, indent=4))  searchid = response[\"id\"] <pre>{\n    \"id\": \"4b0db3dbd1858d54a3a55f84de97d1ca\",\n    \"links\": [\n        {\n            \"href\": \"http://127.0.0.1:8081/searches/4b0db3dbd1858d54a3a55f84de97d1ca/info\",\n            \"rel\": \"metadata\",\n            \"title\": \"Mosaic metadata\"\n        },\n        {\n            \"href\": \"http://127.0.0.1:8081/searches/4b0db3dbd1858d54a3a55f84de97d1ca/{tileMatrixSetId}/tilejson.json\",\n            \"rel\": \"tilejson\",\n            \"templated\": true,\n            \"title\": \"Link for TileJSON (Template URL)\"\n        },\n        {\n            \"href\": \"http://127.0.0.1:8081/searches/4b0db3dbd1858d54a3a55f84de97d1ca/{tileMatrixSetId}/map\",\n            \"rel\": \"map\",\n            \"templated\": true,\n            \"title\": \"Link for Map viewer (Template URL)\"\n        },\n        {\n            \"href\": \"http://127.0.0.1:8081/searches/4b0db3dbd1858d54a3a55f84de97d1ca/{tileMatrixSetId}/WMTSCapabilities.xml\",\n            \"rel\": \"wmts\",\n            \"templated\": true,\n            \"title\": \"Link for WMTS (Template URL)\"\n        }\n    ]\n}\n</pre> In\u00a0[21]: Copied! <pre>tj_response = httpx.get(\n    f\"{endpoint}/searches/{searchid}/WebMercatorQuad/tilejson.json?assets=cog\"\n).json()\nprint(json.dumps(tj_response, indent=4))\n</pre> tj_response = httpx.get(     f\"{endpoint}/searches/{searchid}/WebMercatorQuad/tilejson.json?assets=cog\" ).json() print(json.dumps(tj_response, indent=4)) <pre>{\n    \"tilejson\": \"2.2.0\",\n    \"name\": \"4b0db3dbd1858d54a3a55f84de97d1ca\",\n    \"version\": \"1.0.0\",\n    \"scheme\": \"xyz\",\n    \"tiles\": [\n        \"http://127.0.0.1:8081/searches/4b0db3dbd1858d54a3a55f84de97d1ca/tiles/WebMercatorQuad/{z}/{x}/{y}?assets=cog\"\n    ],\n    \"minzoom\": 14,\n    \"maxzoom\": 18,\n    \"bounds\": [\n        -87.0251,\n        36.0999,\n        -85.4249,\n        36.2251\n    ],\n    \"center\": [\n        -86.225,\n        36.162499999999994,\n        14\n    ]\n}\n</pre> In\u00a0[22]: Copied! <pre>m = Map(\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=14\n)\n\ngeo_json = GeoJson(\n    data=geojson,\n    style_function=lambda x: {\n        \"opacity\": 1,\n        \"dashArray\": \"1\",\n        \"fillOpacity\": 0,\n        \"weight\": 1,\n    },\n)\ngeo_json.add_to(m)\n\naod_layer = TileLayer(\n    tiles=tj_response[\"tiles\"][0],\n    attr=\"Mosaic\",\n    min_zoom=tj_response[\"minzoom\"],\n    max_zoom=tj_response[\"maxzoom\"],\n    max_native_zoom=tj_response[\"maxzoom\"],\n)\naod_layer.add_to(m)\nm\n</pre> m = Map(     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=14 )  geo_json = GeoJson(     data=geojson,     style_function=lambda x: {         \"opacity\": 1,         \"dashArray\": \"1\",         \"fillOpacity\": 0,         \"weight\": 1,     }, ) geo_json.add_to(m)  aod_layer = TileLayer(     tiles=tj_response[\"tiles\"][0],     attr=\"Mosaic\",     min_zoom=tj_response[\"minzoom\"],     max_zoom=tj_response[\"maxzoom\"],     max_native_zoom=tj_response[\"maxzoom\"], ) aod_layer.add_to(m) m Out[22]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/demo/#titilerpgstac-demo","title":"titiler.PgSTAC Demo\u00b6","text":"<p>This Notebook aims to show the different features provided by titiler.pgstac application</p> <p>In order to run this demo you'll need to have a PgSTAC database and the titiler.pgstac application running. The easiest way to launch them is to use the repo's docker-compose.yml</p> <pre><code>docker compose up tiler\n</code></pre>"},{"location":"notebooks/demo/#python-requirements","title":"Python requirements\u00b6","text":"<pre><code>pip install httpx folium pypgstac psycopg psycopg-pool geojson-pydantic\n</code></pre>"},{"location":"notebooks/demo/#populate-the-pgstac-db-with-data","title":"Populate the PgSTAC db with data\u00b6","text":"<pre><code>$ pypgstac load collections tests/fixtures/noaa-emergency-response.json --dsn postgresql://username:password@localhost:5439/postgis --method insert \n$ pypgstac load items tests/fixtures/noaa-eri-nashville2020.json --dsn postgresql://username:password@localhost:5439/postgis --method insert\n</code></pre>"},{"location":"notebooks/demo/#register-search-query","title":"Register Search query\u00b6","text":""},{"location":"notebooks/demo/#show-list-of-mosaics","title":"Show list of Mosaics\u00b6","text":""},{"location":"notebooks/demo/#get-search-metadata","title":"Get Search Metadata\u00b6","text":""},{"location":"notebooks/demo/#get-tilejson","title":"Get TileJSON\u00b6","text":"<p>Note: to return a valid tilejson document you'll need to pass either the <code>assets</code> or <code>expression</code> option.</p>"},{"location":"notebooks/demo/#load-tiles","title":"Load tiles\u00b6","text":""},{"location":"notebooks/demo/#register-a-mosaic-with-metadata","title":"Register a Mosaic with Metadata\u00b6","text":""}]}
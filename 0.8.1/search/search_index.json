{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> <p>Connect PgSTAC and TiTiler.</p> </p> <p> </p> <p>Documentation: stac-utils.github.io/titiler-pgstac/</p> <p>Source Code: stac-utils/titiler-pgstac</p> <p>TiTiler-PgSTAC is a TiTiler extension that connects to a PgSTAC database to create dynamic mosaics based on search queries.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install from PyPI and run:</p> <pre><code># Make sure to have pip up to date\n$ python -m pip install -U pip\n\n# Install `psycopg` or `psycopg[\"binary\"]` or `psycopg[\"c\"]`\n$ python -m pip install psycopg[\"binary\"]\n\n$ python -m pip install titiler.pgstac\n</code></pre> <p>To install from sources and run for development:</p> <pre><code>$ git clone https://github.com/stac-utils/titiler-pgstac.git\n$ cd titiler-pgstac\n$ python -m pip install -e .\n</code></pre>"},{"location":"#pgstac-version","title":"<code>PgSTAC</code> version","text":"<p><code>titiler.pgstac</code> depends on <code>pgstac &gt;=0.3.4</code> (github.com/stac-utils/pgstac/blob/main/CHANGELOG.md#v034).</p>"},{"location":"#psycopg-requirement","title":"<code>psycopg</code> requirement","text":"<p><code>titiler.pgstac</code> depends on the <code>psycopg</code> library. Because there are three ways of installing this package (<code>psycopg</code> or , <code>psycopg[\"c\"]</code>, <code>psycopg[\"binary\"]</code>), the user must install this separately from <code>titiler.pgstac</code>.</p> <ul> <li><code>psycopg</code>: no wheel, pure python implementation. It requires the <code>libpq</code> installed in the system.</li> <li><code>psycopg[\"binary\"]</code>: binary wheel distribution (shipped with libpq) of the <code>psycopg</code> package and is simpler for development. It requires development packages installed on the client machine.</li> <li><code>psycopg[\"c\"]</code>: a C (faster) implementation of the libpq wrapper. It requires the <code>libpq</code> installed in the system.</li> </ul> <p><code>psycopg[c]</code> or <code>psycopg</code> are generally recommended for production use.</p> <p>In <code>titiler.pgstac</code> setup.py, we have added three options to let users choose which psycopg install to use:</p> <ul> <li><code>pip install titiler.pgstac[\"psycopg\"]</code>: pure python</li> <li><code>pip install titiler.pgstac[\"psycopg-c\"]</code>: use the C wrapper (requires development packages installed on the client machine)</li> <li><code>pip install titiler.pgstac[\"psycopg-binary\"]</code>: binary wheels</li> </ul>"},{"location":"#launch","title":"Launch","text":"<p>You'll need to have <code>POSTGRES_USER</code>, <code>POSTGRES_PASS</code>, <code>POSTGRES_DBNAME</code>, <code>POSTGRES_HOST</code>, <code>POSTGRES_PORT</code> variables set in your environment pointing to your Postgres database where pgstac has been installed.</p> <pre><code>export POSTGRES_USER=username\nexport POSTGRES_PASS=password\nexport POSTGRES_DBNAME=postgis\nexport POSTGRES_HOST=database\nexport POSTGRES_PORT=5432\n</code></pre> <pre><code>$ pip install uvicorn\n$ uvicorn titiler.pgstac.main:app --reload\n</code></pre>"},{"location":"#using-docker","title":"Using Docker","text":"<pre><code>$ git clone https://github.com/stac-utils/titiler-pgstac.git\n$ cd titiler-pgstac\n$ docker-compose up --build tiler\n</code></pre> <p>It runs <code>titiler.pgstac</code> using Gunicorn web server. To run Uvicorn based version:</p> <pre><code>$ docker-compose up --build tiler-uvicorn\n</code></pre>"},{"location":"#contribution-development","title":"Contribution &amp; Development","text":"<p>See CONTRIBUTING.md</p>"},{"location":"#license","title":"License","text":"<p>See LICENSE</p>"},{"location":"#authors","title":"Authors","text":"<p>See contributors for a listing of individual contributors.</p>"},{"location":"#changes","title":"Changes","text":"<p>See CHANGES.md.</p>"},{"location":"contributing/","title":"Development - Contributing","text":"<p>Issues and pull requests are more than welcome: github.com/stac-utils/titiler-pgstac/issues</p> <p>dev install</p> <pre><code>$ git clone https://github.com/stac-utils/titiler-pgstac.git\n$ cd titiler\n$ pip install pre-commit -e .[\"dev,test\"]\n</code></pre> <p>You can then run the tests with the following command:</p> <pre><code>python -m pytest --cov titiler.pgstac --cov-report term-missing\n</code></pre> <p>This repo is set to use <code>pre-commit</code> to run isort, flake8, pydocstring, black (\"uncompromising Python code formatter\") and mypy when committing new code.</p> <pre><code>$ pre-commit install\n</code></pre>"},{"location":"intro/","title":"Intro","text":"<p>TiTiler.PgSTAC is a TiTiler extension, which create dynamic tiler connected to PgSTAC databases.</p> <p>By default the main application (<code>titiler.pgstac.main.app</code>) provides two sets of endpoints:</p> <ul> <li> <p><code>/mosaic/{searchid}</code>: Dynamic mosaic tiler based on STAC Search Queries</p> </li> <li> <p><code>/collections/{collection_id}/items/{item_id}</code>: Dynamic tiler for single STAC item (stored in PgSTAC)</p> </li> </ul>"},{"location":"intro/#mosaic","title":"Mosaic","text":"<p>The goal of the <code>mosaic</code> endpoints is to use any <code>search</code> query to create tiles. <code>titiler-pgstac</code> provides a set of endpoint to <code>register</code> and <code>list</code> the <code>search</code> queries.</p>"},{"location":"intro/#register-a-search-request","title":"Register a <code>Search</code> request","text":"<p>Important</p> <p>In <code>TiTiler.PgSTAC</code> a STAC <code>Search Query</code> is equivalent to a Mosaic.</p> <p>Before being able to create Map Tiles, the user needs to register a <code>Search Query</code> within the PgSTAC database (in the <code>searches</code> table). By default, <code>TiTiler.PgSTAC</code> has a <code>/mosaic/register (POST)</code> endpoint which will:</p> <ul> <li>validate the search query (based on the STAC API specification <code>item-search</code>)</li> <li>send the search query to the postgres database using the <code>search_query</code> PgSTAC function</li> <li>return a <code>searchid</code> (might be also called <code>mosaicid</code>).</li> </ul> <p>Example</p> <pre><code>curl -X 'POST' 'http://127.0.0.1:8081/mosaic/register' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"collections\":[\"landsat-c2l2-sr\"], \"bbox\":[-123.75,34.30714385628804,-118.125,38.82259097617712], \"filter-lang\": \"cql-json\"}' | jq\n\n&gt;&gt; {\n  \"searchid\": \"5a1b82d38d53a5d200273cbada886bd7\",\n  \"links\": [\n    {\n      \"rel\": \"metadata\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/5a1b82d38d53a5d200273cbada886bd7/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/5a1b82d38d53a5d200273cbada886bd7/tilejson.json\"\n    }\n  ]\n}\n\n# Or using CQL-2\ncurl -X 'POST' 'http://127.0.0.1:8081/mosaic/register' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"filter\": {\"op\": \"and\", \"args\": [{\"op\": \"=\", \"args\": [{\"property\": \"collection\"}, \"landsat-c2l2-sr\"]}, {\"op\": \"s_intersects\", \"args\": [{\"property\": \"geometry\"}, {\"coordinates\": [[[-123.75, 34.30714385628804], [-123.75, 38.82259097617712], [-118.125, 38.82259097617712], [-118.125, 34.30714385628804], [-123.75, 34.30714385628804]]], \"type\": \"Polygon\"}]}]}}' | jq\n\n&gt;&gt; {\n  \"searchid\": \"5063721f06957d6b2320326d82e90d1e\",\n  \"links\": [\n    {\n      \"rel\": \"metadata\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/5063721f06957d6b2320326d82e90d1e/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/5063721f06957d6b2320326d82e90d1e/tilejson.json\"\n    }\n  ]\n}\n</code></pre>"},{"location":"intro/#mosaic-metadata","title":"Mosaic metadata","text":"<pre><code>curl http://127.0.0.1:8081/mosaic/5063721f06957d6b2320326d82e90d1e/info | jq\n\n&gt;&gt; {\n  \"search\": {\n    \"hash\": \"5063721f06957d6b2320326d82e90d1e\",  # &lt;-- this is the search/mosaic ID\n    \"search\": {  # &lt;-- Summary of the search request\n      \"filter\": {  # &lt;-- this is CQL2 filter associated with the search\n        \"op\": \"and\",\n        \"args\": [\n          {\n            \"op\": \"=\",\n            \"args\": [\n              {\n                \"property\": \"collection\"\n              },\n              \"landsat-c2l2-sr\"\n            ]\n          },\n          {\n            \"op\": \"s_intersects\",\n            \"args\": [\n              {\n                \"property\": \"geometry\"\n              },\n              {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                  [\n                    [\n                      -123.75,\n                      34.30714385628804\n                    ],\n                    [\n                      -123.75,\n                      38.82259097617712\n                    ],\n                    [\n                      -118.125,\n                      38.82259097617712\n                    ],\n                    [\n                      -118.125,\n                      34.30714385628804\n                    ],\n                    [\n                      -123.75,\n                      34.30714385628804\n                    ]\n                  ]\n                ]\n              }\n            ]\n          }\n        ]\n      }\n    },\n    \"_where\": \"(  ( (collection_id = 'landsat-c2l2-sr') and st_intersects(geometry, '0103000020E610000001000000050000000000000000F05EC055F6687D502741400000000000F05EC02D553EA94A6943400000000000885DC02D553EA94A6943400000000000885DC055F6687D502741400000000000F05EC055F6687D50274140'::geometry) )  )  \",  # &lt;-- internal pgstac WHERE expression\n    \"orderby\": \"datetime DESC, id DESC\",\n    \"lastused\": \"2022-03-03T11:44:55.878504+00:00\",  # &lt;-- internal pgstac variable\n    \"usecount\": 2,  # &lt;-- internal pgstac variable\n    \"metadata\": {  # &lt;-- titiler-pgstac Mosaic Metadata\n      \"type\": \"mosaic\"  # &lt;-- where using the `/mosaic/register` endpoint, titiler-pgstac will add `type=mosaic` to the metadata\n    }\n  },\n  \"links\": [\n    {\n      \"rel\": \"self\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/5063721f06957d6b2320326d82e90d1e/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/5063721f06957d6b2320326d82e90d1e/tilejson.json\"\n    }\n  ]\n}\n</code></pre> <p>Note: In addition to the <code>search query</code>, a user can pass <code>metadata</code>, which will be saved in the postgres table.</p> <pre><code>curl -X 'POST' 'http://127.0.0.1:8081/mosaic/register' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"collections\":[\"landsat-c2l2-sr\"], \"bbox\":[-123.75,34.30714385628804,-118.125,38.82259097617712], \"filter-lang\": \"cql-json\", \"metadata\": {\"minzoom\": 8, \"maxzoom\": 13, \"assets\": [\"B04\", \"B03\", \"B02\"], \"defaults\": {\"true_color\": {\"assets\": [\"B04\", \"B03\", \"B02\"], \"color_formula\": \"Gamma RGB 3.5 Saturation 1.7 Sigmoidal RGB 15 0.35\"}}}}' | jq\n\n&gt;&gt; {\n  \"searchid\": \"f31d7de8a5ddfa3a80b9a9dd06378db1\",\n  \"links\": [\n    {\n      \"rel\": \"metadata\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/f31d7de8a5ddfa3a80b9a9dd06378db1/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/f31d7de8a5ddfa3a80b9a9dd06378db1/tilejson.json\"\n    }\n  ]\n}\n\ncurl http://127.0.0.1:8081/mosaic/f31d7de8a5ddfa3a80b9a9dd06378db1/info | jq '.search.metadata'\n&gt;&gt; {\n  \"type\": \"mosaic\",\n  \"minzoom\": 8,\n  \"maxzoom\": 13,\n  \"assets\": [\n    \"B04\",\n    \"B03\",\n    \"B02\"\n  ],\n  \"defaults\": {\n    \"true_color\": {\n      \"assets\": [\n        \"B04\",\n        \"B03\",\n        \"B02\"\n      ],\n      \"color_formula\": \"Gamma RGB 3.5 Saturation 1.7 Sigmoidal RGB 15 0.35\"\n    }\n  }\n}\n</code></pre>"},{"location":"intro/#fetch-mosaic-tiles","title":"Fetch mosaic <code>Tiles</code>","text":"<p>When we have a <code>searchid</code> we can now call the dynamic tiler and ask for Map Tiles.</p> <p></p> <p>How it works</p> <p>On each <code>Tile</code> request, the tiler api is going to call the PgSTAC <code>geometrysearch</code> function with the <code>searchid</code> and the Tile geometry to get the list of STAC items (code). Then based on the <code>assets</code> parameter, the tiler will construct the tile image (code).</p> <p>Important</p> <p>Because <code>Tiles</code> will be created from STAC items we HAVE TO pass <code>assets={stac asset}</code> option to the tile endpoint.</p> <p>See full list of options</p> <p>Example</p> <pre><code>curl 'http://127.0.0.1:8081/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/tiles/8/40/102.png?assets=B01&amp;rescale=0,16000 &gt; 8-40-102.png\n</code></pre>"},{"location":"intro/#items","title":"Items","text":"<p>Set of endpoints created using TiTiler's <code>MultiBaseTilerFactory</code> but with <code>item</code> and <code>collection</code> path parameter (instead of the <code>url=</code> query parameter).</p> <p>example</p> <pre><code>curl http://127.0.0.1:8081/collections/landsat-c2l2-sr/items/LC08_L1TP_028004_20171002_20171018_01_A1\n</code></pre> <p>See full list of endpoints</p>"},{"location":"item_endpoints/","title":"Item","text":"<p>The <code>titiler.pgstac</code> package comes with a full FastAPI application with Mosaic and single STAC item support.</p> <p>The <code>Item</code> endpoints are created using TiTiler's MultiBaseTilerFactory</p> Method URL Output Description <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/bounds</code> JSON (Bounds) return dataset's bounds <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/assets</code> JSON return the list of available assets <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/info</code> JSON (Info) return assets basic info <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/info.geojson</code> GeoJSON (InfoGeoJSON) return assets basic info as a GeoJSON feature <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/asset_statistics</code> JSON (Statistics) return per asset statistics <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/statistics</code> JSON (Statistics) return assets statistics (merged) <code>POST</code> <code>/collections/{collection_id}/items/{item_id}/statistics</code> GeoJSON (Statistics) return assets statistics for a GeoJSON (merged) <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/tiles[/{TileMatrixSetId}]/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin create a web map tile image from assets <code>GET</code> <code>/collections/{collection_id}/items/{item_id}[/{TileMatrixSetId}]/tilejson.json</code> JSON (TileJSON) return a Mapbox TileJSON document <code>GET</code> <code>/collections/{collection_id}/items/{item_id}[/{TileMatrixSetId}]/WMTSCapabilities.xml</code> XML return OGC WMTS Get Capabilities <code>GET</code> <code>/collections/{collection_id}/items/{item_id}[/{TileMatrixSetId}]/map</code> HTML simple map viewer <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/point/{lon},{lat}</code> JSON (Point) return pixel values from assets <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/preview[.{format}]</code> image/bin create a preview image from assets <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/crop/{minx},{miny},{maxx},{maxy}[/{width}x{height}].{format}</code> image/bin create an image from part of assets <code>POST</code> <code>/collections/{collection_id}/items/{item_id}/crop[/{width}x{height}][.{format}]</code> image/bin create an image from a geojson feature intersecting assets"},{"location":"item_endpoints/#tiles","title":"Tiles","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/tiles[/{TileMatrixSetId}]/{z}/{x}/{y}[@{scale}x][.{format}]</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> <li>TileMatrixSetId (str): TileMatrixSet name, default is <code>WebMercatorQuad</code>. Optional</li> <li>z (int): TMS tile's zoom level.</li> <li>x (int): TMS tile's column.</li> <li>y (int): TMS tile's row.</li> <li>scale (int): Tile size scale, default is set to 1 (256x256). Optional</li> <li>format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Add buffer on each side of the tile (e.g 0.5 = 257x257, 1.0 = 258x258).</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/tiles/1/2/3?assets=B01&amp;assets=B00</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/tiles/1/2/3.jpg?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/tiles/WorldCRS84Quad/1/2/3@2x.png?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/tiles/WorldCRS84Quad/1/2/3?expression=B01/B02&amp;rescale=0,1000&amp;colormap_name=cfastie&amp;asset_as_band=True</code></li> </ul>"},{"location":"item_endpoints/#preview","title":"Preview","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/preview[.{format}]</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> <li>format: Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>max_size (int): Max image size, default is 1024.</li> <li>height (int): Force output image height.</li> <li>width (int): Force output image width.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> </ul> </li> </ul> <p>Important</p> <ul> <li> <p>assets OR expression is required</p> </li> <li> <p>if height and width are provided max_size will be ignored.</p> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/preview?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/preview.jpg?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/preview?assets=B01&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul>"},{"location":"item_endpoints/#crop-part","title":"Crop / Part","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/crop/{minx},{miny},{maxx},{maxy}.{format}</code> <code>:endpoint:/collections/{collection_id}/items/{item_id}/crop/{minx},{miny},{maxx},{maxy}/{width}x{height}.{format}</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> <li>minx,miny,maxx,maxy (str): Comma (',') delimited bounding box in WGS84.</li> <li>height (int): Force output image height. Optional</li> <li>width (int): Force output image width. Optional</li> <li>format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>max_size (int): Max image size, default is 1024.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> </ul> </li> </ul> <p>Important</p> <ul> <li> <p>assets OR expression is required</p> </li> <li> <p>if height and width are provided max_size will be ignored.</p> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/crop/0,0,10,10.png?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/crop/0,0,10,10.png?assets=B01&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul> <p><code>:endpoint:/collections/{collection_id}/items/{item_id}/crop[/{width}x{height}][].{format}] - [POST]</code></p> <ul> <li> <p>Body:</p> <ul> <li>feature (JSON): A valid GeoJSON feature (Polygon or MultiPolygon)</li> </ul> </li> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> <li>height (int): Force output image height. Optional</li> <li>width (int): Force output image width. Optional</li> <li>format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>max_size (int): Max image size, default is 1024.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> </ul> </li> </ul> <p>Important</p> <ul> <li> <p>assets OR expression is required</p> </li> <li> <p>if height and width are provided max_size will be ignored.</p> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/crop?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/crop.png?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/100x100.png?assets=B01&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul>"},{"location":"item_endpoints/#point","title":"Point","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/point/{lon},{lat}</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> <li>lon,lat, (str): Comma (',') delimited point Longitude and Latitude WGS84.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/point/0,0?assets=B01</code></li> </ul>"},{"location":"item_endpoints/#tilesjson","title":"TilesJSON","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}[/{TileMatrixSetId}]/tilejson.json</code> tileJSON document</p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> <li>TileMatrixSetId: TileMatrixSet name, default is <code>WebMercatorQuad</code>.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>tile_format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value.</li> <li>tile_scale (int): Tile size scale, default is set to 1 (256x256).</li> <li>minzoom (int): Overwrite default minzoom.</li> <li>maxzoom (int): Overwrite default maxzoom.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Add buffer on each side of the tile (e.g 0.5 = 257x257, 1.0 = 258x258).</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/tilejson.json?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/tilejson.json?assets=B01&amp;tile_format=png</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/WorldCRS84Quad/tilejson.json?tile_scale=2&amp;expression=B01/B02&amp;asset_as_band=True</code></li> </ul>"},{"location":"item_endpoints/#bounds","title":"Bounds","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/bounds</code> - Return the bounds of the STAC item.</p> <ul> <li>PathParams:<ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/bounds</code></li> </ul>"},{"location":"item_endpoints/#info","title":"Info","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/info</code> - Return basic info on STAC item's COG.</p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names. Default to all available assets.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/info?assets=B01</code></li> </ul> <p><code>:endpoint:/collections/{collection_id}/items/{item_id}/info.geojson</code> - Return basic info on STAC item's COG as a GeoJSON feature</p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>collection (str): STAC Collection ID. Required</li> <li>item (str): STAC Item ID. Required</li> <li>assets (array[str]): asset names. Default to all available assets.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/info.geojson?assets=B01</code></li> </ul> <p><code>:endpoint:/collections/{collection_id}/items/{item_id}/assets</code> - Return the list of available assets</p>"},{"location":"item_endpoints/#available-assets","title":"Available Assets","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/assets</code> - Return a list of available assets</p> <ul> <li>PathParams:<ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/assets</code></li> </ul>"},{"location":"item_endpoints/#statistics","title":"Statistics","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/asset_statistics - [GET]</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>collection (str): STAC Collection ID. Required</li> <li>item (str): STAC Item ID. Required</li> <li>assets (array[str]): asset names. Default to all available assets.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>asset_expression (array[str]): Per asset band math expression (e.g <code>Asset1|b1\\*b2</code>).</li> <li>max_size (int): Max image size from which to calculate statistics, default is 1024.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/statistics?assets=B01&amp;categorical=true&amp;c=1&amp;c=2&amp;c=3&amp;p=2&amp;p98</code></li> </ul> <p><code>:endpoint:/collections/{collection_id}/items/{item_id}/statistics - [GET]</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>collection (str): STAC Collection ID. Required</li> <li>item (str): STAC Item ID. Required</li> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>max_size (int): Max image size from which to calculate statistics, default is 1024.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/statistics?assets=B01&amp;categorical=true&amp;c=1&amp;c=2&amp;c=3&amp;p=2&amp;p98</code></li> </ul> <p><code>:endpoint:/collections/{collection_id}/items/{item_id}/statistics - [POST]</code></p> <ul> <li> <p>Body:</p> <ul> <li>feature (JSON): A valid GeoJSON feature or FeatureCollection</li> </ul> </li> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>max_size (int): Max image size from which to calculate statistics, default is 1024.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/statistics?assets=B01&amp;categorical=true&amp;c=1&amp;c=2&amp;c=3&amp;p=2&amp;p98</code></li> </ul>"},{"location":"mosaic_endpoints/","title":"Mosaic","text":"<p>The <code>titiler.pgstac</code> package comes with a full FastAPI application with Mosaic and single STAC item support.</p> Method URL Output Description <code>POST</code> <code>/mosaic/register</code> JSON (Register) Register Search query <code>GET</code> <code>/mosaic/{searchid}/info</code> JSON (Info) Return Search query infos <code>GET</code> <code>/mosaic/list</code> JSON (Infos) Return list of Search entries with <code>Mosaic</code> type <code>GET</code> <code>/mosaic/{searchid}/{lon},{lat}/assets</code> JSON Return a list of assets which overlap a given point <code>GET</code> <code>/mosaic/{searchid}/tiles[/{TileMatrixSetId}]/{z}/{x}/{Y}/assets</code> JSON Return a list of assets which overlap a given tile <code>GET</code> <code>/mosaic/{searchid}/tiles[/{TileMatrixSetId}]/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin Create a web map tile image for a search query and a tile index <code>GET</code> <code>/mosaic/{searchid}[/{TileMatrixSetId}]/tilejson.json</code> JSON (TileJSON) Return a Mapbox TileJSON document <code>GET</code> <code>/mosaic/{searchid}[/{TileMatrixSetId}]/WMTSCapabilities.xml</code> XML return OGC WMTS Get Capabilities <code>GET</code> <code>/mosaic/{searchid}[/{TileMatrixSetId}]/map</code> HTML simple map viewer <code>POST</code> <code>/mosaic/{searchid}/statistics</code> GeoJSON (Statistics) Return statistics for geojson features <code>GET</code> <code>/mosaic/{searchid}/bbox/{minx},{miny},{maxx},{maxy}[/{width}x{height}].{format}</code> image/bin Create an image from part of a dataset <code>POST</code> <code>/mosaic/{searchid}/feature[/{width}x{height}][.{format}]</code> image/bin Create an image from a GeoJSON feature"},{"location":"mosaic_endpoints/#register-a-search-request","title":"Register a Search Request","text":"<p><code>:endpoint:/mosaic/register - [POST]</code></p> <ul> <li>Body (a combination of Search+Metadata): A JSON body composed of a valid STAC Search query (see: github.com/radiantearth/stac-api-spec/tree/master/item-search) and Mosaic's metadata.</li> </ul> <pre><code>// titiler-pgstac search body example\n{\n  // STAC search query\n  \"collections\": [\n    \"string\"\n  ],\n  \"ids\": [\n    \"string\"\n  ],\n  \"bbox\": [\n    \"number\",\n    \"number\",\n    \"number\",\n    \"number\"\n  ],\n  \"intersects\": {\n    \"type\": \"Point\",\n    \"coordinates\": [\n      \"number\",\n      \"number\"\n    ]\n  },\n  \"query\": {\n    \"additionalProp1\": {},\n    \"additionalProp2\": {},\n    \"additionalProp3\": {}\n  },\n  \"filter\": {},\n  \"datetime\": \"string\",\n  \"sortby\": \"string\",\n  \"filter-lang\": \"cql-json\",\n  // titiler-pgstac mosaic metadata\n  \"metadata\": {\n    \"type\": \"mosaic\",\n    \"bounds\": [\n      \"number\",\n      \"number\",\n      \"number\",\n      \"number\"\n    ],\n    \"minzoom\": \"number\",\n    \"maxzoom\": \"number\",\n    \"name\": \"string\",\n    \"assets\": [\n      \"string\",\n      \"string\",\n    ],\n    \"defaults\": {}\n  }\n}\n</code></pre> <p>Important</p> <p>In <code>titiler-pgstac</code> we extended the regular <code>stac</code> search to add a metadata entry. Metadata defaults to <code>{\"type\": \"mosaic\"}</code>.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/mosaic/register</code></li> </ul> <pre><code>curl -X 'POST' 'http://127.0.0.1:8081/mosaic/register' -H 'accept: application/json' -H 'Content-Type: application/json' -d '{\"collections\":[\"landsat-c2l2-sr\"], \"bbox\":[-123.75,34.30714385628804,-118.125,38.82259097617712], \"filter-lang\": \"cql-json\"}' | jq\n&gt;&gt; {\n  \"searchid\": \"5a1b82d38d53a5d200273cbada886bd7\",\n  \"links\": [\n    {\n      \"rel\": \"metadata\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/5a1b82d38d53a5d200273cbada886bd7/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/5a1b82d38d53a5d200273cbada886bd7/tilejson.json\"\n    }\n  ]\n}\n\n# or using CQL2\ncurl -X 'POST' 'http://127.0.0.1:8081/mosaic/register' -H 'accept: application/json' -H 'Content-Type: application/json' -d '{\"filter\": {\"op\": \"=\", \"args\": [{\"property\": \"collection\"}, \"landsat-c2l2-sr\"]}}'\n\n# or using CQL2 with metadata\ncurl -X 'POST' 'http://127.0.0.1:8081/mosaic/register' -H 'accept: application/json' -H 'Content-Type: application/json' -d '{\"filter\": {\"op\": \"=\", \"args\": [{\"property\": \"collection\"}, \"landsat-c2l2-sr\"]}, \"metadata\": {\"name\": \"landsat mosaic\"}}'\n</code></pre>"},{"location":"mosaic_endpoints/#search-infos","title":"Search infos","text":"<p><code>:endpoint:/mosaic/{searchid}/info - [GET]</code></p> <ul> <li>PathParams:<ul> <li>searchid: search query hashkey.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/mosaic/5a1b82d38d53a5d200273cbada886bd7/info</code></li> </ul> <pre><code>curl 'http://127.0.0.1:8081/mosaic/5a1b82d38d53a5d200273cbada886bd7/info' | jq\n&gt;&gt; {\n  \"search\": {\n    \"hash\": \"5a1b82d38d53a5d200273cbada886bd7\",\n    \"search\": {\n      \"bbox\": [\n        -123.75,\n        34.30714385628804,\n        -118.125,\n        38.82259097617712\n      ],\n      \"collections\": [\n        \"landsat-c2l2-sr\"\n      ],\n      \"filter-lang\": \"cql-json\"\n    },\n    \"_where\": \"(  TRUE  )  AND collection_id = ANY ('{landsat-c2l2-sr}')  AND geometry &amp;&amp; '0103000020E610000001000000050000000000000000F05EC055F6687D502741400000000000F05EC02D553EA94A6943400000000000885DC02D553EA94A6943400000000000885DC055F6687D502741400000000000F05EC055F6687D50274140' \",\n    \"orderby\": \"datetime DESC, id DESC\",\n    \"lastused\": \"2022-03-03T11:42:07.213313+00:00\",\n    \"usecount\": 2,\n    \"metadata\": {\n      \"type\": \"mosaic\"\n    }\n  },\n  \"links\": [\n    {\n      \"rel\": \"self\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/5a1b82d38d53a5d200273cbada886bd7/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/5a1b82d38d53a5d200273cbada886bd7/tilejson.json\"\n    }\n  ]\n}\n</code></pre>"},{"location":"mosaic_endpoints/#list-searches","title":"List Searches","text":"<p><code>:endpoint:/mosaic/list - [GET]</code></p> <ul> <li>QueryParams:<ul> <li>limit (int): Page size limit, Default is <code>10</code>.</li> <li>offset (int): Page offset.</li> <li>sortby (str): Sort the searches by Metadata properties (ascending (default) or descending (<code>-</code>)).</li> </ul> </li> </ul> <p>Important</p> <p>Additional query-parameters (form <code>PROP=VALUE</code>) will be considered as a property filter.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/mosaic/list</code></li> <li><code>https://myendpoint/mosaic/list?limit=100</code></li> <li><code>https://myendpoint/mosaic/list?limit=10&amp;offset=10</code> (page 2)</li> <li><code>https://myendpoint/mosaic/list?data=noaa</code> (only show mosaics with <code>metadata.data == noaa</code>)</li> <li><code>https://myendpoint/mosaic/list?sortby=lastused</code> (sort mosaic by <code>lastused</code> pgstac search property)</li> <li><code>https://myendpoint/mosaic/list?sortby=-prop</code> (sort mosaic (descending) by <code>metadata.prop</code> values)</li> </ul>"},{"location":"mosaic_endpoints/#tiles","title":"Tiles","text":"<p><code>:endpoint:/mosaic/{searchid}/tiles[/{TileMatrixSetId}]/{z}/{x}/{y}[@{scale}x][.{format}]</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>searchid: search query hashkey.</li> <li>TileMatrixSetId: TileMatrixSet name, default is <code>WebMercatorQuad</code>. OPTIONAL</li> <li>z: Tile's zoom level.</li> <li>x: Tile's column.</li> <li>y: Tile's row.</li> <li>scale: Tile size scale, default is set to 1 (256x256). OPTIONAL</li> <li>format: Output image format, default is set to None and will be either JPEG or PNG depending on masked value. OPTIONAL</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>nodata: Overwrite internal Nodata value. OPTIONAL</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Add buffer on each side of the tile (e.g 0.5 = 257x257, 1.0 = 258x258).</li> <li>pixel_selection (str): Pixel selection method (cogeotiff.github.io/rio-tiler/mosaic/).</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/tiles/1/2/3?assets=B01</code></li> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/tiles/1/2/3.jpg?assets=B01</code></li> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/tiles/WorldCRS84Quad/1/2/3@2x.png?assets=B01&amp;assets=B02&amp;assets=B03</code></li> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/tiles/WorldCRS84Quad/1/2/3?assets=B01&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul>"},{"location":"mosaic_endpoints/#tilesjson","title":"TilesJSON","text":"<p><code>:endpoint:/mosaic/{searchid}[/{TileMatrixSetId}]/tilejson.json</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>searchid: search query hashkey.</li> <li>TileMatrixSetId: TileMatrixSet name, default is <code>WebMercatorQuad</code>. OPTIONAL</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>tile_format: Output image format, default is set to None and will be either JPEG or PNG depending on masked value.</li> <li>tile_scale: Tile size scale, default is set to 1 (256x256). OPTIONAL</li> <li>minzoom: Overwrite default minzoom. OPTIONAL</li> <li>maxzoom: Overwrite default maxzoom. OPTIONAL</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Add buffer on each side of the tile (e.g 0.5 = 257x257, 1.0 = 258x258).</li> <li>pixel_selection (str): Pixel selection method (cogeotiff.github.io/rio-tiler/mosaic/).</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/tilejson.json?assets=B01</code></li> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/tilejson.json?assets=B01&amp;tile_format=png</code></li> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/WorldCRS84Quad/tilejson.json?assets=B01&amp;tile_scale=2</code></li> </ul>"},{"location":"mosaic_endpoints/#wmts","title":"WMTS","text":"<p><code>:endpoint:/mosaic/{searchid}[/{TileMatrixSetId}]/WMTSCapabilities.xml</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>searchid: search query hashkey.</li> <li>TileMatrixSetId: TileMatrixSet name, default is <code>WebMercatorQuad</code>. OPTIONAL</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>tile_format: Output image format, default is set to PNG.</li> <li>tile_scale: Tile size scale, default is set to 1 (256x256). OPTIONAL</li> <li>minzoom: Overwrite default minzoom. OPTIONAL</li> <li>maxzoom: Overwrite default maxzoom. OPTIONAL</li> </ul> </li> </ul> <p>Important</p> <p>additional query-parameters will be forwarded to the <code>tile</code> URL. If no <code>defaults</code> mosaic metadata, assets OR expression will be required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/WMTSCapabilities.xml?assets=B01</code></li> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/WMTSCapabilities.xml?assets=B01&amp;tile_format=png</code></li> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/WorldCRS84Quad/WMTSCapabilities.xml?assets=B01&amp;tile_scale=2</code></li> </ul>"},{"location":"mosaic_endpoints/#assets","title":"Assets","text":"<p><code>:endpoint:/mosaic/{searchid}/tiles/[{TileMatrixSetId}]/{z}/{x}/{y}/assets</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>searchid: search query hashkey.</li> <li>TileMatrixSetId: TileMatrixSet name, default is <code>WebMercatorQuad</code>. OPTIONAL</li> <li>z: Tile's zoom level.</li> <li>x: Tile's column.</li> <li>y: Tile's row.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/tiles/0/0/0/assets</code></li> </ul> <p><code>:endpoint:/mosaic/{searchid}/{lon},{lat}/assets</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>searchid: search query hashkey.</li> <li>lon: Longitude (in WGS84 CRS).</li> <li>lat: Latitude (in WGS84 CRS).</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/0.0,0.0/assets</code></li> </ul>"},{"location":"mosaic_endpoints/#statistics","title":"Statistics","text":"<p><code>:endpoint:/mosaic/{searchid}/statistics - [POST]</code></p> <ul> <li> <p>Body:</p> <ul> <li>feature (JSON): A valid GeoJSON feature or FeatureCollection</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input geometry. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size from which to calculate statistics.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>nodata: Overwrite internal Nodata value. OPTIONAL</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds.</li> <li>pixel_selection (str): Pixel selection method (cogeotiff.github.io/rio-tiler/mosaic/).</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> </ul> </li> </ul> <p>Important</p> <p>if height and width are provided max_size will be ignored.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/statistics?assets=B01</code></li> </ul>"},{"location":"mosaic_endpoints/#bboxfeature","title":"BBOX/Feature","text":"<p><code>:endpoint:/mosaic/{searchid}/bbox/{minx},{miny},{maxx},{maxy}.{format}</code></p> <p><code>:endpoint:/mosaic/{searchid}/bbox/{minx},{miny},{maxx},{maxy}/{width}x{height}.{format}</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>searchid: search query hashkey.</li> <li>minx,miny,maxx,maxy (str): Comma (',') delimited bounding box in WGS84.</li> <li>format (str): Output image format.</li> <li>height (int): Force output image height.</li> <li>width (int): Force output image width.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input coordinates. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size.</li> <li>nodata: Overwrite internal Nodata value. OPTIONAL</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>pixel_selection (str): Pixel selection method (cogeotiff.github.io/rio-tiler/mosaic/).</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> </ul> </li> </ul> <p>Important</p> <p>if height and width are provided max_size will be ignored.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/bbox/0,0,10,10.png?assets=B01</code></li> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/bbox/0,0,10,10/400x300.png?assets=B01</code></li> </ul> <p><code>:endpoint:/mosaic/{searchid}/feature[/{width}x{height}][].{format}] - [POST]</code></p> <ul> <li> <p>Body:</p> <ul> <li>feature (JSON): A valid GeoJSON feature (Polygon or MultiPolygon)</li> </ul> </li> <li> <p>PathParams:</p> <ul> <li>height (int): Force output image height. Optional</li> <li>width (int): Force output image width. Optional</li> <li>format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input geometry. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size.</li> <li>nodata: Overwrite internal Nodata value. OPTIONAL</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>pixel_selection (str): Pixel selection method (cogeotiff.github.io/rio-tiler/mosaic/).</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> </ul> </li> </ul> <p>Important</p> <p>if height and width are provided max_size will be ignored.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/feature?assets=B01</code></li> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/feature.png?assets=B01f</code></li> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/feature/100x100.png?assets=B01</code></li> </ul>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#081-2023-11-10","title":"0.8.1 (2023-11-10)","text":"<ul> <li>add <code>algorithm</code> options for <code>/statistics [POST]</code> endpoints</li> </ul>"},{"location":"release-notes/#080-2023-10-06","title":"0.8.0 (2023-10-06)","text":"<ul> <li>update titiler requirement to <code>&gt;=0.14.0,&lt;0.15</code></li> <li>remove <code>max_size</code> default for mosaic's <code>/statistics [POST]</code> endpoint  breaking change</li> <li>add <code>/bbox</code> and <code>/feature [POST]</code> optional endpoints</li> <li>add <code>img_part_dependency</code> attribute in <code>MosaicTilerFactory</code> (defaults to <code>titiler.code.dependencies.PartFeatureParams</code>)</li> </ul>"},{"location":"release-notes/#070-2023-09-28","title":"0.7.0 (2023-09-28)","text":"<ul> <li>update requirements to switch to pydantic~=2.0</li> <li>pydantic&gt;=2.4,&lt;3.0</li> <li>pydantic-settings~=2.0</li> <li>geojson-pydantic~=1.0</li> <li> <p>cogeo-mosaic&gt;=7.0,&lt;8.0</p> </li> <li> <p>update titiler requirement to <code>&gt;=0.14.0,&lt;0.15</code></p> <ul> <li> <p>replace <code>-</code> by <code>_</code> in query parameters</p> <ul> <li>coord-crs -&gt; coord_crs</li> <li>dst-crs -&gt; dst_crs</li> </ul> </li> </ul> </li> </ul>"},{"location":"release-notes/#060-2023-09-18","title":"0.6.0 (2023-09-18)","text":"<ul> <li>add <code>tilejson</code> URL links for <code>layers</code> defined in mosaic's metadata in <code>/mosaic/register</code> and <code>/mosaic/{mosaic_id}/info</code> response</li> <li>support multiple <code>layers</code> in <code>/mosaic/{mosaic_id}/WMTSCapabilities.xml</code> endpoint created from mosaic's metadata</li> </ul> <p>breaking change</p> <ul> <li> <p>In <code>/mosaic/WMTSCapabilities.xml</code> we removed the query-parameters related to the <code>tile</code> endpoint (which are forwarded) so <code>?assets=</code> is no more required. The endpoint will still raise an error if there are no <code>layers</code> in the mosaic metadata and no required tile's parameters are passed.</p> <pre><code># before\nresponse = httpx.get(\"/mosaic/{mosaic_id}/WMTSCapabilities.xml\")\nassert response.status_code == 400\n\nresponse = httpx.get(\"/mosaic/{mosaic_id}/WMTSCapabilities.xml?assets=cog\")\nassert response.status_code == 200\n\n# now\n# If the mosaic has `defaults` layers set in the metadata\n# we will construct a WMTS document with multiple layers, so no need for the user to pass any `assets=`\nresponse = httpx.get(\"/mosaic/{mosaic_id}/WMTSCapabilities.xml\")\nassert response.status_code == 200\nwith rasterio.open(io.BytesIO(response.content)) as src:\n    assert src.profile[\"driver\"] == \"WMTS\"\n    assert len(src.subdatasets) == 2\n\n# If the user pass any valid `tile` parameters, an additional layer will be added to the one from the metadata\nresponse = httpx.get(\"/mosaic/{mosaic_id}/WMTSCapabilities.xml?assets=cog\")\nassert response.status_code == 200\nwith rasterio.open(io.BytesIO(response.content)) as src:\n    assert src.profile[\"driver\"] == \"WMTS\"\n    assert len(src.subdatasets) == 3\n</code></pre> </li> </ul>"},{"location":"release-notes/#051-2023-08-03","title":"0.5.1 (2023-08-03)","text":"<ul> <li>add <code>python-dotenv</code> requirement</li> </ul>"},{"location":"release-notes/#050-2023-07-20","title":"0.5.0 (2023-07-20)","text":"<ul> <li>update <code>titiler</code> requirement to <code>&gt;=0.12.0,&lt;0.13</code></li> <li>use <code>Annotated</code> Type for Query/Path parameters</li> <li>re-order endpoints in <code>MosaicTilerFactory</code> to avoid conflicts between <code>tiles</code> and <code>assets</code> endpoints</li> <li>remove <code>stac-pydantic</code> dependency</li> <li>add optional <code>root_path</code> setting to specify a url path prefix to use when running the app behind a reverse proxy</li> <li>add landing page <code>/</code></li> <li>use <code>lifespan</code> option instead of deprecated <code>@app.on_event</code> method to initiate/close DB connection</li> </ul> <p>breaking changes</p> <ul> <li>remove deprecated <code>/{searchid}/{z}/{x}/{y}/assets</code> endpoints</li> <li>use /api and /api.html for documentation (instead of /openapi.json and /docs)</li> <li>replace Enum's with <code>Literal</code> types</li> <li>replace variable <code>TileMatrixSetId</code> by <code>tileMatrixSetId</code></li> <li>add <code>pixel_selection_dependency</code> attribute to the <code>MosaicTilerFactory</code></li> </ul>"},{"location":"release-notes/#041-2023-06-21","title":"0.4.1 (2023-06-21)","text":"<ul> <li>update <code>titiler</code> requirement to <code>&gt;=0.11.7</code></li> <li>fix <code>/map</code> endpoint template name</li> <li>rename <code>add_map_viewer</code> to <code>add_viewer</code> option in <code>MosaicTilerFactory</code> for consistency with <code>titiler's</code> options</li> </ul>"},{"location":"release-notes/#040-2023-05-22","title":"0.4.0 (2023-05-22)","text":"<ul> <li>remove deprecated <code>/tiles/{searchid}/...</code> endpoints (replaced with <code>/{searchid}/tiles/...</code>)</li> <li>depreciate <code>/{searchid}/{z}/{x}/{y}/assets</code> endpoints and add <code>/{searchid}/tiles/{z}/{x}/{y}/assets</code></li> <li>update minimum titiler requirement to <code>&gt;=0.11.6</code></li> <li>remove timing headers</li> <li>add <code>strict_zoom</code> option (controled with <code>MOSAIC_STRICT_ZOOM</code> environment variable) to raise (or not) error when fetching tile outside mosaic min/max zoom range</li> </ul>"},{"location":"release-notes/#033-2023-04-27","title":"0.3.3 (2023-04-27)","text":"<ul> <li>update python packaging/build system to <code>pdm-pep517</code></li> <li>use <code>Ruff</code> for lint</li> <li>add retry mechanism on Database connection issues for <code>PGSTACBackend.get_assets()</code> and <code>get_stac_item</code> methods (back ported from 0.2.4)</li> </ul>"},{"location":"release-notes/#032-2023-03-14","title":"0.3.2 (2023-03-14)","text":"<ul> <li>update titiler requirement to <code>0.10.2</code></li> <li>fix maximum version of FastAPI to 0.92 (to avoid breaking change of starlette &gt;0.25)</li> </ul>"},{"location":"release-notes/#031-2022-12-16","title":"0.3.1 (2022-12-16)","text":"<ul> <li>update Type information for <code>dependencies.get_stac_item</code> (back ported from 0.2.2)</li> </ul>"},{"location":"release-notes/#030-2022-12-16","title":"0.3.0 (2022-12-16)","text":"<p>breaking changes</p> <ul> <li> <p>Use <code>/collections/{collection_id}/items/{item_id}</code> prefix for Item endpoint.     <pre><code># Before\n{endpoint}/stac/info?collection=collection1&amp;item=item1\n\n# Now\n{endpoint}/collections/collection1/items/item1/info\n</code></pre></p> </li> <li> <p>Change tile url path parameter order from <code>/tiles/{searchid}/{TileMatrixSetId}/{z}/{x}/{y}</code> to <code>/{searchid}/tiles/{TileMatrixSetId}/{z}/{x}/{y}</code> <pre><code># Before\n{endpoint}/mosaic/tiles/20200307aC0853900w361030/0/0/0\n\n# Now\n{endpoint}/mosaic/20200307aC0853900w361030/tiles/0/0/0\n</code></pre></p> </li> </ul>"},{"location":"release-notes/#024-2023-04-27","title":"0.2.4 (2023-04-27)","text":"<ul> <li>add retry mechanism on Database connection issues for <code>PGSTACBackend.get_assets()</code> and <code>get_stac_item</code> methods</li> </ul>"},{"location":"release-notes/#023-2023-03-14","title":"0.2.3 (2023-03-14)","text":"<ul> <li>fix maximum version of FastAPI to 0.92 (to avoid breaking change of starlette &gt;0.25)</li> </ul>"},{"location":"release-notes/#022-2022-12-16","title":"0.2.2 (2022-12-16)","text":"<ul> <li>update Type information for <code>dependencies.get_stac_item</code></li> </ul>"},{"location":"release-notes/#021-2022-12-15","title":"0.2.1 (2022-12-15)","text":"<ul> <li>update titiler requirement to <code>&gt;=0.10.1,&lt;0.11</code> and fix <code>/map</code> endpoint (to accept multiple TMS)</li> </ul>"},{"location":"release-notes/#020-2022-12-13","title":"0.2.0 (2022-12-13)","text":"<ul> <li>add python 3.10 and 3.11 support</li> <li>update to rio-tiler 4.1</li> <li>add <code>/{searchid}/map</code> endpoint to the <code>MosaicTilerFactory</code> (added when <code>add_map_viewer</code> is set to <code>True</code>)</li> <li>add <code>/{searchid}/WMTSCapabilities.xml</code> OGC WMTS endpoint to the <code>MosaicTilerFactory</code></li> <li>add <code>/list</code> to the <code>MosaicTilerFactory</code> to list available mosaics (added when <code>add_mosaic_list</code> is set to <code>True</code>)</li> </ul> <p>breaking changes</p> <ul> <li>remove python 3.7 support</li> <li>update titiler requirement to <code>&gt;=0.10.0</code></li> <li>replace <code>connection_string</code> by <code>database_url</code> in <code>settings.PostgresSettings</code>. We can now directly set <code>DATABASE_URL</code> environment variable.</li> </ul>"},{"location":"release-notes/#frontend-changes","title":"Frontend changes","text":"<ul> <li>remove <code>asset_expression</code> (Mosaic and Item)</li> <li>histogram band names are prefixed with <code>b</code> (e.g <code>b1</code>) (Mosaic and Item) (ref: github.com/cogeotiff/rio-tiler/blob/main/docs/src/v4_migration.md#band-names)</li> <li>expression for STAC have to be in form of <code>{asset}_b{band_name}</code> (e.g <code>red_b1/green_b1</code>) (Mosaic and Item) (ref: github.com/cogeotiff/rio-tiler/blob/main/docs/src/v4_migration.md#multibasereader-expressions)</li> <li>added <code>asset_as_band</code> option to force expression to be in form of <code>{asset}</code> (e.g <code>red/green</code>) (Mosaic and Item)</li> <li>expression's band should now be delimited with <code>;</code> (previously <code>,</code> was accepted) (Mosaic and Item)</li> <li>point output model to include band_names (Item)</li> <li>added <code>algorithm</code> options</li> </ul>"},{"location":"release-notes/#010-2022-06-27","title":"0.1.0 (2022-06-27)","text":"<ul> <li>update <code>titiler.core</code> and <code>titiler.mosaic</code> requirement to <code>0.7</code></li> <li>add <code>MosaicTilerFactory._tilejson_routes</code> method to register <code>TileJSON</code> routes</li> <li>raise <code>cogeo_mosaic.errors.MosaicNotFoundError</code> when SearchId is not found in pgstac.searches table</li> </ul> <p>breaking changes</p> <ul> <li>move version definition in <code>titiler.pgstac.__version__</code></li> <li>remove unused <code>fetch_options</code> in <code>titiler.pgstac.reader.PgSTACReader</code></li> </ul>"},{"location":"release-notes/#010a10-2022-05-16-pre-release","title":"0.1.0a10 (2022-05-16) Pre-Release","text":"<ul> <li>update <code>titiler</code> version and add <code>reader_dependency</code> and <code>backend_dependency</code> in endpoint factory.</li> </ul>"},{"location":"release-notes/#010a9-2022-05-05-pre-release","title":"0.1.0.a9 (2022-05-05) Pre-Release","text":"<ul> <li>remove LRU cache on all settings classes to enable support for manually providing settings via keyword arguments and to minimize lines of code (author @alukach, stac-utils/titiler-pgstac!54)</li> </ul>"},{"location":"release-notes/#010a8-2022-05-02-pre-release","title":"0.1.0.a8 (2022-05-02) Pre-Release","text":"<ul> <li>Insert mosaic metadata <code>min/max zoom</code> and <code>bounds</code> in tilejson (stac-utils/titiler-pgstac!51)</li> <li>allow users the ability to optionally provide <code>PostgresSettings</code> to <code>connect_to_db()</code> function in the event that they want to customize how their DB credentials are populated (author @alukach, stac-utils/titiler-pgstac!53)</li> </ul>"},{"location":"release-notes/#010a7-2022-04-05-pre-release","title":"0.1.0.a7 (2022-04-05) Pre-Release","text":"<ul> <li>add <code>feature()</code> method to <code>PGSTACBackend</code> mosaic backend</li> <li>add <code>/statistics</code> endpoint to return statistics given a GeoJSON feature or featureCollection</li> <li>add <code>collection</code> in allowed returned fields</li> <li>switch to <code>pgstac.search</code> to get the STAC Item in <code>titiler.pgstac.dependencies.get_stac_item</code> (stac-utils/titiler-pgstac!50)</li> </ul>"},{"location":"release-notes/#010a6-2022-03-14-pre-release","title":"0.1.0.a6 (2022-03-14) Pre-Release","text":"<ul> <li>move dependencies to <code>titiler.pgstac.dependencies</code></li> <li>add <code>/stac</code> endpoints to work with PgSTAC items</li> </ul> <p>breaking changes</p> <ul> <li>add <code>/mosaic</code> prefix to the PgSTAC mosaic endpoints</li> </ul>"},{"location":"release-notes/#010a5-2022-03-03-pre-release","title":"0.1.0.a5 (2022-03-03) Pre-Release","text":"<ul> <li>Add <code>search_dependency</code> to allow customization of the PgSTAC Search query (Author @drnextgis, stac-utils/titiler-pgstac!41)</li> <li>Add PgSTAC Search entries model (stac-utils/titiler-pgstac!43)</li> <li>Add <code>Metadata</code> specification (stac-utils/titiler-pgstac!38)</li> </ul> <p>breaking changes</p> <ul> <li>update <code>titiler.core</code> and <code>titiler.mosaic</code> requirement to <code>&gt;=0.5</code></li> <li>When registering a <code>search</code> to PgSTAC with the <code>/register</code> endpoint, a default metadata <code>{\"type\": \"mosaic\"}</code> will be set.</li> <li>Renamed <code>titiler.pgstac.models</code> to <code>titiler.pgstac.model</code></li> <li>Renamed <code>titiler.pgstac.models.SearchQuery</code> to <code>titiler.pgstac.model.PgSTACSearch</code> (and removed <code>metadata</code>)</li> <li> <p>output response for <code>/register</code> endpoint: <pre><code>// before\n{\n    \"searchid\": \"...\",\n    \"metadata\": \"http://endpoint/.../info\",\n    \"tiles\": \"http://endpoint/.../tilejson.json\",\n}\n\n// now\n{\n    \"searchid\": \"...\",\n    \"links\": [\n        {\n            \"rel\": \"info\",\n            \"href\": \"http://endpoint/.../info\",\n            \"type\": \"application/json\",\n        },\n        {\n            \"rel\": \"tilejson\",\n            \"href\": \"http://endpoint/.../tilejson.json\",\n            \"type\": \"application/json\",\n        }\n    ]\n}\n</code></pre></p> </li> <li> <p>output response for <code>/info</code> endpoint: <pre><code>// before\n{\n    \"hash\": \"...\",\n    \"search\": {},\n    \"_where\": \"...\",\n    ...\n}\n\n// now\n{\n    \"search\": {\n        \"hash\": \"...\",\n        \"search\": {},\n        \"_where\": \"...\",\n        ...\n    },\n    \"links\": [\n        {\n            \"rel\": \"self\",\n            \"href\": \"http://endpoint/.../info\",\n            \"type\": \"application/json\",\n        },\n        {\n            \"rel\": \"tilejson\",\n            \"href\": \"http://endpoint/.../tilejson.json\",\n            \"type\": \"application/json\",\n        }\n    ]\n}\n</code></pre></p> </li> </ul>"},{"location":"release-notes/#010a4-2022-02-07-pre-release","title":"0.1.0.a4 (2022-02-07) Pre-Release","text":"<ul> <li>add tile <code>buffer</code> option to match rio-tiler tile options (stac-utils/titiler-pgstac!31)</li> </ul>"},{"location":"release-notes/#010a3-2021-12-15-pre-release","title":"0.1.0.a3 (2021-12-15) Pre-Release","text":"<ul> <li>Forward TMS to the STAC Reader (allow multiple TMS) (stac-utils/titiler-pgstac!28)</li> </ul>"},{"location":"release-notes/#010a2-2021-12-13-pre-release","title":"0.1.0.a2 (2021-12-13) Pre-Release","text":"<ul> <li>Switch to psycopg3</li> <li>add <code>filter-lang</code> in Search model to support newer PgSTAC (with CQL-2)</li> <li>add <code>metadata</code> in Search model to allow forwarding metadata to the search query entry in PgSTAC</li> </ul> <p>breaking changes</p> <ul> <li>Unify reader/writer db pools to <code>request.app.state.dbpool</code></li> <li>rename <code>PostgresSettings.db_max_inactive_conn_lifetime</code> to <code>PostgresSettings.max_idle</code></li> <li>remove <code>PostgresSettings().reader_connection_string</code> and <code>PostgresSettings().writer_connection_string</code>. Replaced with <code>PostgresSettings().connection_string</code></li> <li>update titiler requirement (&gt;= 0.4)</li> </ul>"},{"location":"release-notes/#010a1-2021-09-15-pre-release","title":"0.1.0.a1 (2021-09-15) Pre-Release","text":"<ul> <li>Surface PgSTAC options (<code>scan_limit</code>, <code>items_limit</code>, <code>time_limit</code>, <code>exitwhenfull</code> and <code>skipcovered</code>) in Tile endpoints</li> </ul> <p>breaking changes</p> <ul> <li>remove <code>psycopg2</code> requirements to avoid conflict with <code>psycopg2-binary</code> (stac-utils/titiler-pgstac!15)</li> </ul>"},{"location":"release-notes/#010a0-2021-09-06-pre-release","title":"0.1.0.a0 (2021-09-06) Pre-Release","text":"<p>Initial release</p>"},{"location":"tiler_factories/","title":"Tiler Factories","text":"<p><code>TiTiler.PgSTAC</code> provides a <code>MosaicTilerFactory</code> factory which is an helper functions to create FastAPI router (<code>fastapi.APIRouter</code>) with a minimal set of endpoints.</p>"},{"location":"tiler_factories/#titilerpgstacfactorymosaictilerfactory","title":"<code>titiler.pgstac.factory.MosaicTilerFactory</code>","text":"<pre><code># Minimal PgSTAC Mosaic Application\nfrom contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI\nfrom titiler.pgstac.db import close_db_connection, connect_to_db\nfrom titiler.pgstac.factory import MosaicTilerFactory\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"FastAPI Lifespan.\"\"\"\n    # Create Connection Pool\n    await connect_to_db(app)\n    yield\n    # Close the Connection Pool\n    await close_db_connection(app)\n\n\napp = FastAPI(lifespan=lifespan)\n\nmosaic = MosaicTilerFactory()\napp.include_router(mosaic.router)\n</code></pre> Method URL Output Description <code>POST</code> <code>/register</code> JSON (Register) Register Search query  OPTIONAL <code>GET</code> <code>/list</code> JSON (Info) Return Search query infos  OPTIONAL <code>GET</code> <code>/{searchid}/info</code> JSON (Infos) Return list of Search entries with <code>Mosaic</code> type  OPTIONAL <code>GET</code> <code>/{searchid}/{lon},{lat}/assets</code> JSON Return a list of assets which overlap a given point <code>GET</code> <code>/{searchid}/tiles[/{TileMatrixSetId}]/{z}/{x}/{Y}/assets</code> JSON Return a list of assets which overlap a given tile <code>GET</code> <code>/{searchid}/tiles[/{TileMatrixSetId}]/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin Create a web map tile image for a search query and a tile index <code>GET</code> <code>/{searchid}[/{TileMatrixSetId}]/tilejson.json</code> JSON (TileJSON) Return a Mapbox TileJSON document <code>GET</code> <code>/{searchid}[/{TileMatrixSetId}]/WMTSCapabilities.xml</code> XML Return OGC WMTS Get Capabilities <code>GET</code> <code>/{searchid}[/{TileMatrixSetId}]/map</code> HTML Simple map viewer OPTIONAL <code>POST</code> <code>/{searchid}/statistics</code> GeoJSON (Statistics) Return statistics for geojson features OPTIONAL <code>GET</code> <code>/{searchid}/bbox/{minx},{miny},{maxx},{maxy}[/{width}x{height}].{format}</code> image/bin Create an image from part of a dataset OPTIONAL <code>POST</code> <code>/{searchid}/feature[/{width}x{height}][.{format}]</code> image/bin Create an image from a GeoJSON feature OPTIONAL"},{"location":"tiler_factories/#item","title":"Item","text":"<p>For the <code>single STAC item</code> endpoints we use TiTiler's <code>MultiBaseTilerFactory</code> with a custom <code>path_dependency</code> to use <code>item</code> and <code>collection</code> path parameter (instead of the default <code>url</code> query param).</p> <p>This custom <code>path_dependency</code> will connect to PgSTAC directly to fetch the STAC Item and pass it to a custom Reader based on <code>rio_tiler.io.MultiBaseReader</code>.</p> <pre><code># Minimal PgSTAC Item Application\nfrom contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI\n\nfrom titiler.core.factory import MultiBaseTilerFactory\n\nfrom titiler.pgstac.db import close_db_connection, connect_to_db\nfrom titiler.pgstac.dependencies import ItemPathParams\nfrom titiler.pgstac.reader import PgSTACReader\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"FastAPI Lifespan.\"\"\"\n    # Create Connection Pool\n    await connect_to_db(app)\n    yield\n    # Close the Connection Pool\n    await close_db_connection(app)\n\n\napp = FastAPI(lifespan=lifespan)\n\nitem = MultiBaseTilerFactory(\n    reader=PgSTACReader,\n    path_dependency=ItemPathParams,\n    router_prefix=\"/collections/{collection_id}/items/{item_id}\",\n)\napp.include_router(item.router, prefix=\"/collections/{collection_id}/items/{item_id}\")\n</code></pre>"},{"location":"tms_endpoints/","title":"TileMatrixSet","text":"Method URL Output Description <code>GET</code> <code>/tileMatrixSets</code> JSON (TMS list) return the list of supported TileMatrixSet <code>GET</code> <code>/tileMatrixSets/{TileMatrixSetId}</code> JSON (TileMatrixSet) return the TileMatrixSet JSON document"},{"location":"tms_endpoints/#list-tms","title":"List TMS","text":"<p><code>:endpoint:/tileMatrixSets</code> - Get the list of supported TileMatrixSet</p> <pre><code>curl https://myendpoint/tileMatrixSets | jq\n&gt;&gt; {\n  \"tileMatrixSets\": [\n    {\n      \"id\": \"LINZAntarticaMapTilegrid\",\n      \"title\": \"LINZ Antarctic Map Tile Grid (Ross Sea Region)\",\n      \"links\": [\n        {\n          \"href\": \"https://myendpoint/tileMatrixSets/LINZAntarticaMapTilegrid\",\n          \"rel\": \"item\",\n          \"type\": \"application/json\"\n        }\n      ]\n    },\n    ...\n  ]\n}\n</code></pre>"},{"location":"tms_endpoints/#get-tms-info","title":"Get TMS info","text":"<p><code>:endpoint:/tileMatrixSets/{TileMatrixSetId}</code> - Get the TileMatrixSet JSON document</p> <ul> <li>PathParams:<ul> <li>TileMatrixSetId: TileMatrixSet name</li> </ul> </li> </ul> <pre><code>curl http://127.0.0.1:8000/tileMatrixSets/WebMercatorQuad | jq\n&gt;&gt; {\n  \"type\": \"TileMatrixSetType\",\n  \"title\": \"Google Maps Compatible for the World\",\n  \"identifier\": \"WebMercatorQuad\",\n  \"supportedCRS\": \"http://www.opengis.net/def/crs/EPSG/0/3857\",\n  \"wellKnownScaleSet\": \"http://www.opengis.net/def/wkss/OGC/1.0/GoogleMapsCompatible\",\n  \"boundingBox\": {\n    \"type\": \"BoundingBoxType\",\n    \"crs\": \"http://www.opengis.net/def/crs/EPSG/0/3857\",\n    \"lowerCorner\": [\n      -20037508.3427892,\n      -20037508.3427892\n    ],\n    \"upperCorner\": [\n      20037508.3427892,\n      20037508.3427892\n    ]\n  },\n  \"tileMatrix\": [\n    {\n      \"type\": \"TileMatrixType\",\n      \"identifier\": \"0\",\n      \"scaleDenominator\": 559082264.028717,\n      \"topLeftCorner\": [\n        -20037508.3427892,\n        20037508.3427892\n      ],\n      \"tileWidth\": 256,\n      \"tileHeight\": 256,\n      \"matrixWidth\": 1,\n      \"matrixHeight\": 1\n    },\n    ...\n</code></pre>"},{"location":"advanced/custom_search/","title":"Custom search model","text":"<p>Even though <code>TiTiler.PgSTAC</code> includes default FastAPI application, it also can be used like a library if you want to extend or override default behavior.</p> <p>Let's look at one such example. Imagine that we use JSON Web Token (JWT) based approach for authorization and every token contains information about area a user has access to:</p> <pre><code>{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"iat\": 1516239022,\n  \"scope\": \"zone_A\"\n}\n</code></pre> <p>We want our application to take this information into account while registering a search query. It can be done in the following way:</p> <pre><code>from contextlib import asynccontextmanager\n\nfrom typing import Tuple\nimport json\nimport jwt\nfrom fastapi import FastAPI\nfrom fastapi.security.utils import get_authorization_scheme_param\nfrom starlette.requests import Request\nfrom titiler.pgstac.factory import MosaicTilerFactory\nfrom titiler.pgstac.model import RegisterMosaic, Metadata, PgSTACSearch\nfrom titiler.pgstac.db import close_db_connection, connect_to_db\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"FastAPI Lifespan.\"\"\"\n    # Create Connection Pool\n    await connect_to_db(app, settings=postgres_settings)\n    yield\n    # Close the Connection Pool\n    await close_db_connection(app)\n\napp = FastAPI(lifespan=lifespan)\n\nAREAS = {\n    \"zone_A\": {\"type\": \"Point\", \"coordinates\": [-41.93, -12.76]},\n    \"zone_B\": {\"type\": \"Point\", \"coordinates\": [2.15, 41.39]},\n}\n\n\ndef search_factory(request: Request, body: RegisterMosaic) -&gt; Tuple[PgSTACSearch, Metadata]:\n    authorization = request.headers.get(\"Authorization\")\n    scheme, token = get_authorization_scheme_param(authorization)\n    payload = jwt.decode(token, algorithms=[\"HS256\"], key=\"your-256-bit-secret\")\n\n    search = body.dict(exclude_none=True, exclude={\"metadata\"}, by_alias=True)\n    search[\"filter\"] = {\n        \"op\": \"and\",\n        \"args\": [\n            {\n                \"op\": \"s_intersects\",\n                \"args\": [{\"property\": \"geometry\"}, AREAS[payload[\"scope\"]]],\n            },\n            search[\"filter\"],\n        ],\n    }\n\n    return model.PgSTACSearch(**search), body.metadata\n\n\nmosaic = MosaicTilerFactory(search_dependency=search_factory)\napp.include_router(mosaic.router)\n</code></pre> <p>Checking:</p> <pre><code>$ curl -s -X 'POST' \\\n  'http://localhost:8081/register' \\\n  -H 'accept: application/json' \\\n  -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJzY29wZSI6InpvbmVfQSJ9.BelzluX7v7kYObix2KSyy1T5gEOQYQn_pyNO5Ri0gWo' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"filter\":{\"op\":\"and\",\"args\":[{\"op\":\"=\",\"args\":[{\"property\":\"collection\"},\"l1\"]}]}}' | jq '.searchid'\n\"bbc3c8f4c392436f74de6cd0308469f6\"\n\n$ curl -X 'GET' \\\n  'http://localhost:8081/bbc3c8f4c392436f74de6cd0308469f6/info' \\\n  -H 'accept: application/json'\n{\"hash\":\"bbc3c8f4c392436f74de6cd0308469f6\",\"search\":{\"filter\":{\"op\":\"and\",\"args\":[{\"op\":\"s_intersects\",\"args\":[{\"property\":\"geometry\"},{\"type\":\"Point\",\"coordinates\":[-41.93,-12.76]}]},{\"op\":\"and\",\"args\":[{\"op\":\"=\",\"args\":[{\"property\":\"collection\"},\"l1\"]}]}]}},\"_where\":\"(  ( st_intersects(geometry, '0101000020E6100000D7A3703D0AF744C085EB51B81E8529C0'::geometry) and  ( (collection_id = 'l1') )  )  )  \",\"orderby\":\"datetime DESC, id DESC\",\"lastused\":\"2022-02-23T13:00:04.090757+00:00\",\"usecount\":3,\"metadata\":{\"type\":\"mosaic\"}}\n</code></pre>"},{"location":"advanced/custom_tilejson/","title":"Custom TileJSON endpoint","text":"<p>Goal: enable users to select a predefined configuration stored in the mosaic Metadata.</p> <pre><code>import sys\nfrom typing import Optional\nfrom dataclasses import dataclass\n\nfrom morecantile import TileMatrixSet\nfrom titiler.core.resources.enums import ImageType\nfrom titiler.core.models.mapbox import TileJSON\nfrom titiler.pgstac import factory as TitilerPgSTACFactory\nfrom titiler.pgstac.dependencies import PgSTACParams\n\nfrom fastapi import Depends, Query\n\nfrom starlette.requests import Request\n\nif sys.version_info &gt;= (3, 9):\n    from typing import Annotated  # pylint: disable=no-name-in-module\nelse:\n    from typing_extensions import Annotated\n\n\n@dataclass\nclass MosaicTilerFactory(TitilerPgSTACFactory.MosaicTilerFactory):\n    \"\"\"Custom factory.\"\"\"\n\n    def _tilejson_routes(self) -&gt; None:\n        \"\"\"Custom TileJSON endpoint.\"\"\"\n\n        @self.router.get(\n            \"/{searchid}/tilejson.json\",\n            response_model=TileJSON,\n            responses={200: {\"description\": \"Return a tilejson\"}},\n            response_model_exclude_none=True,\n        )\n        @self.router.get(\n            \"/{searchid}/{tileMatrixSetId}/tilejson.json\",\n            response_model=TileJSON,\n            responses={200: {\"description\": \"Return a tilejson\"}},\n            response_model_exclude_none=True,\n        )\n        def tilejson(\n            request: Request,\n            searchid=Depends(self.path_dependency),\n            tileMatrixSetId: Annotated[  # type: ignore\n                Literal[tuple(self.supported_tms.list())],\n                f\"Identifier selecting one of the TileMatrixSetId supported (default: '{self.default_tms}')\",\n            ] = self.default_tms,\n            layer: Annotated[\n                str,\n                Query(description=\"Name of default configuration\"),\n            ] = None,\n            tile_format: Annotated[\n                Optional[ImageType],\n                Query(\n                    description=\"Default will be automatically defined if the output image needs a mask (png) or not (jpeg).\",\n                ),\n            ] = None,\n            tile_scale: Annotated[\n                Optional[int],\n                Query(\n                    gt=0, lt=4, description=\"Tile size scale. 1=256x256, 2=512x512...\"\n                ),\n            ] = None,\n            minzoom: Annotated[\n                Optional[int],\n                Query(description=\"Overwrite default minzoom.\"),\n            ] = None,\n            maxzoom: Annotated[\n                Optional[int],\n                Query(description=\"Overwrite default maxzoom.\"),\n            ] = None,\n            layer_params=Depends(self.layer_dependency),\n            dataset_params=Depends(self.dataset_dependency),\n            pixel_selection=Depends(self.pixel_selection_dependency),\n            buffer: Annotated[\n                Optional[float],\n                Query(\n                    gt=0,\n                    title=\"Tile buffer.\",\n                    description=\"Buffer on each side of the given tile. It must be a multiple of `0.5`. Output **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257, 1.0 = 258x258).\",\n                ),\n            ] = None,\n            post_process=Depends(self.process_dependency),\n            rescale=Depends(self.rescale_dependency),\n            color_formula: Annotated[\n                Optional[str],\n                Query(\n                    title=\"Color Formula\",\n                    description=\"rio-color formula (info: https://github.com/mapbox/rio-color)\",\n                ),\n            ] = None,\n            colormap=Depends(self.colormap_dependency),\n            render_params=Depends(self.render_dependency),\n            pgstac_params: PgSTACParams = Depends(),\n            backend_params=Depends(self.backend_dependency),\n            reader_params=Depends(self.reader_dependency),\n        ):\n            \"\"\"Return TileJSON document for a SearchId.\"\"\"\n            with request.app.state.dbpool.connection() as conn:\n                with conn.cursor(row_factory=class_row(model.Search)) as cursor:\n                    cursor.execute(\n                        \"SELECT * FROM searches WHERE hash=%s;\",\n                        (searchid,),\n                    )\n                    search_info = cursor.fetchone()\n                    if not search_info:\n                        raise KeyError(f\"search {searchid} not found\")\n\n            route_params = {\n                \"searchid\": search_info.id,\n                \"z\": \"{z}\",\n                \"x\": \"{x}\",\n                \"y\": \"{y}\",\n                \"tileMatrixSetId\": tileMatrixSetId,\n            }\n            if tile_scale:\n                route_params[\"scale\"] = tile_scale\n            if tile_format:\n                route_params[\"format\"] = tile_format.value\n\n            tiles_url = self.url_for(request, \"tile\", **route_params)\n\n            qs_key_to_remove = [\n                \"tilematrixsetid\",\n                \"tile_format\",\n                \"tile_scale\",\n                \"minzoom\",\n                \"maxzoom\",\n                \"layer\",\n            ]\n            qs = [\n                (key, value)\n                for (key, value) in request.query_params._list\n                if key.lower() not in qs_key_to_remove\n            ]\n\n            if layer:\n                config = search_info.defaults.get(layer)\n                if not config:\n                    raise HTTPException(status_code=404, detail=f\"Invalid {layer} configuration.\")\n\n                # This assume the default configuration follows the endpoint expected format\n                # as `\"true_color\": [(\"assets\", \"B4\"), (\"assets\", \"B3\"), (\"assets\", \"B2\")]`\n                qs = QueryParams(config)\n\n            if qs:\n                tiles_url += f\"?{urlencode(qs)}\"\n\n            minzoom = _first_value([minzoom, search_info.metadata.minzoom], tms.minzoom)\n            maxzoom = _first_value([maxzoom, search_info.metadata.maxzoom], tms.maxzoom)\n            bounds = _first_value(\n                [search_info.input_search.get(\"bbox\"), search_info.metadata.bounds],\n                tms.bbox,\n            )\n            return {\n                \"bounds\": bounds,\n                \"minzoom\": minzoom,\n                \"maxzoom\": maxzoom,\n                \"name\": search_info.metadata.name or search_info.id,\n                \"tiles\": [tiles_url],\n            }\n</code></pre>"},{"location":"advanced/metadata/","title":"Mosaic metadata specification","text":"<p><code>TiTiler-PgSTAC</code> uses PgSTAC search to host mosaic parameters for performance purposes. To help users we added the possibility to add <code>metadata</code> to search entries and in <code>TiTiler-PgSTAC</code> we introduced a <code>non-official</code> specification to help user storing meaningful informations.</p>"},{"location":"advanced/metadata/#specification","title":"Specification","text":"<pre><code>{\n    // OPTIONAL. Default: \"mosaic\" (No other value accepted for now). Describe the `type` of metadata.\n    \"type\": \"mosaic\",\n\n    // OPTIONAL. Default: null.\n    // The maximum extent of available map tiles. The bounds are represented in WGS:84\n    // latitude and longitude values, in the order left, bottom, right, top.\n    // Values may be integers or floating point numbers.\n    \"bounds\": [ -180, -85.05112877980659, 180, 85.0511287798066 ],\n\n    // OPTIONAL. Default: null.\n    // An integer specifying the minimum zoom level.\n    \"minzoom\": 0,\n\n    // OPTIONAL. Default: null.\n    // An integer specifying the maximum zoom level. MUST be &gt;= minzoom.\n    \"maxzoom\": 11,\n\n    // OPTIONAL. Default: null. The name can contain any legal character.\n    \"name\": \"compositing\",\n\n    // OPTIONAL. Default: null. An array of available assets.\n    \"assets\": [\"image\", \"cog\"],\n\n    // OPTIONAL. Default: null. A set of `defaults` configuration to be forwarded to the /tiles endpoints.\n    \"defaults\": {\n        \"true_color\": {\n            \"assets\": [\"B4\", \"B3\", \"B2\"],\n            \"color_formula\": \"Gamma RGB 3.5 Saturation 1.7 Sigmoidal RGB 15 0.35\",\n        },\n        \"ndvi\": {\n            \"expression\": \"(B4-B3)/(B4+B3)\",\n            \"rescale\": \"-1,1\",\n            \"colormap_name\": \"viridis\"\n        }\n    }\n}\n</code></pre> <p>Important</p> <ul> <li>When using the <code>/mosaic/register</code> endpoint, <code>{\"type\": \"mosaic\"}</code> will be set by default</li> <li>All metadata fields are optional and custom fields are also allowed.</li> </ul> <pre><code>curl -X 'POST' 'http://127.0.0.1:8081/mosaic/register' -H 'accept: application/json' -H 'Content-Type: application/json' -d '{\"filter\": {\"op\": \"=\", \"args\": [{\"property\": \"collection\"}, \"landsat-c2l2-sr\"]}, \"metadata\": {\"name\": \"landsat mosaic\"}}'\n&gt;&gt; {\n  \"searchid\": \"d7fcdefd0457c949ea7a6192bc2c7122\",\n  \"links\": [\n    {\n      \"rel\": \"metadata\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/d7fcdefd0457c949ea7a6192bc2c7122/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/d7fcdefd0457c949ea7a6192bc2c7122/tilejson.json\"\n    }\n  ]\n}\n\ncurl http://127.0.0.1:8081/mosaic/d7fcdefd0457c949ea7a6192bc2c7122/info | jq '.search.metadata'\n&gt;&gt; {\n  \"type\": \"mosaic\",\n  \"name\": \"landsat mosaic\"\n}\n</code></pre> <pre><code>curl -X 'POST' 'http://127.0.0.1:8081/mosaic/register' -H 'accept: application/json' -H 'Content-Type: application/json' -d '{\"collections\": [\"noaa-emergency-response\"], \"bbox\": [-87.0251, 36.0999, -85.4249, 36.2251], \"filter-lang\": \"cql-json\", \"metadata\": {\"bounds\": [-87.0251, 36.0999, -85.4249, 36.2251], \"minzoom\": 14, \"maxzoom\": 18, \"assets\": [\"cog\"], \"defaults\": {\"true_color\": {\"bidx\": [1, 2, 3]}}}}'\n&gt;&gt; {\n  \"searchid\":\"4b0db3dbd1858d54a3a55f84de97d1ca\",\n  \"links\":[\n    {\n      \"rel\": \"metadata\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/4b0db3dbd1858d54a3a55f84de97d1ca/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/4b0db3dbd1858d54a3a55f84de97d1ca/tilejson.json\"\n    }\n  ]\n}\n\ncurl http://127.0.0.1:8081/mosaic/4b0db3dbd1858d54a3a55f84de97d1ca/info | jq '.search.metadata'\n&gt;&gt; {\n  \"type\": \"mosaic\",\n  \"bounds\": [\n    -87.0251,\n    36.0999,\n    -85.4249,\n    36.2251\n  ],\n  \"minzoom\": 14,\n  \"maxzoom\": 18,\n  \"assets\": [\n    \"cog\"\n  ],\n  \"defaults\": {\n    \"true_color\": {\n      \"bidx\": [\n        1,\n        2,\n        3\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"advanced/mosaic_list/","title":"Mosaic list","text":"<p>Starting with <code>titiler-pgstac&gt;=0.2.0</code>, we've added a <code>/mosaic/list</code> endpoint to be able to list all registered mosaics. When we add a mosaic via <code>/mosaic/register</code> we add a specific <code>metadata.type: \"mosaic\"</code> to the pgstac <code>search</code> entry, which is then used by the <code>/mosaic/list</code> endpoint to filter the pgstac <code>searches</code>.</p> <p>In order to make the mosaic list performant, users might want to alter their PgSTAC database to add an index</p> <pre><code>$ psql\npostgis=# SET schema 'pgstac';\n&gt;&gt; SET\n\npostgis=# CREATE INDEX IF NOT EXISTS searches_mosaic ON searches ((true)) WHERE metadata-&gt;&gt;'type'='mosaic';\n&gt;&gt; NOTICE:  relation \"searches_mosaic\" already exists, skipping\n&gt;&gt; CREATE INDEX\n\npostgis=# SELECT\n    indexname,\n    indexdef\nFROM\n    pg_indexes\nWHERE\n    tablename = 'searches';\n\n&gt;&gt;     indexname    |                                                         indexdef\n&gt;&gt; -----------------+---------------------------------------------------------------------------------------------------------------------------\n&gt;&gt;  searches_pkey   | CREATE UNIQUE INDEX searches_pkey ON pgstac.searches USING btree (hash)\n&gt;&gt;  searches_mosaic | CREATE INDEX searches_mosaic ON pgstac.searches USING btree ((true)) WHERE ((metadata -&gt;&gt; 'type'::text) = 'mosaic'::text)\n</code></pre> <p>ref: github.com/developmentseed/eoAPI/blob/master/stack/handlers/db_handler.py#L204-L213</p>"},{"location":"api/titiler/pgstac/db/","title":"Module titiler.pgstac.db","text":"<p>Database connection handling.</p> <p>None</p>"},{"location":"api/titiler/pgstac/db/#functions","title":"Functions","text":""},{"location":"api/titiler/pgstac/db/#close_db_connection","title":"close_db_connection","text":"<pre><code>def close_db_connection(\n    app: fastapi.applications.FastAPI\n) -&gt; None\n</code></pre> <p>Close Pool.</p>"},{"location":"api/titiler/pgstac/db/#connect_to_db","title":"connect_to_db","text":"<pre><code>def connect_to_db(\n    app: fastapi.applications.FastAPI,\n    settings: Optional[titiler.pgstac.settings.PostgresSettings] = None\n) -&gt; None\n</code></pre> <p>Connect to Database.</p>"},{"location":"api/titiler/pgstac/dependencies/","title":"Module titiler.pgstac.dependencies","text":"<p>titiler-pgstac dependencies.</p> <p>None</p>"},{"location":"api/titiler/pgstac/dependencies/#variables","title":"Variables","text":"<pre><code>cache_config\n</code></pre> <pre><code>retry_config\n</code></pre>"},{"location":"api/titiler/pgstac/dependencies/#functions","title":"Functions","text":""},{"location":"api/titiler/pgstac/dependencies/#itempathparams","title":"ItemPathParams","text":"<pre><code>def ItemPathParams(\n    request: starlette.requests.Request,\n    collection_id: typing.Annotated[str, Path(PydanticUndefined)],\n    item_id: typing.Annotated[str, Path(PydanticUndefined)]\n) -&gt; pystac.item.Item\n</code></pre> <p>STAC Item dependency.</p>"},{"location":"api/titiler/pgstac/dependencies/#pathparams","title":"PathParams","text":"<pre><code>def PathParams(\n    searchid: typing.Annotated[str, Path(PydanticUndefined)]\n) -&gt; str\n</code></pre> <p>SearchId</p>"},{"location":"api/titiler/pgstac/dependencies/#searchparams","title":"SearchParams","text":"<pre><code>def SearchParams(\n    body: titiler.pgstac.model.RegisterMosaic\n) -&gt; Tuple[titiler.pgstac.model.PgSTACSearch, titiler.pgstac.model.Metadata]\n</code></pre> <p>Search parameters.</p>"},{"location":"api/titiler/pgstac/dependencies/#tileparams","title":"TileParams","text":"<pre><code>def TileParams(\n    z: typing.Annotated[int, Path(PydanticUndefined)],\n    x: typing.Annotated[int, Path(PydanticUndefined)],\n    y: typing.Annotated[int, Path(PydanticUndefined)]\n) -&gt; morecantile.commons.Tile\n</code></pre> <p>Tile parameters.</p>"},{"location":"api/titiler/pgstac/dependencies/#classes","title":"Classes","text":""},{"location":"api/titiler/pgstac/dependencies/#backendparams","title":"BackendParams","text":"<pre><code>class BackendParams(\n    request: starlette.requests.Request\n)\n</code></pre>"},{"location":"api/titiler/pgstac/dependencies/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>titiler.core.dependencies.DefaultDependency</li> </ul>"},{"location":"api/titiler/pgstac/dependencies/#methods","title":"Methods","text":""},{"location":"api/titiler/pgstac/dependencies/#keys","title":"keys","text":"<pre><code>def keys(\n    self\n)\n</code></pre> <p>Return Keys.</p>"},{"location":"api/titiler/pgstac/dependencies/#pgstacparams","title":"PgSTACParams","text":"<pre><code>class PgSTACParams(\n    scan_limit: Annotated[Optional[int], Query(PydanticUndefined)] = None,\n    items_limit: Annotated[Optional[int], Query(PydanticUndefined)] = None,\n    time_limit: Annotated[Optional[int], Query(PydanticUndefined)] = None,\n    exitwhenfull: Annotated[Optional[bool], Query(PydanticUndefined)] = None,\n    skipcovered: Annotated[Optional[bool], Query(PydanticUndefined)] = None\n)\n</code></pre>"},{"location":"api/titiler/pgstac/dependencies/#ancestors-in-mro_1","title":"Ancestors (in MRO)","text":"<ul> <li>titiler.core.dependencies.DefaultDependency</li> </ul>"},{"location":"api/titiler/pgstac/dependencies/#class-variables","title":"Class variables","text":"<pre><code>exitwhenfull\n</code></pre> <pre><code>items_limit\n</code></pre> <pre><code>scan_limit\n</code></pre> <pre><code>skipcovered\n</code></pre> <pre><code>time_limit\n</code></pre>"},{"location":"api/titiler/pgstac/dependencies/#methods_1","title":"Methods","text":""},{"location":"api/titiler/pgstac/dependencies/#keys_1","title":"keys","text":"<pre><code>def keys(\n    self\n)\n</code></pre> <p>Return Keys.</p>"},{"location":"api/titiler/pgstac/factory/","title":"Module titiler.pgstac.factory","text":"<p>Custom MosaicTiler Factory for PgSTAC Mosaic Backend.</p> <p>None</p>"},{"location":"api/titiler/pgstac/factory/#variables","title":"Variables","text":"<pre><code>DEFAULT_TEMPLATES\n</code></pre> <pre><code>MAX_THREADS\n</code></pre> <pre><code>MOSAIC_STRICT_ZOOM\n</code></pre> <pre><code>MOSAIC_THREADS\n</code></pre> <pre><code>WGS84_CRS\n</code></pre> <pre><code>img_endpoint_params\n</code></pre>"},{"location":"api/titiler/pgstac/factory/#classes","title":"Classes","text":""},{"location":"api/titiler/pgstac/factory/#mosaictilerfactory","title":"MosaicTilerFactory","text":"<pre><code>class MosaicTilerFactory(\n    reader: Type[cogeo_mosaic.backends.base.BaseBackend] = &lt;class 'titiler.pgstac.mosaic.PGSTACBackend'&gt;,\n    router: fastapi.routing.APIRouter = &lt;factory&gt;,\n    path_dependency: Callable[..., str] = &lt;function PathParams at 0x11d331ee0&gt;,\n    layer_dependency: Type[titiler.core.dependencies.DefaultDependency] = &lt;class 'titiler.core.dependencies.AssetsBidxExprParams'&gt;,\n    dataset_dependency: Type[titiler.core.dependencies.DefaultDependency] = &lt;class 'titiler.core.dependencies.DatasetParams'&gt;,\n    process_dependency: Callable[..., Optional[titiler.core.algorithm.base.BaseAlgorithm]] = &lt;function Algorithms.dependency.&lt;locals&gt;.post_process at 0x12c754a60&gt;,\n    rescale_dependency: Callable[..., Optional[List[Tuple[float, ...]]]] = &lt;function RescalingParams at 0x12c43bf70&gt;,\n    color_formula_dependency: Callable[..., Optional[str]] = &lt;function ColorFormulaParams at 0x12c466160&gt;,\n    colormap_dependency: Callable[..., Union[Dict[int, Tuple[int, int, int, int]], Sequence[Tuple[Tuple[Union[float, int], Union[float, int]], Tuple[int, int, int, int]]], NoneType]] = &lt;function create_colormap_dependency.&lt;locals&gt;.deps at 0x11e28e280&gt;,\n    render_dependency: Type[titiler.core.dependencies.DefaultDependency] = &lt;class 'titiler.core.dependencies.ImageRenderingParams'&gt;,\n    reader_dependency: Type[titiler.core.dependencies.DefaultDependency] = &lt;class 'titiler.core.dependencies.DefaultDependency'&gt;,\n    environment_dependency: Callable[..., Dict] = &lt;function BaseTilerFactory.&lt;lambda&gt; at 0x12c6bdb80&gt;,\n    supported_tms: morecantile.defaults.TileMatrixSets = TileMatrixSets(tms={'CDB1GlobalGrid': PosixPath('/Users/vincentsarago/Dev/DevSeed/morecantile/morecantile/data/CDB1GlobalGrid.json'), 'CanadianNAD83_LCC': PosixPath('/Users/vincentsarago/Dev/DevSeed/morecantile/morecantile/data/CanadianNAD83_LCC.json'), 'EuropeanETRS89_LAEAQuad': PosixPath('/Users/vincentsarago/Dev/DevSeed/morecantile/morecantile/data/EuropeanETRS89_LAEAQuad.json'), 'GNOSISGlobalGrid': PosixPath('/Users/vincentsarago/Dev/DevSeed/morecantile/morecantile/data/GNOSISGlobalGrid.json'), 'LINZAntarticaMapTilegrid': PosixPath('/Users/vincentsarago/Dev/DevSeed/morecantile/morecantile/data/LINZAntarticaMapTilegrid.json'), 'NZTM2000Quad': PosixPath('/Users/vincentsarago/Dev/DevSeed/morecantile/morecantile/data/NZTM2000Quad.json'), 'UPSAntarcticWGS84Quad': PosixPath('/Users/vincentsarago/Dev/DevSeed/morecantile/morecantile/data/UPSAntarcticWGS84Quad.json'), 'UPSArcticWGS84Quad': PosixPath('/Users/vincentsarago/Dev/DevSeed/morecantile/morecantile/data/UPSArcticWGS84Quad.json'), 'UTM31WGS84Quad': PosixPath('/Users/vincentsarago/Dev/DevSeed/morecantile/morecantile/data/UTM31WGS84Quad.json'), 'WGS1984Quad': PosixPath('/Users/vincentsarago/Dev/DevSeed/morecantile/morecantile/data/WGS1984Quad.json'), 'WebMercatorQuad': &lt;TileMatrixSet title='Google Maps Compatible for the World' id='WebMercatorQuad' crs='http://www.opengis.net/def/crs/EPSG/0/3857&gt;, 'WorldCRS84Quad': PosixPath('/Users/vincentsarago/Dev/DevSeed/morecantile/morecantile/data/WorldCRS84Quad.json'), 'WorldMercatorWGS84Quad': PosixPath('/Users/vincentsarago/Dev/DevSeed/morecantile/morecantile/data/WorldMercatorWGS84Quad.json')}),\n    default_tms: str = 'WebMercatorQuad',\n    router_prefix: str = '',\n    optional_headers: List[titiler.core.resources.enums.OptionalHeader] = &lt;factory&gt;,\n    route_dependencies: List[Tuple[List[titiler.core.routing.EndpointScope], List[fastapi.params.Depends]]] = &lt;factory&gt;,\n    extensions: List[titiler.core.factory.FactoryExtension] = &lt;factory&gt;,\n    templates: starlette.templating.Jinja2Templates = &lt;starlette.templating.Jinja2Templates object at 0x12d47ff10&gt;,\n    stats_dependency: Type[titiler.core.dependencies.DefaultDependency] = &lt;class 'titiler.core.dependencies.StatisticsParams'&gt;,\n    histogram_dependency: Type[titiler.core.dependencies.DefaultDependency] = &lt;class 'titiler.core.dependencies.HistogramParams'&gt;,\n    img_part_dependency: Type[titiler.core.dependencies.DefaultDependency] = &lt;class 'titiler.core.dependencies.PartFeatureParams'&gt;,\n    search_dependency: Callable[..., Tuple[titiler.pgstac.model.PgSTACSearch, titiler.pgstac.model.Metadata]] = &lt;function SearchParams at 0x12c762ee0&gt;,\n    pixel_selection_dependency: Callable[..., rio_tiler.mosaic.methods.base.MosaicMethodBase] = &lt;function PixelSelectionParams at 0x12c3c6550&gt;,\n    backend_dependency: Type[titiler.core.dependencies.DefaultDependency] = &lt;class 'titiler.pgstac.dependencies.BackendParams'&gt;,\n    add_statistics: bool = False,\n    add_viewer: bool = False,\n    add_mosaic_list: bool = False,\n    add_part: bool = False\n)\n</code></pre>"},{"location":"api/titiler/pgstac/factory/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>titiler.core.factory.BaseTilerFactory</li> </ul>"},{"location":"api/titiler/pgstac/factory/#class-variables","title":"Class variables","text":"<pre><code>add_mosaic_list\n</code></pre> <pre><code>add_part\n</code></pre> <pre><code>add_statistics\n</code></pre> <pre><code>add_viewer\n</code></pre> <pre><code>backend_dependency\n</code></pre> <pre><code>dataset_dependency\n</code></pre> <pre><code>default_tms\n</code></pre> <pre><code>histogram_dependency\n</code></pre> <pre><code>img_part_dependency\n</code></pre> <pre><code>layer_dependency\n</code></pre> <pre><code>reader\n</code></pre> <pre><code>reader_dependency\n</code></pre> <pre><code>render_dependency\n</code></pre> <pre><code>router_prefix\n</code></pre> <pre><code>stats_dependency\n</code></pre> <pre><code>supported_tms\n</code></pre> <pre><code>templates\n</code></pre>"},{"location":"api/titiler/pgstac/factory/#methods","title":"Methods","text":""},{"location":"api/titiler/pgstac/factory/#add_route_dependencies","title":"add_route_dependencies","text":"<pre><code>def add_route_dependencies(\n    self,\n    *,\n    scopes: List[titiler.core.routing.EndpointScope],\n    dependencies=typing.List[fastapi.params.Depends]\n)\n</code></pre> <p>Add dependencies to routes.</p> <p>Allows a developer to add dependencies to a route after the route has been defined.</p>"},{"location":"api/titiler/pgstac/factory/#check_query_params","title":"check_query_params","text":"<pre><code>def check_query_params(\n    self,\n    *,\n    dependencies: List[Callable],\n    query_params: starlette.datastructures.QueryParams\n) -&gt; None\n</code></pre> <p>Check QueryParams for Query dependency.</p> <ol> <li><code>get_dependant</code> is used to get the query-parameters required by the <code>callable</code></li> <li>we use <code>request_params_to_args</code> to construct arguments needed to call the <code>callable</code></li> <li>we call the <code>callable</code> and catch any errors</li> </ol> <p>Important: We assume the <code>callable</code> in not a co-routine</p>"},{"location":"api/titiler/pgstac/factory/#color_formula_dependency","title":"color_formula_dependency","text":"<pre><code>def color_formula_dependency(\n    color_formula: Annotated[Optional[str], Query(PydanticUndefined)] = None\n) -&gt; Optional[str]\n</code></pre> <p>ColorFormula Parameter.</p>"},{"location":"api/titiler/pgstac/factory/#colormap_dependency","title":"colormap_dependency","text":"<pre><code>def colormap_dependency(\n    colormap_name: Annotated[Literal['dense_r', 'delta', 'algae_r', 'ylorbr', 'oxy', 'copper', 'tab20c_r', 'cividis_r', 'solar', 'gnuplot', 'dark2_r', 'gist_yarg_r', 'balance_r', 'gist_earth', 'balance', 'jet', 'gist_heat', 'rdylgn', 'rainbow_r', 'turbid_r', 'magma_r', 'gist_stern_r', 'plasma', 'gnuplot2_r', 'rdylgn_r', 'matter', 'puor_r', 'cool', 'gist_gray_r', 'spectral', 'turbo_r', 'amp', 'gist_heat_r', 'accent', 'ice', 'brg', 'hsv_r', 'tab10', 'brg_r', 'ylgnbu', 'accent_r', 'coolwarm', 'winter_r', 'binary', 'bwr_r', 'wistia', 'bone', 'paired', 'rdylbu', 'inferno', 'summer_r', 'hot', 'gist_ncar', 'ylorbr_r', 'amp_r', 'tarn_r', 'orrd', 'bupu', 'dense', 'greens_r', 'hot_r', 'phase', 'ocean', 'plasma_r', 'afmhot_r', 'autumn', 'gist_stern', 'diff_r', 'prgn', 'tab20b_r', 'solar_r', 'cubehelix', 'prism', 'gnuplot_r', 'inferno_r', 'twilight_r', 'jet_r', 'brbg', 'autumn_r', 'afmhot', 'rain', 'purd_r', 'wistia_r', 'tab10_r', 'coolwarm_r', 'bugn_r', 'viridis', 'ylgn_r', 'gist_rainbow', 'rainbow', 'spring_r', 'puor', 'greys', 'pubu', 'dark2', 'bugn', 'phase_r', 'thermal_r', 'set2', 'flag_r', 'ylorrd_r', 'copper_r', 'spectral_r', 'prism_r', 'set3', 'ylgnbu_r', 'rain_r', 'brbg_r', 'terrain_r', 'pastel1_r', 'rdbu', 'bwr', 'set1', 'tab20b', 'blues_r', 'purples', 'terrain', 'gist_rainbow_r', 'haline', 'summer', 'tab20c', 'turbid', 'flag', 'twilight_shifted', 'gray_r', 'delta_r', 'nipy_spectral', 'topo_r', 'oranges_r', 'prgn_r', 'diff', 'set3_r', 'deep', 'ylorrd', 'cfastie', 'rplumbo', 'gray', 'deep_r', 'gist_yarg', 'twilight', 'rdbu_r', 'pink_r', 'reds', 'algae', 'speed_r', 'twilight_shifted_r', 'bone_r', 'cividis', 'set1_r', 'purples_r', 'rdgy_r', 'matter_r', 'gist_gray', 'cool_r', 'ice_r', 'speed', 'gist_ncar_r', 'rdgy', 'ylgn', 'oxy_r', 'pastel2_r', 'pastel2', 'nipy_spectral_r', 'tempo_r', 'haline_r', 'viridis_r', 'gnuplot2', 'pubu_r', 'bupu_r', 'pastel1', 'binary_r', 'greys_r', 'paired_r', 'orrd_r', 'gnbu', 'topo', 'pubugn', 'tempo', 'tab20_r', 'pink', 'gnbu_r', 'tab20', 'blues', 'rdpu_r', 'turbo', 'rdylbu_r', 'hsv', 'winter', 'magma', 'seismic', 'piyg', 'cmrmap_r', 'schwarzwald', 'gist_earth_r', 'cubehelix_r', 'piyg_r', 'seismic_r', 'thermal', 'cmrmap', 'purd', 'rdpu', 'oranges', 'set2_r', 'greens', 'ocean_r', 'spring', 'curl', 'tarn', 'curl_r', 'reds_r', 'pubugn_r'], Query(PydanticUndefined)] = None,\n    colormap: Annotated[Optional[str], Query(PydanticUndefined)] = None\n)\n</code></pre>"},{"location":"api/titiler/pgstac/factory/#environment_dependency","title":"environment_dependency","text":"<pre><code>def environment_dependency(\n\n)\n</code></pre>"},{"location":"api/titiler/pgstac/factory/#path_dependency","title":"path_dependency","text":"<pre><code>def path_dependency(\n    searchid: typing.Annotated[str, Path(PydanticUndefined)]\n) -&gt; str\n</code></pre> <p>SearchId</p>"},{"location":"api/titiler/pgstac/factory/#pixel_selection_dependency","title":"pixel_selection_dependency","text":"<pre><code>def pixel_selection_dependency(\n    pixel_selection: Annotated[Literal['first', 'highest', 'lowest', 'mean', 'median', 'stdev', 'lastbandlow', 'lastbandhight'], Query(PydanticUndefined)] = 'first'\n) -&gt; rio_tiler.mosaic.methods.base.MosaicMethodBase\n</code></pre> <p>Returns the mosaic method used to combine datasets together.</p>"},{"location":"api/titiler/pgstac/factory/#process_dependency","title":"process_dependency","text":"<pre><code>def process_dependency(\n    algorithm: Annotated[Literal['hillshade', 'contours', 'normalizedIndex', 'terrarium', 'terrainrgb'], Query(PydanticUndefined)] = None,\n    algorithm_params: Annotated[Optional[str], Query(PydanticUndefined)] = None\n) -&gt; Optional[titiler.core.algorithm.base.BaseAlgorithm]\n</code></pre> <p>Data Post-Processing options.</p>"},{"location":"api/titiler/pgstac/factory/#register_routes","title":"register_routes","text":"<pre><code>def register_routes(\n    self\n) -&gt; None\n</code></pre> <p>This Method register routes to the router.</p>"},{"location":"api/titiler/pgstac/factory/#rescale_dependency","title":"rescale_dependency","text":"<pre><code>def rescale_dependency(\n    rescale: Annotated[Optional[List[str]], Query(PydanticUndefined)] = None\n) -&gt; Optional[List[Tuple[float, ...]]]\n</code></pre> <p>Min/Max data Rescaling</p>"},{"location":"api/titiler/pgstac/factory/#search_dependency","title":"search_dependency","text":"<pre><code>def search_dependency(\n    body: titiler.pgstac.model.RegisterMosaic\n) -&gt; Tuple[titiler.pgstac.model.PgSTACSearch, titiler.pgstac.model.Metadata]\n</code></pre> <p>Search parameters.</p>"},{"location":"api/titiler/pgstac/factory/#url_for","title":"url_for","text":"<pre><code>def url_for(\n    self,\n    request: starlette.requests.Request,\n    name: str,\n    **path_params: Any\n) -&gt; str\n</code></pre> <p>Return full url (with prefix) for a specific endpoint.</p>"},{"location":"api/titiler/pgstac/model/","title":"Module titiler.pgstac.model","text":"<p>Titiler.pgstac models.</p> <p>Note: This is mostly a copy of github.com/stac-utils/stac-fastapi/blob/master/stac_fastapi/pgstac/stac_fastapi/pgstac/types/search.py</p>"},{"location":"api/titiler/pgstac/model/#variables","title":"Variables","text":"<pre><code>FilterLang\n</code></pre> <pre><code>Operator\n</code></pre>"},{"location":"api/titiler/pgstac/model/#classes","title":"Classes","text":""},{"location":"api/titiler/pgstac/model/#context","title":"Context","text":"<pre><code>class Context(\n    __pydantic_self__,\n    **data: 'Any'\n)\n</code></pre>"},{"location":"api/titiler/pgstac/model/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>pydantic.main.BaseModel</li> </ul>"},{"location":"api/titiler/pgstac/model/#class-variables","title":"Class variables","text":"<pre><code>model_config\n</code></pre> <pre><code>model_fields\n</code></pre>"},{"location":"api/titiler/pgstac/model/#static-methods","title":"Static methods","text":""},{"location":"api/titiler/pgstac/model/#construct","title":"construct","text":"<pre><code>def construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#from_orm","title":"from_orm","text":"<pre><code>def from_orm(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#model_construct","title":"model_construct","text":"<pre><code>def model_construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if <code>Config.extra = 'allow'</code> was set since it adds all passed values</p> <p>Parameters:</p> Name Type Description Default _fields_set None The set of field names accepted for the Model instance. None values None Trusted or pre-validated data dictionary. None <p>Returns:</p> Type Description None A new instance of the <code>Model</code> class with validated data."},{"location":"api/titiler/pgstac/model/#model_json_schema","title":"model_json_schema","text":"<pre><code>def model_json_schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    schema_generator: 'type[GenerateJsonSchema]' = &lt;class 'pydantic.json_schema.GenerateJsonSchema'&gt;,\n    mode: 'JsonSchemaMode' = 'validation'\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default by_alias None Whether to use attribute aliases or not. None ref_template None The reference template. None schema_generator None To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications None mode None The mode in which to generate the schema. None <p>Returns:</p> Type Description None The JSON schema for the given model class."},{"location":"api/titiler/pgstac/model/#model_parametrized_name","title":"model_parametrized_name","text":"<pre><code>def model_parametrized_name(\n    params: 'tuple[type[Any], ...]'\n) -&gt; 'str'\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default params None Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>. None <p>Returns:</p> Type Description None String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables. <p>Raises:</p> Type Description TypeError Raised when trying to generate concrete names for non-generic models."},{"location":"api/titiler/pgstac/model/#model_rebuild","title":"model_rebuild","text":"<pre><code>def model_rebuild(\n    *,\n    force: 'bool' = False,\n    raise_errors: 'bool' = True,\n    _parent_namespace_depth: 'int' = 2,\n    _types_namespace: 'dict[str, Any] | None' = None\n) -&gt; 'bool | None'\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default force None Whether to force the rebuilding of the model schema, defaults to <code>False</code>. None raise_errors None Whether to raise errors, defaults to <code>True</code>. None _parent_namespace_depth None The depth level of the parent namespace, defaults to 2. None _types_namespace None The types namespace, defaults to <code>None</code>. None <p>Returns:</p> Type Description None Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>."},{"location":"api/titiler/pgstac/model/#model_validate","title":"model_validate","text":"<pre><code>def model_validate(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    from_attributes: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default obj None The object to validate. None strict None Whether to raise an exception on invalid fields. None from_attributes None Whether to extract data from object attributes. None context None Additional context to pass to the validator. None <p>Returns:</p> Type Description None The validated model instance. <p>Raises:</p> Type Description ValidationError If the object could not be validated."},{"location":"api/titiler/pgstac/model/#model_validate_json","title":"model_validate_json","text":"<pre><code>def model_validate_json(\n    json_data: 'str | bytes | bytearray',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default json_data None The JSON data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model. <p>Raises:</p> Type Description ValueError If <code>json_data</code> is not a JSON string."},{"location":"api/titiler/pgstac/model/#model_validate_strings","title":"model_validate_strings","text":"<pre><code>def model_validate_strings(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given object contains string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default obj None The object contains string data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model."},{"location":"api/titiler/pgstac/model/#parse_file","title":"parse_file","text":"<pre><code>def parse_file(\n    path: 'str | Path',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#parse_obj","title":"parse_obj","text":"<pre><code>def parse_obj(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#parse_raw","title":"parse_raw","text":"<pre><code>def parse_raw(\n    b: 'str | bytes',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#schema","title":"schema","text":"<pre><code>def schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}'\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#schema_json","title":"schema_json","text":"<pre><code>def schema_json(\n    *,\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#update_forward_refs","title":"update_forward_refs","text":"<pre><code>def update_forward_refs(\n    **localns: 'Any'\n) -&gt; 'None'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#validate","title":"validate","text":"<pre><code>def validate(\n    value: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#validate_limit","title":"validate_limit","text":"<pre><code>def validate_limit(\n    v,\n    info: pydantic_core.core_schema.ValidationInfo\n)\n</code></pre> <p>validate limit.</p>"},{"location":"api/titiler/pgstac/model/#instance-variables","title":"Instance variables","text":"<pre><code>model_computed_fields\n</code></pre> <p>Get the computed fields of this model instance.</p> <pre><code>model_extra\n</code></pre> <p>Get extra fields set during validation.</p> <pre><code>model_fields_set\n</code></pre> <p>Returns the set of fields that have been set on this model instance.</p>"},{"location":"api/titiler/pgstac/model/#methods","title":"Methods","text":""},{"location":"api/titiler/pgstac/model/#copy","title":"copy","text":"<pre><code>def copy(\n    self: 'Model',\n    *,\n    include: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    update: 'typing.Dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default include None Optional set or mapping specifying which fields to include in the copied model. None exclude None Optional set or mapping specifying which fields to exclude in the copied model. None update None Optional dictionary of field-value pairs to override field values in the copied model. None deep None If True, the values of fields that are Pydantic models will be deep copied. None <p>Returns:</p> Type Description None A copy of the model with included, excluded and updated fields as specified."},{"location":"api/titiler/pgstac/model/#dict","title":"dict","text":"<pre><code>def dict(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#json","title":"json","text":"<pre><code>def json(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    encoder: 'typing.Callable[[Any], Any] | None' = PydanticUndefined,\n    models_as_dict: 'bool' = PydanticUndefined,\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#model_copy","title":"model_copy","text":"<pre><code>def model_copy(\n    self: 'Model',\n    *,\n    update: 'dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#model_copy</p> <p>Returns a copy of the model.</p> <p>Parameters:</p> Name Type Description Default update None Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data. None deep None Set to <code>True</code> to make a deep copy of the model. None <p>Returns:</p> Type Description None New model instance."},{"location":"api/titiler/pgstac/model/#model_dump","title":"model_dump","text":"<pre><code>def model_dump(\n    self,\n    *,\n    mode: \"Literal['json', 'python'] | str\" = 'python',\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump</p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default mode None The mode in which <code>to_python</code> should run. If mode is 'json', the dictionary will only contain JSON serializable types. If mode is 'python', the dictionary may contain any Python objects. None include None A list of fields to include in the output. None exclude None A list of fields to exclude from the output. None by_alias None Whether to use the field's alias in the dictionary key if defined. None exclude_unset None Whether to exclude fields that are unset or None from the output. None exclude_defaults None Whether to exclude fields that are set to their default value from the output. None exclude_none None Whether to exclude fields that have a value of <code>None</code> from the output. None round_trip None Whether to enable serialization and deserialization round-trip support. None warnings None Whether to log warnings when invalid fields are encountered. None <p>Returns:</p> Type Description None A dictionary representation of the model."},{"location":"api/titiler/pgstac/model/#model_dump_json","title":"model_dump_json","text":"<pre><code>def model_dump_json(\n    self,\n    *,\n    indent: 'int | None' = None,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'str'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump_json</p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default indent None Indentation to use in the JSON output. If None is passed, the output will be compact. None include None Field(s) to include in the JSON output. Can take either a string or set of strings. None exclude None Field(s) to exclude from the JSON output. Can take either a string or set of strings. None by_alias None Whether to serialize using field aliases. None exclude_unset None Whether to exclude fields that have not been explicitly set. None exclude_defaults None Whether to exclude fields that have the default value. None exclude_none None Whether to exclude fields that have a value of <code>None</code>. None round_trip None Whether to use serialization/deserialization between JSON and class instance. None warnings None Whether to show any warnings that occurred during serialization. None <p>Returns:</p> Type Description None A JSON string representation of the model."},{"location":"api/titiler/pgstac/model/#model_post_init","title":"model_post_init","text":"<pre><code>def model_post_init(\n    self,\n    _BaseModel__context: 'Any'\n) -&gt; 'None'\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <p>This is useful if you want to do some validation that requires the entire model to be initialized.</p>"},{"location":"api/titiler/pgstac/model/#info","title":"Info","text":"<pre><code>class Info(\n    __pydantic_self__,\n    **data: 'Any'\n)\n</code></pre>"},{"location":"api/titiler/pgstac/model/#ancestors-in-mro_1","title":"Ancestors (in MRO)","text":"<ul> <li>pydantic.main.BaseModel</li> </ul>"},{"location":"api/titiler/pgstac/model/#class-variables_1","title":"Class variables","text":"<pre><code>model_config\n</code></pre> <pre><code>model_fields\n</code></pre>"},{"location":"api/titiler/pgstac/model/#static-methods_1","title":"Static methods","text":""},{"location":"api/titiler/pgstac/model/#construct_1","title":"construct","text":"<pre><code>def construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#from_orm_1","title":"from_orm","text":"<pre><code>def from_orm(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#model_construct_1","title":"model_construct","text":"<pre><code>def model_construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if <code>Config.extra = 'allow'</code> was set since it adds all passed values</p> <p>Parameters:</p> Name Type Description Default _fields_set None The set of field names accepted for the Model instance. None values None Trusted or pre-validated data dictionary. None <p>Returns:</p> Type Description None A new instance of the <code>Model</code> class with validated data."},{"location":"api/titiler/pgstac/model/#model_json_schema_1","title":"model_json_schema","text":"<pre><code>def model_json_schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    schema_generator: 'type[GenerateJsonSchema]' = &lt;class 'pydantic.json_schema.GenerateJsonSchema'&gt;,\n    mode: 'JsonSchemaMode' = 'validation'\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default by_alias None Whether to use attribute aliases or not. None ref_template None The reference template. None schema_generator None To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications None mode None The mode in which to generate the schema. None <p>Returns:</p> Type Description None The JSON schema for the given model class."},{"location":"api/titiler/pgstac/model/#model_parametrized_name_1","title":"model_parametrized_name","text":"<pre><code>def model_parametrized_name(\n    params: 'tuple[type[Any], ...]'\n) -&gt; 'str'\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default params None Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>. None <p>Returns:</p> Type Description None String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables. <p>Raises:</p> Type Description TypeError Raised when trying to generate concrete names for non-generic models."},{"location":"api/titiler/pgstac/model/#model_rebuild_1","title":"model_rebuild","text":"<pre><code>def model_rebuild(\n    *,\n    force: 'bool' = False,\n    raise_errors: 'bool' = True,\n    _parent_namespace_depth: 'int' = 2,\n    _types_namespace: 'dict[str, Any] | None' = None\n) -&gt; 'bool | None'\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default force None Whether to force the rebuilding of the model schema, defaults to <code>False</code>. None raise_errors None Whether to raise errors, defaults to <code>True</code>. None _parent_namespace_depth None The depth level of the parent namespace, defaults to 2. None _types_namespace None The types namespace, defaults to <code>None</code>. None <p>Returns:</p> Type Description None Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>."},{"location":"api/titiler/pgstac/model/#model_validate_1","title":"model_validate","text":"<pre><code>def model_validate(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    from_attributes: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default obj None The object to validate. None strict None Whether to raise an exception on invalid fields. None from_attributes None Whether to extract data from object attributes. None context None Additional context to pass to the validator. None <p>Returns:</p> Type Description None The validated model instance. <p>Raises:</p> Type Description ValidationError If the object could not be validated."},{"location":"api/titiler/pgstac/model/#model_validate_json_1","title":"model_validate_json","text":"<pre><code>def model_validate_json(\n    json_data: 'str | bytes | bytearray',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default json_data None The JSON data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model. <p>Raises:</p> Type Description ValueError If <code>json_data</code> is not a JSON string."},{"location":"api/titiler/pgstac/model/#model_validate_strings_1","title":"model_validate_strings","text":"<pre><code>def model_validate_strings(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given object contains string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default obj None The object contains string data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model."},{"location":"api/titiler/pgstac/model/#parse_file_1","title":"parse_file","text":"<pre><code>def parse_file(\n    path: 'str | Path',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#parse_obj_1","title":"parse_obj","text":"<pre><code>def parse_obj(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#parse_raw_1","title":"parse_raw","text":"<pre><code>def parse_raw(\n    b: 'str | bytes',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#schema_1","title":"schema","text":"<pre><code>def schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}'\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#schema_json_1","title":"schema_json","text":"<pre><code>def schema_json(\n    *,\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#update_forward_refs_1","title":"update_forward_refs","text":"<pre><code>def update_forward_refs(\n    **localns: 'Any'\n) -&gt; 'None'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#validate_1","title":"validate","text":"<pre><code>def validate(\n    value: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#instance-variables_1","title":"Instance variables","text":"<pre><code>model_computed_fields\n</code></pre> <p>Get the computed fields of this model instance.</p> <pre><code>model_extra\n</code></pre> <p>Get extra fields set during validation.</p> <pre><code>model_fields_set\n</code></pre> <p>Returns the set of fields that have been set on this model instance.</p>"},{"location":"api/titiler/pgstac/model/#methods_1","title":"Methods","text":""},{"location":"api/titiler/pgstac/model/#copy_1","title":"copy","text":"<pre><code>def copy(\n    self: 'Model',\n    *,\n    include: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    update: 'typing.Dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default include None Optional set or mapping specifying which fields to include in the copied model. None exclude None Optional set or mapping specifying which fields to exclude in the copied model. None update None Optional dictionary of field-value pairs to override field values in the copied model. None deep None If True, the values of fields that are Pydantic models will be deep copied. None <p>Returns:</p> Type Description None A copy of the model with included, excluded and updated fields as specified."},{"location":"api/titiler/pgstac/model/#dict_1","title":"dict","text":"<pre><code>def dict(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#json_1","title":"json","text":"<pre><code>def json(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    encoder: 'typing.Callable[[Any], Any] | None' = PydanticUndefined,\n    models_as_dict: 'bool' = PydanticUndefined,\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#model_copy_1","title":"model_copy","text":"<pre><code>def model_copy(\n    self: 'Model',\n    *,\n    update: 'dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#model_copy</p> <p>Returns a copy of the model.</p> <p>Parameters:</p> Name Type Description Default update None Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data. None deep None Set to <code>True</code> to make a deep copy of the model. None <p>Returns:</p> Type Description None New model instance."},{"location":"api/titiler/pgstac/model/#model_dump_1","title":"model_dump","text":"<pre><code>def model_dump(\n    self,\n    *,\n    mode: \"Literal['json', 'python'] | str\" = 'python',\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump</p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default mode None The mode in which <code>to_python</code> should run. If mode is 'json', the dictionary will only contain JSON serializable types. If mode is 'python', the dictionary may contain any Python objects. None include None A list of fields to include in the output. None exclude None A list of fields to exclude from the output. None by_alias None Whether to use the field's alias in the dictionary key if defined. None exclude_unset None Whether to exclude fields that are unset or None from the output. None exclude_defaults None Whether to exclude fields that are set to their default value from the output. None exclude_none None Whether to exclude fields that have a value of <code>None</code> from the output. None round_trip None Whether to enable serialization and deserialization round-trip support. None warnings None Whether to log warnings when invalid fields are encountered. None <p>Returns:</p> Type Description None A dictionary representation of the model."},{"location":"api/titiler/pgstac/model/#model_dump_json_1","title":"model_dump_json","text":"<pre><code>def model_dump_json(\n    self,\n    *,\n    indent: 'int | None' = None,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'str'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump_json</p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default indent None Indentation to use in the JSON output. If None is passed, the output will be compact. None include None Field(s) to include in the JSON output. Can take either a string or set of strings. None exclude None Field(s) to exclude from the JSON output. Can take either a string or set of strings. None by_alias None Whether to serialize using field aliases. None exclude_unset None Whether to exclude fields that have not been explicitly set. None exclude_defaults None Whether to exclude fields that have the default value. None exclude_none None Whether to exclude fields that have a value of <code>None</code>. None round_trip None Whether to use serialization/deserialization between JSON and class instance. None warnings None Whether to show any warnings that occurred during serialization. None <p>Returns:</p> Type Description None A JSON string representation of the model."},{"location":"api/titiler/pgstac/model/#model_post_init_1","title":"model_post_init","text":"<pre><code>def model_post_init(\n    self,\n    _BaseModel__context: 'Any'\n) -&gt; 'None'\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <p>This is useful if you want to do some validation that requires the entire model to be initialized.</p>"},{"location":"api/titiler/pgstac/model/#infos","title":"Infos","text":"<pre><code>class Infos(\n    __pydantic_self__,\n    **data: 'Any'\n)\n</code></pre>"},{"location":"api/titiler/pgstac/model/#ancestors-in-mro_2","title":"Ancestors (in MRO)","text":"<ul> <li>pydantic.main.BaseModel</li> </ul>"},{"location":"api/titiler/pgstac/model/#class-variables_2","title":"Class variables","text":"<pre><code>model_config\n</code></pre> <pre><code>model_fields\n</code></pre>"},{"location":"api/titiler/pgstac/model/#static-methods_2","title":"Static methods","text":""},{"location":"api/titiler/pgstac/model/#construct_2","title":"construct","text":"<pre><code>def construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#from_orm_2","title":"from_orm","text":"<pre><code>def from_orm(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#model_construct_2","title":"model_construct","text":"<pre><code>def model_construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if <code>Config.extra = 'allow'</code> was set since it adds all passed values</p> <p>Parameters:</p> Name Type Description Default _fields_set None The set of field names accepted for the Model instance. None values None Trusted or pre-validated data dictionary. None <p>Returns:</p> Type Description None A new instance of the <code>Model</code> class with validated data."},{"location":"api/titiler/pgstac/model/#model_json_schema_2","title":"model_json_schema","text":"<pre><code>def model_json_schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    schema_generator: 'type[GenerateJsonSchema]' = &lt;class 'pydantic.json_schema.GenerateJsonSchema'&gt;,\n    mode: 'JsonSchemaMode' = 'validation'\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default by_alias None Whether to use attribute aliases or not. None ref_template None The reference template. None schema_generator None To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications None mode None The mode in which to generate the schema. None <p>Returns:</p> Type Description None The JSON schema for the given model class."},{"location":"api/titiler/pgstac/model/#model_parametrized_name_2","title":"model_parametrized_name","text":"<pre><code>def model_parametrized_name(\n    params: 'tuple[type[Any], ...]'\n) -&gt; 'str'\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default params None Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>. None <p>Returns:</p> Type Description None String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables. <p>Raises:</p> Type Description TypeError Raised when trying to generate concrete names for non-generic models."},{"location":"api/titiler/pgstac/model/#model_rebuild_2","title":"model_rebuild","text":"<pre><code>def model_rebuild(\n    *,\n    force: 'bool' = False,\n    raise_errors: 'bool' = True,\n    _parent_namespace_depth: 'int' = 2,\n    _types_namespace: 'dict[str, Any] | None' = None\n) -&gt; 'bool | None'\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default force None Whether to force the rebuilding of the model schema, defaults to <code>False</code>. None raise_errors None Whether to raise errors, defaults to <code>True</code>. None _parent_namespace_depth None The depth level of the parent namespace, defaults to 2. None _types_namespace None The types namespace, defaults to <code>None</code>. None <p>Returns:</p> Type Description None Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>."},{"location":"api/titiler/pgstac/model/#model_validate_2","title":"model_validate","text":"<pre><code>def model_validate(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    from_attributes: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default obj None The object to validate. None strict None Whether to raise an exception on invalid fields. None from_attributes None Whether to extract data from object attributes. None context None Additional context to pass to the validator. None <p>Returns:</p> Type Description None The validated model instance. <p>Raises:</p> Type Description ValidationError If the object could not be validated."},{"location":"api/titiler/pgstac/model/#model_validate_json_2","title":"model_validate_json","text":"<pre><code>def model_validate_json(\n    json_data: 'str | bytes | bytearray',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default json_data None The JSON data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model. <p>Raises:</p> Type Description ValueError If <code>json_data</code> is not a JSON string."},{"location":"api/titiler/pgstac/model/#model_validate_strings_2","title":"model_validate_strings","text":"<pre><code>def model_validate_strings(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given object contains string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default obj None The object contains string data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model."},{"location":"api/titiler/pgstac/model/#parse_file_2","title":"parse_file","text":"<pre><code>def parse_file(\n    path: 'str | Path',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#parse_obj_2","title":"parse_obj","text":"<pre><code>def parse_obj(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#parse_raw_2","title":"parse_raw","text":"<pre><code>def parse_raw(\n    b: 'str | bytes',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#schema_2","title":"schema","text":"<pre><code>def schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}'\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#schema_json_2","title":"schema_json","text":"<pre><code>def schema_json(\n    *,\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#update_forward_refs_2","title":"update_forward_refs","text":"<pre><code>def update_forward_refs(\n    **localns: 'Any'\n) -&gt; 'None'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#validate_2","title":"validate","text":"<pre><code>def validate(\n    value: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#instance-variables_2","title":"Instance variables","text":"<pre><code>model_computed_fields\n</code></pre> <p>Get the computed fields of this model instance.</p> <pre><code>model_extra\n</code></pre> <p>Get extra fields set during validation.</p> <pre><code>model_fields_set\n</code></pre> <p>Returns the set of fields that have been set on this model instance.</p>"},{"location":"api/titiler/pgstac/model/#methods_2","title":"Methods","text":""},{"location":"api/titiler/pgstac/model/#copy_2","title":"copy","text":"<pre><code>def copy(\n    self: 'Model',\n    *,\n    include: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    update: 'typing.Dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default include None Optional set or mapping specifying which fields to include in the copied model. None exclude None Optional set or mapping specifying which fields to exclude in the copied model. None update None Optional dictionary of field-value pairs to override field values in the copied model. None deep None If True, the values of fields that are Pydantic models will be deep copied. None <p>Returns:</p> Type Description None A copy of the model with included, excluded and updated fields as specified."},{"location":"api/titiler/pgstac/model/#dict_2","title":"dict","text":"<pre><code>def dict(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#json_2","title":"json","text":"<pre><code>def json(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    encoder: 'typing.Callable[[Any], Any] | None' = PydanticUndefined,\n    models_as_dict: 'bool' = PydanticUndefined,\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#model_copy_2","title":"model_copy","text":"<pre><code>def model_copy(\n    self: 'Model',\n    *,\n    update: 'dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#model_copy</p> <p>Returns a copy of the model.</p> <p>Parameters:</p> Name Type Description Default update None Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data. None deep None Set to <code>True</code> to make a deep copy of the model. None <p>Returns:</p> Type Description None New model instance."},{"location":"api/titiler/pgstac/model/#model_dump_2","title":"model_dump","text":"<pre><code>def model_dump(\n    self,\n    *,\n    mode: \"Literal['json', 'python'] | str\" = 'python',\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump</p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default mode None The mode in which <code>to_python</code> should run. If mode is 'json', the dictionary will only contain JSON serializable types. If mode is 'python', the dictionary may contain any Python objects. None include None A list of fields to include in the output. None exclude None A list of fields to exclude from the output. None by_alias None Whether to use the field's alias in the dictionary key if defined. None exclude_unset None Whether to exclude fields that are unset or None from the output. None exclude_defaults None Whether to exclude fields that are set to their default value from the output. None exclude_none None Whether to exclude fields that have a value of <code>None</code> from the output. None round_trip None Whether to enable serialization and deserialization round-trip support. None warnings None Whether to log warnings when invalid fields are encountered. None <p>Returns:</p> Type Description None A dictionary representation of the model."},{"location":"api/titiler/pgstac/model/#model_dump_json_2","title":"model_dump_json","text":"<pre><code>def model_dump_json(\n    self,\n    *,\n    indent: 'int | None' = None,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'str'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump_json</p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default indent None Indentation to use in the JSON output. If None is passed, the output will be compact. None include None Field(s) to include in the JSON output. Can take either a string or set of strings. None exclude None Field(s) to exclude from the JSON output. Can take either a string or set of strings. None by_alias None Whether to serialize using field aliases. None exclude_unset None Whether to exclude fields that have not been explicitly set. None exclude_defaults None Whether to exclude fields that have the default value. None exclude_none None Whether to exclude fields that have a value of <code>None</code>. None round_trip None Whether to use serialization/deserialization between JSON and class instance. None warnings None Whether to show any warnings that occurred during serialization. None <p>Returns:</p> Type Description None A JSON string representation of the model."},{"location":"api/titiler/pgstac/model/#model_post_init_2","title":"model_post_init","text":"<pre><code>def model_post_init(\n    self,\n    _BaseModel__context: 'Any'\n) -&gt; 'None'\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <p>This is useful if you want to do some validation that requires the entire model to be initialized.</p>"},{"location":"api/titiler/pgstac/model/#link","title":"Link","text":"<pre><code>class Link(\n    __pydantic_self__,\n    **data: 'Any'\n)\n</code></pre>"},{"location":"api/titiler/pgstac/model/#ancestors-in-mro_3","title":"Ancestors (in MRO)","text":"<ul> <li>pydantic.main.BaseModel</li> </ul>"},{"location":"api/titiler/pgstac/model/#class-variables_3","title":"Class variables","text":"<pre><code>model_config\n</code></pre> <pre><code>model_fields\n</code></pre>"},{"location":"api/titiler/pgstac/model/#static-methods_3","title":"Static methods","text":""},{"location":"api/titiler/pgstac/model/#construct_3","title":"construct","text":"<pre><code>def construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#from_orm_3","title":"from_orm","text":"<pre><code>def from_orm(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#model_construct_3","title":"model_construct","text":"<pre><code>def model_construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if <code>Config.extra = 'allow'</code> was set since it adds all passed values</p> <p>Parameters:</p> Name Type Description Default _fields_set None The set of field names accepted for the Model instance. None values None Trusted or pre-validated data dictionary. None <p>Returns:</p> Type Description None A new instance of the <code>Model</code> class with validated data."},{"location":"api/titiler/pgstac/model/#model_json_schema_3","title":"model_json_schema","text":"<pre><code>def model_json_schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    schema_generator: 'type[GenerateJsonSchema]' = &lt;class 'pydantic.json_schema.GenerateJsonSchema'&gt;,\n    mode: 'JsonSchemaMode' = 'validation'\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default by_alias None Whether to use attribute aliases or not. None ref_template None The reference template. None schema_generator None To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications None mode None The mode in which to generate the schema. None <p>Returns:</p> Type Description None The JSON schema for the given model class."},{"location":"api/titiler/pgstac/model/#model_parametrized_name_3","title":"model_parametrized_name","text":"<pre><code>def model_parametrized_name(\n    params: 'tuple[type[Any], ...]'\n) -&gt; 'str'\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default params None Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>. None <p>Returns:</p> Type Description None String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables. <p>Raises:</p> Type Description TypeError Raised when trying to generate concrete names for non-generic models."},{"location":"api/titiler/pgstac/model/#model_rebuild_3","title":"model_rebuild","text":"<pre><code>def model_rebuild(\n    *,\n    force: 'bool' = False,\n    raise_errors: 'bool' = True,\n    _parent_namespace_depth: 'int' = 2,\n    _types_namespace: 'dict[str, Any] | None' = None\n) -&gt; 'bool | None'\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default force None Whether to force the rebuilding of the model schema, defaults to <code>False</code>. None raise_errors None Whether to raise errors, defaults to <code>True</code>. None _parent_namespace_depth None The depth level of the parent namespace, defaults to 2. None _types_namespace None The types namespace, defaults to <code>None</code>. None <p>Returns:</p> Type Description None Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>."},{"location":"api/titiler/pgstac/model/#model_validate_3","title":"model_validate","text":"<pre><code>def model_validate(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    from_attributes: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default obj None The object to validate. None strict None Whether to raise an exception on invalid fields. None from_attributes None Whether to extract data from object attributes. None context None Additional context to pass to the validator. None <p>Returns:</p> Type Description None The validated model instance. <p>Raises:</p> Type Description ValidationError If the object could not be validated."},{"location":"api/titiler/pgstac/model/#model_validate_json_3","title":"model_validate_json","text":"<pre><code>def model_validate_json(\n    json_data: 'str | bytes | bytearray',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default json_data None The JSON data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model. <p>Raises:</p> Type Description ValueError If <code>json_data</code> is not a JSON string."},{"location":"api/titiler/pgstac/model/#model_validate_strings_3","title":"model_validate_strings","text":"<pre><code>def model_validate_strings(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given object contains string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default obj None The object contains string data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model."},{"location":"api/titiler/pgstac/model/#parse_file_3","title":"parse_file","text":"<pre><code>def parse_file(\n    path: 'str | Path',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#parse_obj_3","title":"parse_obj","text":"<pre><code>def parse_obj(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#parse_raw_3","title":"parse_raw","text":"<pre><code>def parse_raw(\n    b: 'str | bytes',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#schema_3","title":"schema","text":"<pre><code>def schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}'\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#schema_json_3","title":"schema_json","text":"<pre><code>def schema_json(\n    *,\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#update_forward_refs_3","title":"update_forward_refs","text":"<pre><code>def update_forward_refs(\n    **localns: 'Any'\n) -&gt; 'None'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#validate_3","title":"validate","text":"<pre><code>def validate(\n    value: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#instance-variables_3","title":"Instance variables","text":"<pre><code>model_computed_fields\n</code></pre> <p>Get the computed fields of this model instance.</p> <pre><code>model_extra\n</code></pre> <p>Get extra fields set during validation.</p> <pre><code>model_fields_set\n</code></pre> <p>Returns the set of fields that have been set on this model instance.</p>"},{"location":"api/titiler/pgstac/model/#methods_3","title":"Methods","text":""},{"location":"api/titiler/pgstac/model/#copy_3","title":"copy","text":"<pre><code>def copy(\n    self: 'Model',\n    *,\n    include: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    update: 'typing.Dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default include None Optional set or mapping specifying which fields to include in the copied model. None exclude None Optional set or mapping specifying which fields to exclude in the copied model. None update None Optional dictionary of field-value pairs to override field values in the copied model. None deep None If True, the values of fields that are Pydantic models will be deep copied. None <p>Returns:</p> Type Description None A copy of the model with included, excluded and updated fields as specified."},{"location":"api/titiler/pgstac/model/#dict_3","title":"dict","text":"<pre><code>def dict(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#json_3","title":"json","text":"<pre><code>def json(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    encoder: 'typing.Callable[[Any], Any] | None' = PydanticUndefined,\n    models_as_dict: 'bool' = PydanticUndefined,\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#model_copy_3","title":"model_copy","text":"<pre><code>def model_copy(\n    self: 'Model',\n    *,\n    update: 'dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#model_copy</p> <p>Returns a copy of the model.</p> <p>Parameters:</p> Name Type Description Default update None Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data. None deep None Set to <code>True</code> to make a deep copy of the model. None <p>Returns:</p> Type Description None New model instance."},{"location":"api/titiler/pgstac/model/#model_dump_3","title":"model_dump","text":"<pre><code>def model_dump(\n    self,\n    *,\n    mode: \"Literal['json', 'python'] | str\" = 'python',\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump</p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default mode None The mode in which <code>to_python</code> should run. If mode is 'json', the dictionary will only contain JSON serializable types. If mode is 'python', the dictionary may contain any Python objects. None include None A list of fields to include in the output. None exclude None A list of fields to exclude from the output. None by_alias None Whether to use the field's alias in the dictionary key if defined. None exclude_unset None Whether to exclude fields that are unset or None from the output. None exclude_defaults None Whether to exclude fields that are set to their default value from the output. None exclude_none None Whether to exclude fields that have a value of <code>None</code> from the output. None round_trip None Whether to enable serialization and deserialization round-trip support. None warnings None Whether to log warnings when invalid fields are encountered. None <p>Returns:</p> Type Description None A dictionary representation of the model."},{"location":"api/titiler/pgstac/model/#model_dump_json_3","title":"model_dump_json","text":"<pre><code>def model_dump_json(\n    self,\n    *,\n    indent: 'int | None' = None,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'str'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump_json</p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default indent None Indentation to use in the JSON output. If None is passed, the output will be compact. None include None Field(s) to include in the JSON output. Can take either a string or set of strings. None exclude None Field(s) to exclude from the JSON output. Can take either a string or set of strings. None by_alias None Whether to serialize using field aliases. None exclude_unset None Whether to exclude fields that have not been explicitly set. None exclude_defaults None Whether to exclude fields that have the default value. None exclude_none None Whether to exclude fields that have a value of <code>None</code>. None round_trip None Whether to use serialization/deserialization between JSON and class instance. None warnings None Whether to show any warnings that occurred during serialization. None <p>Returns:</p> Type Description None A JSON string representation of the model."},{"location":"api/titiler/pgstac/model/#model_post_init_3","title":"model_post_init","text":"<pre><code>def model_post_init(\n    self,\n    _BaseModel__context: 'Any'\n) -&gt; 'None'\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <p>This is useful if you want to do some validation that requires the entire model to be initialized.</p>"},{"location":"api/titiler/pgstac/model/#metadata","title":"Metadata","text":"<pre><code>class Metadata(\n    __pydantic_self__,\n    **data: 'Any'\n)\n</code></pre>"},{"location":"api/titiler/pgstac/model/#ancestors-in-mro_4","title":"Ancestors (in MRO)","text":"<ul> <li>pydantic.main.BaseModel</li> </ul>"},{"location":"api/titiler/pgstac/model/#class-variables_4","title":"Class variables","text":"<pre><code>model_config\n</code></pre> <pre><code>model_fields\n</code></pre>"},{"location":"api/titiler/pgstac/model/#static-methods_4","title":"Static methods","text":""},{"location":"api/titiler/pgstac/model/#construct_4","title":"construct","text":"<pre><code>def construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#from_orm_4","title":"from_orm","text":"<pre><code>def from_orm(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#model_construct_4","title":"model_construct","text":"<pre><code>def model_construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if <code>Config.extra = 'allow'</code> was set since it adds all passed values</p> <p>Parameters:</p> Name Type Description Default _fields_set None The set of field names accepted for the Model instance. None values None Trusted or pre-validated data dictionary. None <p>Returns:</p> Type Description None A new instance of the <code>Model</code> class with validated data."},{"location":"api/titiler/pgstac/model/#model_json_schema_4","title":"model_json_schema","text":"<pre><code>def model_json_schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    schema_generator: 'type[GenerateJsonSchema]' = &lt;class 'pydantic.json_schema.GenerateJsonSchema'&gt;,\n    mode: 'JsonSchemaMode' = 'validation'\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default by_alias None Whether to use attribute aliases or not. None ref_template None The reference template. None schema_generator None To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications None mode None The mode in which to generate the schema. None <p>Returns:</p> Type Description None The JSON schema for the given model class."},{"location":"api/titiler/pgstac/model/#model_parametrized_name_4","title":"model_parametrized_name","text":"<pre><code>def model_parametrized_name(\n    params: 'tuple[type[Any], ...]'\n) -&gt; 'str'\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default params None Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>. None <p>Returns:</p> Type Description None String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables. <p>Raises:</p> Type Description TypeError Raised when trying to generate concrete names for non-generic models."},{"location":"api/titiler/pgstac/model/#model_rebuild_4","title":"model_rebuild","text":"<pre><code>def model_rebuild(\n    *,\n    force: 'bool' = False,\n    raise_errors: 'bool' = True,\n    _parent_namespace_depth: 'int' = 2,\n    _types_namespace: 'dict[str, Any] | None' = None\n) -&gt; 'bool | None'\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default force None Whether to force the rebuilding of the model schema, defaults to <code>False</code>. None raise_errors None Whether to raise errors, defaults to <code>True</code>. None _parent_namespace_depth None The depth level of the parent namespace, defaults to 2. None _types_namespace None The types namespace, defaults to <code>None</code>. None <p>Returns:</p> Type Description None Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>."},{"location":"api/titiler/pgstac/model/#model_validate_4","title":"model_validate","text":"<pre><code>def model_validate(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    from_attributes: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default obj None The object to validate. None strict None Whether to raise an exception on invalid fields. None from_attributes None Whether to extract data from object attributes. None context None Additional context to pass to the validator. None <p>Returns:</p> Type Description None The validated model instance. <p>Raises:</p> Type Description ValidationError If the object could not be validated."},{"location":"api/titiler/pgstac/model/#model_validate_json_4","title":"model_validate_json","text":"<pre><code>def model_validate_json(\n    json_data: 'str | bytes | bytearray',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default json_data None The JSON data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model. <p>Raises:</p> Type Description ValueError If <code>json_data</code> is not a JSON string."},{"location":"api/titiler/pgstac/model/#model_validate_strings_4","title":"model_validate_strings","text":"<pre><code>def model_validate_strings(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given object contains string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default obj None The object contains string data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model."},{"location":"api/titiler/pgstac/model/#parse_file_4","title":"parse_file","text":"<pre><code>def parse_file(\n    path: 'str | Path',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#parse_obj_4","title":"parse_obj","text":"<pre><code>def parse_obj(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#parse_raw_4","title":"parse_raw","text":"<pre><code>def parse_raw(\n    b: 'str | bytes',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#schema_4","title":"schema","text":"<pre><code>def schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}'\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#schema_json_4","title":"schema_json","text":"<pre><code>def schema_json(\n    *,\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#update_forward_refs_4","title":"update_forward_refs","text":"<pre><code>def update_forward_refs(\n    **localns: 'Any'\n) -&gt; 'None'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#validate_4","title":"validate","text":"<pre><code>def validate(\n    value: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#instance-variables_4","title":"Instance variables","text":"<pre><code>model_computed_fields\n</code></pre> <p>Get the computed fields of this model instance.</p> <pre><code>model_extra\n</code></pre> <p>Get extra fields set during validation.</p> <pre><code>model_fields_set\n</code></pre> <p>Returns the set of fields that have been set on this model instance.</p>"},{"location":"api/titiler/pgstac/model/#methods_4","title":"Methods","text":""},{"location":"api/titiler/pgstac/model/#copy_4","title":"copy","text":"<pre><code>def copy(\n    self: 'Model',\n    *,\n    include: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    update: 'typing.Dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default include None Optional set or mapping specifying which fields to include in the copied model. None exclude None Optional set or mapping specifying which fields to exclude in the copied model. None update None Optional dictionary of field-value pairs to override field values in the copied model. None deep None If True, the values of fields that are Pydantic models will be deep copied. None <p>Returns:</p> Type Description None A copy of the model with included, excluded and updated fields as specified."},{"location":"api/titiler/pgstac/model/#dict_4","title":"dict","text":"<pre><code>def dict(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#json_4","title":"json","text":"<pre><code>def json(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    encoder: 'typing.Callable[[Any], Any] | None' = PydanticUndefined,\n    models_as_dict: 'bool' = PydanticUndefined,\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#model_copy_4","title":"model_copy","text":"<pre><code>def model_copy(\n    self: 'Model',\n    *,\n    update: 'dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#model_copy</p> <p>Returns a copy of the model.</p> <p>Parameters:</p> Name Type Description Default update None Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data. None deep None Set to <code>True</code> to make a deep copy of the model. None <p>Returns:</p> Type Description None New model instance."},{"location":"api/titiler/pgstac/model/#model_dump_4","title":"model_dump","text":"<pre><code>def model_dump(\n    self,\n    *,\n    mode: \"Literal['json', 'python'] | str\" = 'python',\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump</p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default mode None The mode in which <code>to_python</code> should run. If mode is 'json', the dictionary will only contain JSON serializable types. If mode is 'python', the dictionary may contain any Python objects. None include None A list of fields to include in the output. None exclude None A list of fields to exclude from the output. None by_alias None Whether to use the field's alias in the dictionary key if defined. None exclude_unset None Whether to exclude fields that are unset or None from the output. None exclude_defaults None Whether to exclude fields that are set to their default value from the output. None exclude_none None Whether to exclude fields that have a value of <code>None</code> from the output. None round_trip None Whether to enable serialization and deserialization round-trip support. None warnings None Whether to log warnings when invalid fields are encountered. None <p>Returns:</p> Type Description None A dictionary representation of the model."},{"location":"api/titiler/pgstac/model/#model_dump_json_4","title":"model_dump_json","text":"<pre><code>def model_dump_json(\n    self,\n    *,\n    indent: 'int | None' = None,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'str'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump_json</p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default indent None Indentation to use in the JSON output. If None is passed, the output will be compact. None include None Field(s) to include in the JSON output. Can take either a string or set of strings. None exclude None Field(s) to exclude from the JSON output. Can take either a string or set of strings. None by_alias None Whether to serialize using field aliases. None exclude_unset None Whether to exclude fields that have not been explicitly set. None exclude_defaults None Whether to exclude fields that have the default value. None exclude_none None Whether to exclude fields that have a value of <code>None</code>. None round_trip None Whether to use serialization/deserialization between JSON and class instance. None warnings None Whether to show any warnings that occurred during serialization. None <p>Returns:</p> Type Description None A JSON string representation of the model."},{"location":"api/titiler/pgstac/model/#model_post_init_4","title":"model_post_init","text":"<pre><code>def model_post_init(\n    self,\n    _BaseModel__context: 'Any'\n) -&gt; 'None'\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <p>This is useful if you want to do some validation that requires the entire model to be initialized.</p>"},{"location":"api/titiler/pgstac/model/#pgstacsearch","title":"PgSTACSearch","text":"<pre><code>class PgSTACSearch(\n    __pydantic_self__,\n    **data: 'Any'\n)\n</code></pre>"},{"location":"api/titiler/pgstac/model/#ancestors-in-mro_5","title":"Ancestors (in MRO)","text":"<ul> <li>pydantic.main.BaseModel</li> </ul>"},{"location":"api/titiler/pgstac/model/#descendants","title":"Descendants","text":"<ul> <li>titiler.pgstac.model.RegisterMosaic</li> </ul>"},{"location":"api/titiler/pgstac/model/#class-variables_5","title":"Class variables","text":"<pre><code>model_config\n</code></pre> <pre><code>model_fields\n</code></pre>"},{"location":"api/titiler/pgstac/model/#static-methods_5","title":"Static methods","text":""},{"location":"api/titiler/pgstac/model/#construct_5","title":"construct","text":"<pre><code>def construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#from_orm_5","title":"from_orm","text":"<pre><code>def from_orm(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#model_construct_5","title":"model_construct","text":"<pre><code>def model_construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if <code>Config.extra = 'allow'</code> was set since it adds all passed values</p> <p>Parameters:</p> Name Type Description Default _fields_set None The set of field names accepted for the Model instance. None values None Trusted or pre-validated data dictionary. None <p>Returns:</p> Type Description None A new instance of the <code>Model</code> class with validated data."},{"location":"api/titiler/pgstac/model/#model_json_schema_5","title":"model_json_schema","text":"<pre><code>def model_json_schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    schema_generator: 'type[GenerateJsonSchema]' = &lt;class 'pydantic.json_schema.GenerateJsonSchema'&gt;,\n    mode: 'JsonSchemaMode' = 'validation'\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default by_alias None Whether to use attribute aliases or not. None ref_template None The reference template. None schema_generator None To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications None mode None The mode in which to generate the schema. None <p>Returns:</p> Type Description None The JSON schema for the given model class."},{"location":"api/titiler/pgstac/model/#model_parametrized_name_5","title":"model_parametrized_name","text":"<pre><code>def model_parametrized_name(\n    params: 'tuple[type[Any], ...]'\n) -&gt; 'str'\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default params None Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>. None <p>Returns:</p> Type Description None String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables. <p>Raises:</p> Type Description TypeError Raised when trying to generate concrete names for non-generic models."},{"location":"api/titiler/pgstac/model/#model_rebuild_5","title":"model_rebuild","text":"<pre><code>def model_rebuild(\n    *,\n    force: 'bool' = False,\n    raise_errors: 'bool' = True,\n    _parent_namespace_depth: 'int' = 2,\n    _types_namespace: 'dict[str, Any] | None' = None\n) -&gt; 'bool | None'\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default force None Whether to force the rebuilding of the model schema, defaults to <code>False</code>. None raise_errors None Whether to raise errors, defaults to <code>True</code>. None _parent_namespace_depth None The depth level of the parent namespace, defaults to 2. None _types_namespace None The types namespace, defaults to <code>None</code>. None <p>Returns:</p> Type Description None Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>."},{"location":"api/titiler/pgstac/model/#model_validate_5","title":"model_validate","text":"<pre><code>def model_validate(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    from_attributes: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default obj None The object to validate. None strict None Whether to raise an exception on invalid fields. None from_attributes None Whether to extract data from object attributes. None context None Additional context to pass to the validator. None <p>Returns:</p> Type Description None The validated model instance. <p>Raises:</p> Type Description ValidationError If the object could not be validated."},{"location":"api/titiler/pgstac/model/#model_validate_json_5","title":"model_validate_json","text":"<pre><code>def model_validate_json(\n    json_data: 'str | bytes | bytearray',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default json_data None The JSON data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model. <p>Raises:</p> Type Description ValueError If <code>json_data</code> is not a JSON string."},{"location":"api/titiler/pgstac/model/#model_validate_strings_5","title":"model_validate_strings","text":"<pre><code>def model_validate_strings(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given object contains string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default obj None The object contains string data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model."},{"location":"api/titiler/pgstac/model/#parse_file_5","title":"parse_file","text":"<pre><code>def parse_file(\n    path: 'str | Path',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#parse_obj_5","title":"parse_obj","text":"<pre><code>def parse_obj(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#parse_raw_5","title":"parse_raw","text":"<pre><code>def parse_raw(\n    b: 'str | bytes',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#schema_5","title":"schema","text":"<pre><code>def schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}'\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#schema_json_5","title":"schema_json","text":"<pre><code>def schema_json(\n    *,\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#update_forward_refs_5","title":"update_forward_refs","text":"<pre><code>def update_forward_refs(\n    **localns: 'Any'\n) -&gt; 'None'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#validate_5","title":"validate","text":"<pre><code>def validate(\n    value: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#validate_bbox","title":"validate_bbox","text":"<pre><code>def validate_bbox(\n    v: Union[Tuple[float, float, float, float], Tuple[float, float, float, float, float, float]]\n)\n</code></pre> <p>Validate BBOX.</p>"},{"location":"api/titiler/pgstac/model/#validate_datetime","title":"validate_datetime","text":"<pre><code>def validate_datetime(\n    v\n)\n</code></pre> <p>Pgstac does not require the base validator for datetime.</p>"},{"location":"api/titiler/pgstac/model/#validate_query_fields","title":"validate_query_fields","text":"<pre><code>def validate_query_fields(\n    values: Dict\n) -&gt; Dict\n</code></pre> <p>Pgstac does not require the base validator for query fields.</p>"},{"location":"api/titiler/pgstac/model/#validate_spatial","title":"validate_spatial","text":"<pre><code>def validate_spatial(\n    v: Optional[Annotated[Union[geojson_pydantic.geometries.Point, geojson_pydantic.geometries.MultiPoint, geojson_pydantic.geometries.LineString, geojson_pydantic.geometries.MultiLineString, geojson_pydantic.geometries.Polygon, geojson_pydantic.geometries.MultiPolygon, geojson_pydantic.geometries.GeometryCollection], FieldInfo(annotation=NoneType, required=True, discriminator='type')]],\n    info: pydantic_core.core_schema.ValidationInfo\n)\n</code></pre> <p>Make sure bbox is not used with Intersects.</p>"},{"location":"api/titiler/pgstac/model/#instance-variables_5","title":"Instance variables","text":"<pre><code>model_computed_fields\n</code></pre> <p>Get the computed fields of this model instance.</p> <pre><code>model_extra\n</code></pre> <p>Get extra fields set during validation.</p> <pre><code>model_fields_set\n</code></pre> <p>Returns the set of fields that have been set on this model instance.</p>"},{"location":"api/titiler/pgstac/model/#methods_5","title":"Methods","text":""},{"location":"api/titiler/pgstac/model/#copy_5","title":"copy","text":"<pre><code>def copy(\n    self: 'Model',\n    *,\n    include: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    update: 'typing.Dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default include None Optional set or mapping specifying which fields to include in the copied model. None exclude None Optional set or mapping specifying which fields to exclude in the copied model. None update None Optional dictionary of field-value pairs to override field values in the copied model. None deep None If True, the values of fields that are Pydantic models will be deep copied. None <p>Returns:</p> Type Description None A copy of the model with included, excluded and updated fields as specified."},{"location":"api/titiler/pgstac/model/#dict_5","title":"dict","text":"<pre><code>def dict(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#json_5","title":"json","text":"<pre><code>def json(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    encoder: 'typing.Callable[[Any], Any] | None' = PydanticUndefined,\n    models_as_dict: 'bool' = PydanticUndefined,\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#model_copy_5","title":"model_copy","text":"<pre><code>def model_copy(\n    self: 'Model',\n    *,\n    update: 'dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#model_copy</p> <p>Returns a copy of the model.</p> <p>Parameters:</p> Name Type Description Default update None Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data. None deep None Set to <code>True</code> to make a deep copy of the model. None <p>Returns:</p> Type Description None New model instance."},{"location":"api/titiler/pgstac/model/#model_dump_5","title":"model_dump","text":"<pre><code>def model_dump(\n    self,\n    *,\n    mode: \"Literal['json', 'python'] | str\" = 'python',\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump</p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default mode None The mode in which <code>to_python</code> should run. If mode is 'json', the dictionary will only contain JSON serializable types. If mode is 'python', the dictionary may contain any Python objects. None include None A list of fields to include in the output. None exclude None A list of fields to exclude from the output. None by_alias None Whether to use the field's alias in the dictionary key if defined. None exclude_unset None Whether to exclude fields that are unset or None from the output. None exclude_defaults None Whether to exclude fields that are set to their default value from the output. None exclude_none None Whether to exclude fields that have a value of <code>None</code> from the output. None round_trip None Whether to enable serialization and deserialization round-trip support. None warnings None Whether to log warnings when invalid fields are encountered. None <p>Returns:</p> Type Description None A dictionary representation of the model."},{"location":"api/titiler/pgstac/model/#model_dump_json_5","title":"model_dump_json","text":"<pre><code>def model_dump_json(\n    self,\n    *,\n    indent: 'int | None' = None,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'str'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump_json</p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default indent None Indentation to use in the JSON output. If None is passed, the output will be compact. None include None Field(s) to include in the JSON output. Can take either a string or set of strings. None exclude None Field(s) to exclude from the JSON output. Can take either a string or set of strings. None by_alias None Whether to serialize using field aliases. None exclude_unset None Whether to exclude fields that have not been explicitly set. None exclude_defaults None Whether to exclude fields that have the default value. None exclude_none None Whether to exclude fields that have a value of <code>None</code>. None round_trip None Whether to use serialization/deserialization between JSON and class instance. None warnings None Whether to show any warnings that occurred during serialization. None <p>Returns:</p> Type Description None A JSON string representation of the model."},{"location":"api/titiler/pgstac/model/#model_post_init_5","title":"model_post_init","text":"<pre><code>def model_post_init(\n    self,\n    _BaseModel__context: 'Any'\n) -&gt; 'None'\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <p>This is useful if you want to do some validation that requires the entire model to be initialized.</p>"},{"location":"api/titiler/pgstac/model/#registermosaic","title":"RegisterMosaic","text":"<pre><code>class RegisterMosaic(\n    __pydantic_self__,\n    **data: 'Any'\n)\n</code></pre>"},{"location":"api/titiler/pgstac/model/#ancestors-in-mro_6","title":"Ancestors (in MRO)","text":"<ul> <li>titiler.pgstac.model.PgSTACSearch</li> <li>pydantic.main.BaseModel</li> </ul>"},{"location":"api/titiler/pgstac/model/#class-variables_6","title":"Class variables","text":"<pre><code>model_config\n</code></pre> <pre><code>model_fields\n</code></pre>"},{"location":"api/titiler/pgstac/model/#static-methods_6","title":"Static methods","text":""},{"location":"api/titiler/pgstac/model/#construct_6","title":"construct","text":"<pre><code>def construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#from_orm_6","title":"from_orm","text":"<pre><code>def from_orm(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#model_construct_6","title":"model_construct","text":"<pre><code>def model_construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if <code>Config.extra = 'allow'</code> was set since it adds all passed values</p> <p>Parameters:</p> Name Type Description Default _fields_set None The set of field names accepted for the Model instance. None values None Trusted or pre-validated data dictionary. None <p>Returns:</p> Type Description None A new instance of the <code>Model</code> class with validated data."},{"location":"api/titiler/pgstac/model/#model_json_schema_6","title":"model_json_schema","text":"<pre><code>def model_json_schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    schema_generator: 'type[GenerateJsonSchema]' = &lt;class 'pydantic.json_schema.GenerateJsonSchema'&gt;,\n    mode: 'JsonSchemaMode' = 'validation'\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default by_alias None Whether to use attribute aliases or not. None ref_template None The reference template. None schema_generator None To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications None mode None The mode in which to generate the schema. None <p>Returns:</p> Type Description None The JSON schema for the given model class."},{"location":"api/titiler/pgstac/model/#model_parametrized_name_6","title":"model_parametrized_name","text":"<pre><code>def model_parametrized_name(\n    params: 'tuple[type[Any], ...]'\n) -&gt; 'str'\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default params None Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>. None <p>Returns:</p> Type Description None String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables. <p>Raises:</p> Type Description TypeError Raised when trying to generate concrete names for non-generic models."},{"location":"api/titiler/pgstac/model/#model_rebuild_6","title":"model_rebuild","text":"<pre><code>def model_rebuild(\n    *,\n    force: 'bool' = False,\n    raise_errors: 'bool' = True,\n    _parent_namespace_depth: 'int' = 2,\n    _types_namespace: 'dict[str, Any] | None' = None\n) -&gt; 'bool | None'\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default force None Whether to force the rebuilding of the model schema, defaults to <code>False</code>. None raise_errors None Whether to raise errors, defaults to <code>True</code>. None _parent_namespace_depth None The depth level of the parent namespace, defaults to 2. None _types_namespace None The types namespace, defaults to <code>None</code>. None <p>Returns:</p> Type Description None Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>."},{"location":"api/titiler/pgstac/model/#model_validate_6","title":"model_validate","text":"<pre><code>def model_validate(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    from_attributes: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default obj None The object to validate. None strict None Whether to raise an exception on invalid fields. None from_attributes None Whether to extract data from object attributes. None context None Additional context to pass to the validator. None <p>Returns:</p> Type Description None The validated model instance. <p>Raises:</p> Type Description ValidationError If the object could not be validated."},{"location":"api/titiler/pgstac/model/#model_validate_json_6","title":"model_validate_json","text":"<pre><code>def model_validate_json(\n    json_data: 'str | bytes | bytearray',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default json_data None The JSON data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model. <p>Raises:</p> Type Description ValueError If <code>json_data</code> is not a JSON string."},{"location":"api/titiler/pgstac/model/#model_validate_strings_6","title":"model_validate_strings","text":"<pre><code>def model_validate_strings(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given object contains string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default obj None The object contains string data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model."},{"location":"api/titiler/pgstac/model/#parse_file_6","title":"parse_file","text":"<pre><code>def parse_file(\n    path: 'str | Path',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#parse_obj_6","title":"parse_obj","text":"<pre><code>def parse_obj(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#parse_raw_6","title":"parse_raw","text":"<pre><code>def parse_raw(\n    b: 'str | bytes',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#schema_6","title":"schema","text":"<pre><code>def schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}'\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#schema_json_6","title":"schema_json","text":"<pre><code>def schema_json(\n    *,\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#update_forward_refs_6","title":"update_forward_refs","text":"<pre><code>def update_forward_refs(\n    **localns: 'Any'\n) -&gt; 'None'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#validate_6","title":"validate","text":"<pre><code>def validate(\n    value: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#validate_bbox_1","title":"validate_bbox","text":"<pre><code>def validate_bbox(\n    v: Union[Tuple[float, float, float, float], Tuple[float, float, float, float, float, float]]\n)\n</code></pre> <p>Validate BBOX.</p>"},{"location":"api/titiler/pgstac/model/#validate_datetime_1","title":"validate_datetime","text":"<pre><code>def validate_datetime(\n    v\n)\n</code></pre> <p>Pgstac does not require the base validator for datetime.</p>"},{"location":"api/titiler/pgstac/model/#validate_query_fields_1","title":"validate_query_fields","text":"<pre><code>def validate_query_fields(\n    values: Dict\n) -&gt; Dict\n</code></pre> <p>Pgstac does not require the base validator for query fields.</p>"},{"location":"api/titiler/pgstac/model/#validate_spatial_1","title":"validate_spatial","text":"<pre><code>def validate_spatial(\n    v: Optional[Annotated[Union[geojson_pydantic.geometries.Point, geojson_pydantic.geometries.MultiPoint, geojson_pydantic.geometries.LineString, geojson_pydantic.geometries.MultiLineString, geojson_pydantic.geometries.Polygon, geojson_pydantic.geometries.MultiPolygon, geojson_pydantic.geometries.GeometryCollection], FieldInfo(annotation=NoneType, required=True, discriminator='type')]],\n    info: pydantic_core.core_schema.ValidationInfo\n)\n</code></pre> <p>Make sure bbox is not used with Intersects.</p>"},{"location":"api/titiler/pgstac/model/#instance-variables_6","title":"Instance variables","text":"<pre><code>model_computed_fields\n</code></pre> <p>Get the computed fields of this model instance.</p> <pre><code>model_extra\n</code></pre> <p>Get extra fields set during validation.</p> <pre><code>model_fields_set\n</code></pre> <p>Returns the set of fields that have been set on this model instance.</p>"},{"location":"api/titiler/pgstac/model/#methods_6","title":"Methods","text":""},{"location":"api/titiler/pgstac/model/#copy_6","title":"copy","text":"<pre><code>def copy(\n    self: 'Model',\n    *,\n    include: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    update: 'typing.Dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default include None Optional set or mapping specifying which fields to include in the copied model. None exclude None Optional set or mapping specifying which fields to exclude in the copied model. None update None Optional dictionary of field-value pairs to override field values in the copied model. None deep None If True, the values of fields that are Pydantic models will be deep copied. None <p>Returns:</p> Type Description None A copy of the model with included, excluded and updated fields as specified."},{"location":"api/titiler/pgstac/model/#dict_6","title":"dict","text":"<pre><code>def dict(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#json_6","title":"json","text":"<pre><code>def json(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    encoder: 'typing.Callable[[Any], Any] | None' = PydanticUndefined,\n    models_as_dict: 'bool' = PydanticUndefined,\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#model_copy_6","title":"model_copy","text":"<pre><code>def model_copy(\n    self: 'Model',\n    *,\n    update: 'dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#model_copy</p> <p>Returns a copy of the model.</p> <p>Parameters:</p> Name Type Description Default update None Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data. None deep None Set to <code>True</code> to make a deep copy of the model. None <p>Returns:</p> Type Description None New model instance."},{"location":"api/titiler/pgstac/model/#model_dump_6","title":"model_dump","text":"<pre><code>def model_dump(\n    self,\n    *,\n    mode: \"Literal['json', 'python'] | str\" = 'python',\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump</p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default mode None The mode in which <code>to_python</code> should run. If mode is 'json', the dictionary will only contain JSON serializable types. If mode is 'python', the dictionary may contain any Python objects. None include None A list of fields to include in the output. None exclude None A list of fields to exclude from the output. None by_alias None Whether to use the field's alias in the dictionary key if defined. None exclude_unset None Whether to exclude fields that are unset or None from the output. None exclude_defaults None Whether to exclude fields that are set to their default value from the output. None exclude_none None Whether to exclude fields that have a value of <code>None</code> from the output. None round_trip None Whether to enable serialization and deserialization round-trip support. None warnings None Whether to log warnings when invalid fields are encountered. None <p>Returns:</p> Type Description None A dictionary representation of the model."},{"location":"api/titiler/pgstac/model/#model_dump_json_6","title":"model_dump_json","text":"<pre><code>def model_dump_json(\n    self,\n    *,\n    indent: 'int | None' = None,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'str'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump_json</p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default indent None Indentation to use in the JSON output. If None is passed, the output will be compact. None include None Field(s) to include in the JSON output. Can take either a string or set of strings. None exclude None Field(s) to exclude from the JSON output. Can take either a string or set of strings. None by_alias None Whether to serialize using field aliases. None exclude_unset None Whether to exclude fields that have not been explicitly set. None exclude_defaults None Whether to exclude fields that have the default value. None exclude_none None Whether to exclude fields that have a value of <code>None</code>. None round_trip None Whether to use serialization/deserialization between JSON and class instance. None warnings None Whether to show any warnings that occurred during serialization. None <p>Returns:</p> Type Description None A JSON string representation of the model."},{"location":"api/titiler/pgstac/model/#model_post_init_6","title":"model_post_init","text":"<pre><code>def model_post_init(\n    self,\n    _BaseModel__context: 'Any'\n) -&gt; 'None'\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <p>This is useful if you want to do some validation that requires the entire model to be initialized.</p>"},{"location":"api/titiler/pgstac/model/#registerresponse","title":"RegisterResponse","text":"<pre><code>class RegisterResponse(\n    __pydantic_self__,\n    **data: 'Any'\n)\n</code></pre>"},{"location":"api/titiler/pgstac/model/#ancestors-in-mro_7","title":"Ancestors (in MRO)","text":"<ul> <li>pydantic.main.BaseModel</li> </ul>"},{"location":"api/titiler/pgstac/model/#class-variables_7","title":"Class variables","text":"<pre><code>model_config\n</code></pre> <pre><code>model_fields\n</code></pre>"},{"location":"api/titiler/pgstac/model/#static-methods_7","title":"Static methods","text":""},{"location":"api/titiler/pgstac/model/#construct_7","title":"construct","text":"<pre><code>def construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#from_orm_7","title":"from_orm","text":"<pre><code>def from_orm(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#model_construct_7","title":"model_construct","text":"<pre><code>def model_construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if <code>Config.extra = 'allow'</code> was set since it adds all passed values</p> <p>Parameters:</p> Name Type Description Default _fields_set None The set of field names accepted for the Model instance. None values None Trusted or pre-validated data dictionary. None <p>Returns:</p> Type Description None A new instance of the <code>Model</code> class with validated data."},{"location":"api/titiler/pgstac/model/#model_json_schema_7","title":"model_json_schema","text":"<pre><code>def model_json_schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    schema_generator: 'type[GenerateJsonSchema]' = &lt;class 'pydantic.json_schema.GenerateJsonSchema'&gt;,\n    mode: 'JsonSchemaMode' = 'validation'\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default by_alias None Whether to use attribute aliases or not. None ref_template None The reference template. None schema_generator None To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications None mode None The mode in which to generate the schema. None <p>Returns:</p> Type Description None The JSON schema for the given model class."},{"location":"api/titiler/pgstac/model/#model_parametrized_name_7","title":"model_parametrized_name","text":"<pre><code>def model_parametrized_name(\n    params: 'tuple[type[Any], ...]'\n) -&gt; 'str'\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default params None Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>. None <p>Returns:</p> Type Description None String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables. <p>Raises:</p> Type Description TypeError Raised when trying to generate concrete names for non-generic models."},{"location":"api/titiler/pgstac/model/#model_rebuild_7","title":"model_rebuild","text":"<pre><code>def model_rebuild(\n    *,\n    force: 'bool' = False,\n    raise_errors: 'bool' = True,\n    _parent_namespace_depth: 'int' = 2,\n    _types_namespace: 'dict[str, Any] | None' = None\n) -&gt; 'bool | None'\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default force None Whether to force the rebuilding of the model schema, defaults to <code>False</code>. None raise_errors None Whether to raise errors, defaults to <code>True</code>. None _parent_namespace_depth None The depth level of the parent namespace, defaults to 2. None _types_namespace None The types namespace, defaults to <code>None</code>. None <p>Returns:</p> Type Description None Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>."},{"location":"api/titiler/pgstac/model/#model_validate_7","title":"model_validate","text":"<pre><code>def model_validate(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    from_attributes: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default obj None The object to validate. None strict None Whether to raise an exception on invalid fields. None from_attributes None Whether to extract data from object attributes. None context None Additional context to pass to the validator. None <p>Returns:</p> Type Description None The validated model instance. <p>Raises:</p> Type Description ValidationError If the object could not be validated."},{"location":"api/titiler/pgstac/model/#model_validate_json_7","title":"model_validate_json","text":"<pre><code>def model_validate_json(\n    json_data: 'str | bytes | bytearray',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default json_data None The JSON data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model. <p>Raises:</p> Type Description ValueError If <code>json_data</code> is not a JSON string."},{"location":"api/titiler/pgstac/model/#model_validate_strings_7","title":"model_validate_strings","text":"<pre><code>def model_validate_strings(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given object contains string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default obj None The object contains string data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model."},{"location":"api/titiler/pgstac/model/#parse_file_7","title":"parse_file","text":"<pre><code>def parse_file(\n    path: 'str | Path',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#parse_obj_7","title":"parse_obj","text":"<pre><code>def parse_obj(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#parse_raw_7","title":"parse_raw","text":"<pre><code>def parse_raw(\n    b: 'str | bytes',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#schema_7","title":"schema","text":"<pre><code>def schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}'\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#schema_json_7","title":"schema_json","text":"<pre><code>def schema_json(\n    *,\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#update_forward_refs_7","title":"update_forward_refs","text":"<pre><code>def update_forward_refs(\n    **localns: 'Any'\n) -&gt; 'None'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#validate_7","title":"validate","text":"<pre><code>def validate(\n    value: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#instance-variables_7","title":"Instance variables","text":"<pre><code>model_computed_fields\n</code></pre> <p>Get the computed fields of this model instance.</p> <pre><code>model_extra\n</code></pre> <p>Get extra fields set during validation.</p> <pre><code>model_fields_set\n</code></pre> <p>Returns the set of fields that have been set on this model instance.</p>"},{"location":"api/titiler/pgstac/model/#methods_7","title":"Methods","text":""},{"location":"api/titiler/pgstac/model/#copy_7","title":"copy","text":"<pre><code>def copy(\n    self: 'Model',\n    *,\n    include: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    update: 'typing.Dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default include None Optional set or mapping specifying which fields to include in the copied model. None exclude None Optional set or mapping specifying which fields to exclude in the copied model. None update None Optional dictionary of field-value pairs to override field values in the copied model. None deep None If True, the values of fields that are Pydantic models will be deep copied. None <p>Returns:</p> Type Description None A copy of the model with included, excluded and updated fields as specified."},{"location":"api/titiler/pgstac/model/#dict_7","title":"dict","text":"<pre><code>def dict(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#json_7","title":"json","text":"<pre><code>def json(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    encoder: 'typing.Callable[[Any], Any] | None' = PydanticUndefined,\n    models_as_dict: 'bool' = PydanticUndefined,\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#model_copy_7","title":"model_copy","text":"<pre><code>def model_copy(\n    self: 'Model',\n    *,\n    update: 'dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#model_copy</p> <p>Returns a copy of the model.</p> <p>Parameters:</p> Name Type Description Default update None Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data. None deep None Set to <code>True</code> to make a deep copy of the model. None <p>Returns:</p> Type Description None New model instance."},{"location":"api/titiler/pgstac/model/#model_dump_7","title":"model_dump","text":"<pre><code>def model_dump(\n    self,\n    *,\n    mode: \"Literal['json', 'python'] | str\" = 'python',\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump</p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default mode None The mode in which <code>to_python</code> should run. If mode is 'json', the dictionary will only contain JSON serializable types. If mode is 'python', the dictionary may contain any Python objects. None include None A list of fields to include in the output. None exclude None A list of fields to exclude from the output. None by_alias None Whether to use the field's alias in the dictionary key if defined. None exclude_unset None Whether to exclude fields that are unset or None from the output. None exclude_defaults None Whether to exclude fields that are set to their default value from the output. None exclude_none None Whether to exclude fields that have a value of <code>None</code> from the output. None round_trip None Whether to enable serialization and deserialization round-trip support. None warnings None Whether to log warnings when invalid fields are encountered. None <p>Returns:</p> Type Description None A dictionary representation of the model."},{"location":"api/titiler/pgstac/model/#model_dump_json_7","title":"model_dump_json","text":"<pre><code>def model_dump_json(\n    self,\n    *,\n    indent: 'int | None' = None,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'str'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump_json</p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default indent None Indentation to use in the JSON output. If None is passed, the output will be compact. None include None Field(s) to include in the JSON output. Can take either a string or set of strings. None exclude None Field(s) to exclude from the JSON output. Can take either a string or set of strings. None by_alias None Whether to serialize using field aliases. None exclude_unset None Whether to exclude fields that have not been explicitly set. None exclude_defaults None Whether to exclude fields that have the default value. None exclude_none None Whether to exclude fields that have a value of <code>None</code>. None round_trip None Whether to use serialization/deserialization between JSON and class instance. None warnings None Whether to show any warnings that occurred during serialization. None <p>Returns:</p> Type Description None A JSON string representation of the model."},{"location":"api/titiler/pgstac/model/#model_post_init_7","title":"model_post_init","text":"<pre><code>def model_post_init(\n    self,\n    _BaseModel__context: 'Any'\n) -&gt; 'None'\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <p>This is useful if you want to do some validation that requires the entire model to be initialized.</p>"},{"location":"api/titiler/pgstac/model/#search","title":"Search","text":"<pre><code>class Search(\n    __pydantic_self__,\n    **data: 'Any'\n)\n</code></pre>"},{"location":"api/titiler/pgstac/model/#ancestors-in-mro_8","title":"Ancestors (in MRO)","text":"<ul> <li>pydantic.main.BaseModel</li> </ul>"},{"location":"api/titiler/pgstac/model/#class-variables_8","title":"Class variables","text":"<pre><code>model_config\n</code></pre> <pre><code>model_fields\n</code></pre>"},{"location":"api/titiler/pgstac/model/#static-methods_8","title":"Static methods","text":""},{"location":"api/titiler/pgstac/model/#construct_8","title":"construct","text":"<pre><code>def construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#from_orm_8","title":"from_orm","text":"<pre><code>def from_orm(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#model_construct_8","title":"model_construct","text":"<pre><code>def model_construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if <code>Config.extra = 'allow'</code> was set since it adds all passed values</p> <p>Parameters:</p> Name Type Description Default _fields_set None The set of field names accepted for the Model instance. None values None Trusted or pre-validated data dictionary. None <p>Returns:</p> Type Description None A new instance of the <code>Model</code> class with validated data."},{"location":"api/titiler/pgstac/model/#model_json_schema_8","title":"model_json_schema","text":"<pre><code>def model_json_schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    schema_generator: 'type[GenerateJsonSchema]' = &lt;class 'pydantic.json_schema.GenerateJsonSchema'&gt;,\n    mode: 'JsonSchemaMode' = 'validation'\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default by_alias None Whether to use attribute aliases or not. None ref_template None The reference template. None schema_generator None To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications None mode None The mode in which to generate the schema. None <p>Returns:</p> Type Description None The JSON schema for the given model class."},{"location":"api/titiler/pgstac/model/#model_parametrized_name_8","title":"model_parametrized_name","text":"<pre><code>def model_parametrized_name(\n    params: 'tuple[type[Any], ...]'\n) -&gt; 'str'\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default params None Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>. None <p>Returns:</p> Type Description None String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables. <p>Raises:</p> Type Description TypeError Raised when trying to generate concrete names for non-generic models."},{"location":"api/titiler/pgstac/model/#model_rebuild_8","title":"model_rebuild","text":"<pre><code>def model_rebuild(\n    *,\n    force: 'bool' = False,\n    raise_errors: 'bool' = True,\n    _parent_namespace_depth: 'int' = 2,\n    _types_namespace: 'dict[str, Any] | None' = None\n) -&gt; 'bool | None'\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default force None Whether to force the rebuilding of the model schema, defaults to <code>False</code>. None raise_errors None Whether to raise errors, defaults to <code>True</code>. None _parent_namespace_depth None The depth level of the parent namespace, defaults to 2. None _types_namespace None The types namespace, defaults to <code>None</code>. None <p>Returns:</p> Type Description None Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>."},{"location":"api/titiler/pgstac/model/#model_validate_8","title":"model_validate","text":"<pre><code>def model_validate(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    from_attributes: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default obj None The object to validate. None strict None Whether to raise an exception on invalid fields. None from_attributes None Whether to extract data from object attributes. None context None Additional context to pass to the validator. None <p>Returns:</p> Type Description None The validated model instance. <p>Raises:</p> Type Description ValidationError If the object could not be validated."},{"location":"api/titiler/pgstac/model/#model_validate_json_8","title":"model_validate_json","text":"<pre><code>def model_validate_json(\n    json_data: 'str | bytes | bytearray',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default json_data None The JSON data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model. <p>Raises:</p> Type Description ValueError If <code>json_data</code> is not a JSON string."},{"location":"api/titiler/pgstac/model/#model_validate_strings_8","title":"model_validate_strings","text":"<pre><code>def model_validate_strings(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given object contains string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default obj None The object contains string data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model."},{"location":"api/titiler/pgstac/model/#parse_file_8","title":"parse_file","text":"<pre><code>def parse_file(\n    path: 'str | Path',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#parse_obj_8","title":"parse_obj","text":"<pre><code>def parse_obj(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#parse_raw_8","title":"parse_raw","text":"<pre><code>def parse_raw(\n    b: 'str | bytes',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#schema_8","title":"schema","text":"<pre><code>def schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}'\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#schema_json_8","title":"schema_json","text":"<pre><code>def schema_json(\n    *,\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#update_forward_refs_8","title":"update_forward_refs","text":"<pre><code>def update_forward_refs(\n    **localns: 'Any'\n) -&gt; 'None'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#validate_8","title":"validate","text":"<pre><code>def validate(\n    value: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#validate_metadata","title":"validate_metadata","text":"<pre><code>def validate_metadata(\n    v\n)\n</code></pre> <p>Set SearchType.search when not present in metadata.</p>"},{"location":"api/titiler/pgstac/model/#instance-variables_8","title":"Instance variables","text":"<pre><code>model_computed_fields\n</code></pre> <p>Get the computed fields of this model instance.</p> <pre><code>model_extra\n</code></pre> <p>Get extra fields set during validation.</p> <pre><code>model_fields_set\n</code></pre> <p>Returns the set of fields that have been set on this model instance.</p>"},{"location":"api/titiler/pgstac/model/#methods_8","title":"Methods","text":""},{"location":"api/titiler/pgstac/model/#copy_8","title":"copy","text":"<pre><code>def copy(\n    self: 'Model',\n    *,\n    include: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    update: 'typing.Dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default include None Optional set or mapping specifying which fields to include in the copied model. None exclude None Optional set or mapping specifying which fields to exclude in the copied model. None update None Optional dictionary of field-value pairs to override field values in the copied model. None deep None If True, the values of fields that are Pydantic models will be deep copied. None <p>Returns:</p> Type Description None A copy of the model with included, excluded and updated fields as specified."},{"location":"api/titiler/pgstac/model/#dict_8","title":"dict","text":"<pre><code>def dict(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#json_8","title":"json","text":"<pre><code>def json(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    encoder: 'typing.Callable[[Any], Any] | None' = PydanticUndefined,\n    models_as_dict: 'bool' = PydanticUndefined,\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/model/#model_copy_8","title":"model_copy","text":"<pre><code>def model_copy(\n    self: 'Model',\n    *,\n    update: 'dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#model_copy</p> <p>Returns a copy of the model.</p> <p>Parameters:</p> Name Type Description Default update None Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data. None deep None Set to <code>True</code> to make a deep copy of the model. None <p>Returns:</p> Type Description None New model instance."},{"location":"api/titiler/pgstac/model/#model_dump_8","title":"model_dump","text":"<pre><code>def model_dump(\n    self,\n    *,\n    mode: \"Literal['json', 'python'] | str\" = 'python',\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump</p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default mode None The mode in which <code>to_python</code> should run. If mode is 'json', the dictionary will only contain JSON serializable types. If mode is 'python', the dictionary may contain any Python objects. None include None A list of fields to include in the output. None exclude None A list of fields to exclude from the output. None by_alias None Whether to use the field's alias in the dictionary key if defined. None exclude_unset None Whether to exclude fields that are unset or None from the output. None exclude_defaults None Whether to exclude fields that are set to their default value from the output. None exclude_none None Whether to exclude fields that have a value of <code>None</code> from the output. None round_trip None Whether to enable serialization and deserialization round-trip support. None warnings None Whether to log warnings when invalid fields are encountered. None <p>Returns:</p> Type Description None A dictionary representation of the model."},{"location":"api/titiler/pgstac/model/#model_dump_json_8","title":"model_dump_json","text":"<pre><code>def model_dump_json(\n    self,\n    *,\n    indent: 'int | None' = None,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'str'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump_json</p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default indent None Indentation to use in the JSON output. If None is passed, the output will be compact. None include None Field(s) to include in the JSON output. Can take either a string or set of strings. None exclude None Field(s) to exclude from the JSON output. Can take either a string or set of strings. None by_alias None Whether to serialize using field aliases. None exclude_unset None Whether to exclude fields that have not been explicitly set. None exclude_defaults None Whether to exclude fields that have the default value. None exclude_none None Whether to exclude fields that have a value of <code>None</code>. None round_trip None Whether to use serialization/deserialization between JSON and class instance. None warnings None Whether to show any warnings that occurred during serialization. None <p>Returns:</p> Type Description None A JSON string representation of the model."},{"location":"api/titiler/pgstac/model/#model_post_init_8","title":"model_post_init","text":"<pre><code>def model_post_init(\n    self,\n    _BaseModel__context: 'Any'\n) -&gt; 'None'\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <p>This is useful if you want to do some validation that requires the entire model to be initialized.</p>"},{"location":"api/titiler/pgstac/mosaic/","title":"Module titiler.pgstac.mosaic","text":"<p>TiTiler.PgSTAC custom Mosaic Backend and Custom STACReader.</p> <p>None</p>"},{"location":"api/titiler/pgstac/mosaic/#variables","title":"Variables","text":"<pre><code>WGS84_CRS\n</code></pre> <pre><code>cache_config\n</code></pre> <pre><code>retry_config\n</code></pre>"},{"location":"api/titiler/pgstac/mosaic/#classes","title":"Classes","text":""},{"location":"api/titiler/pgstac/mosaic/#customstacreader","title":"CustomSTACReader","text":"<pre><code>class CustomSTACReader(\n    input: Dict[str, Any],\n    tms: morecantile.models.TileMatrixSet = &lt;TileMatrixSet title='Google Maps Compatible for the World' id='WebMercatorQuad' crs='http://www.opengis.net/def/crs/EPSG/0/3857&gt;,\n    minzoom: int = NOTHING,\n    maxzoom: int = NOTHING,\n    reader: Type[rio_tiler.io.base.BaseReader] = &lt;class 'rio_tiler.io.rasterio.Reader'&gt;,\n    reader_options: Dict = NOTHING,\n    ctx: Any = &lt;class 'rasterio.env.Env'&gt;\n)\n</code></pre>"},{"location":"api/titiler/pgstac/mosaic/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.io.base.MultiBaseReader</li> <li>rio_tiler.io.base.SpatialMixin</li> </ul>"},{"location":"api/titiler/pgstac/mosaic/#instance-variables","title":"Instance variables","text":"<pre><code>geographic_bounds\n</code></pre> <p>Return dataset bounds in geographic_crs.</p>"},{"location":"api/titiler/pgstac/mosaic/#methods","title":"Methods","text":""},{"location":"api/titiler/pgstac/mosaic/#feature","title":"feature","text":"<pre><code>def feature(\n    self,\n    shape: Dict,\n    assets: Union[Sequence[str], str] = None,\n    expression: Optional[str] = None,\n    asset_indexes: Optional[Dict[str, Union[Sequence[int], int]]] = None,\n    asset_as_band: bool = False,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read and merge parts defined by geojson feature from multiple assets.</p> <p>Parameters:</p> Name Type Description Default shape dict Valid GeoJSON feature. None assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None kwargs optional Options to forward to the <code>self.reader.feature</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/titiler/pgstac/mosaic/#info","title":"info","text":"<pre><code>def info(\n    self,\n    assets: Union[Sequence[str], str] = None,\n    **kwargs: Any\n) -&gt; Dict[str, rio_tiler.models.Info]\n</code></pre> <p>Return metadata from multiple assets.</p> <p>Parameters:</p> Name Type Description Default assets sequence of str or str assets to fetch info from. Required keyword argument. None <p>Returns:</p> Type Description dict Multiple assets info in form of {\"asset1\": rio_tile.models.Info}."},{"location":"api/titiler/pgstac/mosaic/#merged_statistics","title":"merged_statistics","text":"<pre><code>def merged_statistics(\n    self,\n    assets: Union[Sequence[str], str] = None,\n    expression: Optional[str] = None,\n    asset_indexes: Optional[Dict[str, Union[Sequence[int], int]]] = None,\n    categorical: bool = False,\n    categories: Optional[List[float]] = None,\n    percentiles: Optional[List[int]] = None,\n    hist_options: Optional[Dict] = None,\n    max_size: int = 1024,\n    **kwargs: Any\n) -&gt; Dict[str, rio_tiler.models.BandStatistics]\n</code></pre> <p>Return array statistics for multiple assets.</p> <p>Parameters:</p> Name Type Description Default assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None categorical bool treat input data as categorical data. Defaults to False. False categories list of numbers list of categories to return value for. None percentiles list of numbers list of percentile values to calculate. Defaults to <code>[2, 98]</code>. <code>[2, 98]</code> hist_options dict Options to forward to numpy.histogram function. None max_size int Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio. Defaults to 1024. 1024 kwargs optional Options to forward to the <code>self.preview</code> method. None <p>Returns:</p> Type Description Dict[str, rio_tiler.models.BandStatistics] bands statistics."},{"location":"api/titiler/pgstac/mosaic/#parse_expression","title":"parse_expression","text":"<pre><code>def parse_expression(\n    self,\n    expression: str,\n    asset_as_band: bool = False\n) -&gt; Tuple\n</code></pre> <p>Parse rio-tiler band math expression.</p>"},{"location":"api/titiler/pgstac/mosaic/#part","title":"part","text":"<pre><code>def part(\n    self,\n    bbox: Tuple[float, float, float, float],\n    assets: Union[Sequence[str], str] = None,\n    expression: Optional[str] = None,\n    asset_indexes: Optional[Dict[str, Union[Sequence[int], int]]] = None,\n    asset_as_band: bool = False,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read and merge parts from multiple assets.</p> <p>Parameters:</p> Name Type Description Default bbox tuple Output bounds (left, bottom, right, top) in target crs. None assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None kwargs optional Options to forward to the <code>self.reader.part</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/titiler/pgstac/mosaic/#point","title":"point","text":"<pre><code>def point(\n    self,\n    lon: float,\n    lat: float,\n    assets: Union[Sequence[str], str] = None,\n    expression: Optional[str] = None,\n    asset_indexes: Optional[Dict[str, Union[Sequence[int], int]]] = None,\n    asset_as_band: bool = False,\n    **kwargs: Any\n) -&gt; rio_tiler.models.PointData\n</code></pre> <p>Read pixel value from multiple assets.</p> <p>Parameters:</p> Name Type Description Default lon float Longitude. None lat float Latitude. None assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None kwargs optional Options to forward to the <code>self.reader.point</code> method. None <p>Returns:</p> Type Description None PointData"},{"location":"api/titiler/pgstac/mosaic/#preview","title":"preview","text":"<pre><code>def preview(\n    self,\n    assets: Union[Sequence[str], str] = None,\n    expression: Optional[str] = None,\n    asset_indexes: Optional[Dict[str, Union[Sequence[int], int]]] = None,\n    asset_as_band: bool = False,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read and merge previews from multiple assets.</p> <p>Parameters:</p> Name Type Description Default assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None kwargs optional Options to forward to the <code>self.reader.preview</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/titiler/pgstac/mosaic/#statistics","title":"statistics","text":"<pre><code>def statistics(\n    self,\n    assets: Union[Sequence[str], str] = None,\n    asset_indexes: Optional[Dict[str, Union[Sequence[int], int]]] = None,\n    asset_expression: Optional[Dict[str, str]] = None,\n    **kwargs: Any\n) -&gt; Dict[str, Dict[str, rio_tiler.models.BandStatistics]]\n</code></pre> <p>Return array statistics for multiple assets.</p> <p>Parameters:</p> Name Type Description Default assets sequence of str or str assets to fetch info from. None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None asset_expression dict rio-tiler expression for each asset (e.g. {\"asset1\": \"b1/b2+b3\", \"asset2\": ...}). None kwargs optional Options to forward to the <code>self.reader.statistics</code> method. None <p>Returns:</p> Type Description dict Multiple assets statistics in form of {\"asset1\": {\"1\": rio_tiler.models.BandStatistics, ...}}."},{"location":"api/titiler/pgstac/mosaic/#tile","title":"tile","text":"<pre><code>def tile(\n    self,\n    tile_x: int,\n    tile_y: int,\n    tile_z: int,\n    assets: Union[Sequence[str], str] = None,\n    expression: Optional[str] = None,\n    asset_indexes: Optional[Dict[str, Union[Sequence[int], int]]] = None,\n    asset_as_band: bool = False,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read and merge Wep Map tiles from multiple assets.</p> <p>Parameters:</p> Name Type Description Default tile_x int Tile's horizontal index. None tile_y int Tile's vertical index. None tile_z int Tile's zoom level index. None assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None kwargs optional Options to forward to the <code>self.reader.tile</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/titiler/pgstac/mosaic/#tile_exists","title":"tile_exists","text":"<pre><code>def tile_exists(\n    self,\n    tile_x: int,\n    tile_y: int,\n    tile_z: int\n) -&gt; bool\n</code></pre> <p>Check if a tile intersects the dataset bounds.</p> <p>Parameters:</p> Name Type Description Default tile_x int Tile's horizontal index. None tile_y int Tile's vertical index. None tile_z int Tile's zoom level index. None <p>Returns:</p> Type Description bool True if the tile intersects the dataset bounds."},{"location":"api/titiler/pgstac/mosaic/#pgstacbackend","title":"PGSTACBackend","text":"<pre><code>class PGSTACBackend(\n    input: str,\n    pool: psycopg_pool.pool.ConnectionPool,\n    tms: morecantile.models.TileMatrixSet = &lt;TileMatrixSet title='Google Maps Compatible for the World' id='WebMercatorQuad' crs='http://www.opengis.net/def/crs/EPSG/0/3857&gt;,\n    minzoom: int = NOTHING,\n    maxzoom: int = NOTHING,\n    reader_options: Dict = NOTHING,\n    bounds: Tuple[float, float, float, float] = (-180, -90, 180, 90),\n    crs: rasterio.crs.CRS = CRS.from_epsg(4326),\n    geographic_crs: rasterio.crs.CRS = CRS.from_epsg(4326)\n)\n</code></pre>"},{"location":"api/titiler/pgstac/mosaic/#ancestors-in-mro_1","title":"Ancestors (in MRO)","text":"<ul> <li>cogeo_mosaic.backends.base.BaseBackend</li> <li>rio_tiler.io.base.BaseReader</li> <li>rio_tiler.io.base.SpatialMixin</li> </ul>"},{"location":"api/titiler/pgstac/mosaic/#instance-variables_1","title":"Instance variables","text":"<pre><code>center\n</code></pre> <p>Return center from the mosaic definition.</p> <pre><code>geographic_bounds\n</code></pre> <p>Return dataset bounds in geographic_crs.</p> <pre><code>mosaicid\n</code></pre> <p>Return sha224 id of the mosaicjson document.</p> <pre><code>quadkey_zoom\n</code></pre> <p>Return Quadkey zoom property.</p>"},{"location":"api/titiler/pgstac/mosaic/#methods_1","title":"Methods","text":""},{"location":"api/titiler/pgstac/mosaic/#assets_for_bbox","title":"assets_for_bbox","text":"<pre><code>def assets_for_bbox(\n    self,\n    xmin: float,\n    ymin: float,\n    xmax: float,\n    ymax: float,\n    coord_crs: rasterio.crs.CRS = CRS.from_epsg(4326),\n    **kwargs: Any\n) -&gt; List[Dict]\n</code></pre> <p>Retrieve assets for bbox.</p>"},{"location":"api/titiler/pgstac/mosaic/#assets_for_point","title":"assets_for_point","text":"<pre><code>def assets_for_point(\n    self,\n    lng: float,\n    lat: float,\n    coord_crs: rasterio.crs.CRS = CRS.from_epsg(4326),\n    **kwargs: Any\n) -&gt; List[Dict]\n</code></pre> <p>Retrieve assets for point.</p>"},{"location":"api/titiler/pgstac/mosaic/#assets_for_tile","title":"assets_for_tile","text":"<pre><code>def assets_for_tile(\n    self,\n    x: int,\n    y: int,\n    z: int,\n    **kwargs: Any\n) -&gt; List[Dict]\n</code></pre> <p>Retrieve assets for tile.</p>"},{"location":"api/titiler/pgstac/mosaic/#feature_1","title":"feature","text":"<pre><code>def feature(\n    self,\n    shape: Dict,\n    dst_crs: Optional[rasterio.crs.CRS] = None,\n    shape_crs: rasterio.crs.CRS = CRS.from_epsg(4326),\n    max_size: int = 1024,\n    reverse: bool = False,\n    scan_limit: Optional[int] = None,\n    items_limit: Optional[int] = None,\n    time_limit: Optional[int] = None,\n    exitwhenfull: Optional[bool] = None,\n    skipcovered: Optional[bool] = None,\n    **kwargs: Any\n) -&gt; Tuple[rio_tiler.models.ImageData, List[str]]\n</code></pre> <p>Create an Image from multiple items for a GeoJSON feature.</p>"},{"location":"api/titiler/pgstac/mosaic/#find_quadkeys","title":"find_quadkeys","text":"<pre><code>def find_quadkeys(\n    self,\n    tile: morecantile.commons.Tile,\n    quadkey_zoom: int\n) -&gt; List[str]\n</code></pre> <p>Find quadkeys at desired zoom for tile</p> <p>Parameters:</p> Name Type Description Default tile morecantile.Tile Input tile to use when searching for quadkeys None quadkey_zoom int Zoom level None <p>Returns:</p> Type Description list List[str] of quadkeys"},{"location":"api/titiler/pgstac/mosaic/#get_assets","title":"get_assets","text":"<pre><code>def get_assets(\n    *args: Any,\n    **kwargs: Any\n)\n</code></pre>"},{"location":"api/titiler/pgstac/mosaic/#info_1","title":"info","text":"<pre><code>def info(\n    self,\n    quadkeys: bool = False\n) -&gt; cogeo_mosaic.models.Info\n</code></pre> <p>Mosaic info.</p>"},{"location":"api/titiler/pgstac/mosaic/#part_1","title":"part","text":"<pre><code>def part(\n    self,\n    bbox: Tuple[float, float, float, float],\n    dst_crs: Optional[rasterio.crs.CRS] = None,\n    bounds_crs: rasterio.crs.CRS = CRS.from_epsg(4326),\n    reverse: bool = False,\n    scan_limit: Optional[int] = None,\n    items_limit: Optional[int] = None,\n    time_limit: Optional[int] = None,\n    exitwhenfull: Optional[bool] = None,\n    skipcovered: Optional[bool] = None,\n    **kwargs: Any\n) -&gt; Tuple[rio_tiler.models.ImageData, List[str]]\n</code></pre> <p>Create an Image from multiple items for a bbox.</p>"},{"location":"api/titiler/pgstac/mosaic/#point_1","title":"point","text":"<pre><code>def point(\n    self,\n    lon: float,\n    lat: float,\n    coord_crs: rasterio.crs.CRS = CRS.from_epsg(4326),\n    reverse: bool = False,\n    scan_limit: Optional[int] = None,\n    items_limit: Optional[int] = None,\n    time_limit: Optional[int] = None,\n    exitwhenfull: Optional[bool] = None,\n    skipcovered: Optional[bool] = None,\n    **kwargs: Any\n) -&gt; List\n</code></pre> <p>Get Point value from multiple observation.</p>"},{"location":"api/titiler/pgstac/mosaic/#preview_1","title":"preview","text":"<pre><code>def preview(\n    self\n)\n</code></pre> <p>PlaceHolder for BaseReader.preview.</p>"},{"location":"api/titiler/pgstac/mosaic/#statistics_1","title":"statistics","text":"<pre><code>def statistics(\n    self\n)\n</code></pre> <p>PlaceHolder for BaseReader.statistics.</p>"},{"location":"api/titiler/pgstac/mosaic/#tile_1","title":"tile","text":"<pre><code>def tile(\n    self,\n    tile_x: int,\n    tile_y: int,\n    tile_z: int,\n    reverse: bool = False,\n    scan_limit: Optional[int] = None,\n    items_limit: Optional[int] = None,\n    time_limit: Optional[int] = None,\n    exitwhenfull: Optional[bool] = None,\n    skipcovered: Optional[bool] = None,\n    **kwargs: Any\n) -&gt; Tuple[rio_tiler.models.ImageData, List[str]]\n</code></pre> <p>Get Tile from multiple observation.</p>"},{"location":"api/titiler/pgstac/mosaic/#tile_exists_1","title":"tile_exists","text":"<pre><code>def tile_exists(\n    self,\n    tile_x: int,\n    tile_y: int,\n    tile_z: int\n) -&gt; bool\n</code></pre> <p>Check if a tile intersects the dataset bounds.</p> <p>Parameters:</p> Name Type Description Default tile_x int Tile's horizontal index. None tile_y int Tile's vertical index. None tile_z int Tile's zoom level index. None <p>Returns:</p> Type Description bool True if the tile intersects the dataset bounds."},{"location":"api/titiler/pgstac/mosaic/#update","title":"update","text":"<pre><code>def update(\n    self\n) -&gt; None\n</code></pre> <p>We overwrite the default method.</p>"},{"location":"api/titiler/pgstac/mosaic/#write","title":"write","text":"<pre><code>def write(\n    self,\n    overwrite: bool = True\n) -&gt; None\n</code></pre> <p>This method is not used but is required by the abstract class.</p>"},{"location":"api/titiler/pgstac/reader/","title":"Module titiler.pgstac.reader","text":"<p>Custom STAC reader.</p> <p>None</p>"},{"location":"api/titiler/pgstac/reader/#variables","title":"Variables","text":"<pre><code>DEFAULT_VALID_TYPE\n</code></pre> <pre><code>WGS84_CRS\n</code></pre>"},{"location":"api/titiler/pgstac/reader/#classes","title":"Classes","text":""},{"location":"api/titiler/pgstac/reader/#pgstacreader","title":"PgSTACReader","text":"<pre><code>class PgSTACReader(\n    input: pystac.item.Item,\n    tms: morecantile.models.TileMatrixSet = &lt;TileMatrixSet title='Google Maps Compatible for the World' id='WebMercatorQuad' crs='http://www.opengis.net/def/crs/EPSG/0/3857&gt;,\n    minzoom: int = NOTHING,\n    maxzoom: int = NOTHING,\n    geographic_crs: rasterio.crs.CRS = CRS.from_epsg(4326),\n    include_assets: Optional[Set[str]] = None,\n    exclude_assets: Optional[Set[str]] = None,\n    include_asset_types: Set[str] = {'image/vnd.stac.geotiff; cloud-optimized=true', 'image/tiff; profile=cloud-optimized; application=geotiff', 'image/tiff; application=geotiff; profile=cloud-optimized', 'application/x-hdf', 'image/tiff; application=geotiff', 'image/jp2', 'application/x-hdf5', 'image/x.geotiff', 'image/tiff'},\n    exclude_asset_types: Optional[Set[str]] = None,\n    reader: Type[rio_tiler.io.base.BaseReader] = &lt;class 'rio_tiler.io.rasterio.Reader'&gt;,\n    reader_options: Dict = NOTHING,\n    ctx: Any = &lt;class 'rasterio.env.Env'&gt;\n)\n</code></pre>"},{"location":"api/titiler/pgstac/reader/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.io.base.MultiBaseReader</li> <li>rio_tiler.io.base.SpatialMixin</li> </ul>"},{"location":"api/titiler/pgstac/reader/#instance-variables","title":"Instance variables","text":"<pre><code>geographic_bounds\n</code></pre> <p>Return dataset bounds in geographic_crs.</p>"},{"location":"api/titiler/pgstac/reader/#methods","title":"Methods","text":""},{"location":"api/titiler/pgstac/reader/#feature","title":"feature","text":"<pre><code>def feature(\n    self,\n    shape: Dict,\n    assets: Union[Sequence[str], str] = None,\n    expression: Optional[str] = None,\n    asset_indexes: Optional[Dict[str, Union[Sequence[int], int]]] = None,\n    asset_as_band: bool = False,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read and merge parts defined by geojson feature from multiple assets.</p> <p>Parameters:</p> Name Type Description Default shape dict Valid GeoJSON feature. None assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None kwargs optional Options to forward to the <code>self.reader.feature</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/titiler/pgstac/reader/#info","title":"info","text":"<pre><code>def info(\n    self,\n    assets: Union[Sequence[str], str] = None,\n    **kwargs: Any\n) -&gt; Dict[str, rio_tiler.models.Info]\n</code></pre> <p>Return metadata from multiple assets.</p> <p>Parameters:</p> Name Type Description Default assets sequence of str or str assets to fetch info from. Required keyword argument. None <p>Returns:</p> Type Description dict Multiple assets info in form of {\"asset1\": rio_tile.models.Info}."},{"location":"api/titiler/pgstac/reader/#merged_statistics","title":"merged_statistics","text":"<pre><code>def merged_statistics(\n    self,\n    assets: Union[Sequence[str], str] = None,\n    expression: Optional[str] = None,\n    asset_indexes: Optional[Dict[str, Union[Sequence[int], int]]] = None,\n    categorical: bool = False,\n    categories: Optional[List[float]] = None,\n    percentiles: Optional[List[int]] = None,\n    hist_options: Optional[Dict] = None,\n    max_size: int = 1024,\n    **kwargs: Any\n) -&gt; Dict[str, rio_tiler.models.BandStatistics]\n</code></pre> <p>Return array statistics for multiple assets.</p> <p>Parameters:</p> Name Type Description Default assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None categorical bool treat input data as categorical data. Defaults to False. False categories list of numbers list of categories to return value for. None percentiles list of numbers list of percentile values to calculate. Defaults to <code>[2, 98]</code>. <code>[2, 98]</code> hist_options dict Options to forward to numpy.histogram function. None max_size int Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio. Defaults to 1024. 1024 kwargs optional Options to forward to the <code>self.preview</code> method. None <p>Returns:</p> Type Description Dict[str, rio_tiler.models.BandStatistics] bands statistics."},{"location":"api/titiler/pgstac/reader/#parse_expression","title":"parse_expression","text":"<pre><code>def parse_expression(\n    self,\n    expression: str,\n    asset_as_band: bool = False\n) -&gt; Tuple\n</code></pre> <p>Parse rio-tiler band math expression.</p>"},{"location":"api/titiler/pgstac/reader/#part","title":"part","text":"<pre><code>def part(\n    self,\n    bbox: Tuple[float, float, float, float],\n    assets: Union[Sequence[str], str] = None,\n    expression: Optional[str] = None,\n    asset_indexes: Optional[Dict[str, Union[Sequence[int], int]]] = None,\n    asset_as_band: bool = False,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read and merge parts from multiple assets.</p> <p>Parameters:</p> Name Type Description Default bbox tuple Output bounds (left, bottom, right, top) in target crs. None assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None kwargs optional Options to forward to the <code>self.reader.part</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/titiler/pgstac/reader/#point","title":"point","text":"<pre><code>def point(\n    self,\n    lon: float,\n    lat: float,\n    assets: Union[Sequence[str], str] = None,\n    expression: Optional[str] = None,\n    asset_indexes: Optional[Dict[str, Union[Sequence[int], int]]] = None,\n    asset_as_band: bool = False,\n    **kwargs: Any\n) -&gt; rio_tiler.models.PointData\n</code></pre> <p>Read pixel value from multiple assets.</p> <p>Parameters:</p> Name Type Description Default lon float Longitude. None lat float Latitude. None assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None kwargs optional Options to forward to the <code>self.reader.point</code> method. None <p>Returns:</p> Type Description None PointData"},{"location":"api/titiler/pgstac/reader/#preview","title":"preview","text":"<pre><code>def preview(\n    self,\n    assets: Union[Sequence[str], str] = None,\n    expression: Optional[str] = None,\n    asset_indexes: Optional[Dict[str, Union[Sequence[int], int]]] = None,\n    asset_as_band: bool = False,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read and merge previews from multiple assets.</p> <p>Parameters:</p> Name Type Description Default assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None kwargs optional Options to forward to the <code>self.reader.preview</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/titiler/pgstac/reader/#statistics","title":"statistics","text":"<pre><code>def statistics(\n    self,\n    assets: Union[Sequence[str], str] = None,\n    asset_indexes: Optional[Dict[str, Union[Sequence[int], int]]] = None,\n    asset_expression: Optional[Dict[str, str]] = None,\n    **kwargs: Any\n) -&gt; Dict[str, Dict[str, rio_tiler.models.BandStatistics]]\n</code></pre> <p>Return array statistics for multiple assets.</p> <p>Parameters:</p> Name Type Description Default assets sequence of str or str assets to fetch info from. None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None asset_expression dict rio-tiler expression for each asset (e.g. {\"asset1\": \"b1/b2+b3\", \"asset2\": ...}). None kwargs optional Options to forward to the <code>self.reader.statistics</code> method. None <p>Returns:</p> Type Description dict Multiple assets statistics in form of {\"asset1\": {\"1\": rio_tiler.models.BandStatistics, ...}}."},{"location":"api/titiler/pgstac/reader/#tile","title":"tile","text":"<pre><code>def tile(\n    self,\n    tile_x: int,\n    tile_y: int,\n    tile_z: int,\n    assets: Union[Sequence[str], str] = None,\n    expression: Optional[str] = None,\n    asset_indexes: Optional[Dict[str, Union[Sequence[int], int]]] = None,\n    asset_as_band: bool = False,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read and merge Wep Map tiles from multiple assets.</p> <p>Parameters:</p> Name Type Description Default tile_x int Tile's horizontal index. None tile_y int Tile's vertical index. None tile_z int Tile's zoom level index. None assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None kwargs optional Options to forward to the <code>self.reader.tile</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/titiler/pgstac/reader/#tile_exists","title":"tile_exists","text":"<pre><code>def tile_exists(\n    self,\n    tile_x: int,\n    tile_y: int,\n    tile_z: int\n) -&gt; bool\n</code></pre> <p>Check if a tile intersects the dataset bounds.</p> <p>Parameters:</p> Name Type Description Default tile_x int Tile's horizontal index. None tile_y int Tile's vertical index. None tile_z int Tile's zoom level index. None <p>Returns:</p> Type Description bool True if the tile intersects the dataset bounds."},{"location":"api/titiler/pgstac/settings/","title":"Module titiler.pgstac.settings","text":"<p>API settings.</p> <p>None</p>"},{"location":"api/titiler/pgstac/settings/#functions","title":"Functions","text":""},{"location":"api/titiler/pgstac/settings/#retrysettings","title":"RetrySettings","text":"<pre><code>def RetrySettings(\n\n) -&gt; titiler.pgstac.settings._RetrySettings\n</code></pre> <p>This function returns a cached instance of the RetrySettings object.</p>"},{"location":"api/titiler/pgstac/settings/#classes","title":"Classes","text":""},{"location":"api/titiler/pgstac/settings/#apisettings","title":"ApiSettings","text":"<pre><code>class ApiSettings(\n    __pydantic_self__,\n    _case_sensitive: 'bool | None' = None,\n    _env_prefix: 'str | None' = None,\n    _env_file: 'DotenvType | None' = PosixPath('.'),\n    _env_file_encoding: 'str | None' = None,\n    _env_nested_delimiter: 'str | None' = None,\n    _secrets_dir: 'str | Path | None' = None,\n    **values: 'Any'\n)\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>pydantic_settings.main.BaseSettings</li> <li>pydantic.main.BaseModel</li> </ul>"},{"location":"api/titiler/pgstac/settings/#class-variables","title":"Class variables","text":"<pre><code>model_config\n</code></pre> <pre><code>model_fields\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#static-methods","title":"Static methods","text":""},{"location":"api/titiler/pgstac/settings/#construct","title":"construct","text":"<pre><code>def construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#from_orm","title":"from_orm","text":"<pre><code>def from_orm(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#model_construct","title":"model_construct","text":"<pre><code>def model_construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if <code>Config.extra = 'allow'</code> was set since it adds all passed values</p> <p>Parameters:</p> Name Type Description Default _fields_set None The set of field names accepted for the Model instance. None values None Trusted or pre-validated data dictionary. None <p>Returns:</p> Type Description None A new instance of the <code>Model</code> class with validated data."},{"location":"api/titiler/pgstac/settings/#model_json_schema","title":"model_json_schema","text":"<pre><code>def model_json_schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    schema_generator: 'type[GenerateJsonSchema]' = &lt;class 'pydantic.json_schema.GenerateJsonSchema'&gt;,\n    mode: 'JsonSchemaMode' = 'validation'\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default by_alias None Whether to use attribute aliases or not. None ref_template None The reference template. None schema_generator None To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications None mode None The mode in which to generate the schema. None <p>Returns:</p> Type Description None The JSON schema for the given model class."},{"location":"api/titiler/pgstac/settings/#model_parametrized_name","title":"model_parametrized_name","text":"<pre><code>def model_parametrized_name(\n    params: 'tuple[type[Any], ...]'\n) -&gt; 'str'\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default params None Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>. None <p>Returns:</p> Type Description None String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables. <p>Raises:</p> Type Description TypeError Raised when trying to generate concrete names for non-generic models."},{"location":"api/titiler/pgstac/settings/#model_rebuild","title":"model_rebuild","text":"<pre><code>def model_rebuild(\n    *,\n    force: 'bool' = False,\n    raise_errors: 'bool' = True,\n    _parent_namespace_depth: 'int' = 2,\n    _types_namespace: 'dict[str, Any] | None' = None\n) -&gt; 'bool | None'\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default force None Whether to force the rebuilding of the model schema, defaults to <code>False</code>. None raise_errors None Whether to raise errors, defaults to <code>True</code>. None _parent_namespace_depth None The depth level of the parent namespace, defaults to 2. None _types_namespace None The types namespace, defaults to <code>None</code>. None <p>Returns:</p> Type Description None Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>."},{"location":"api/titiler/pgstac/settings/#model_validate","title":"model_validate","text":"<pre><code>def model_validate(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    from_attributes: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default obj None The object to validate. None strict None Whether to raise an exception on invalid fields. None from_attributes None Whether to extract data from object attributes. None context None Additional context to pass to the validator. None <p>Returns:</p> Type Description None The validated model instance. <p>Raises:</p> Type Description ValidationError If the object could not be validated."},{"location":"api/titiler/pgstac/settings/#model_validate_json","title":"model_validate_json","text":"<pre><code>def model_validate_json(\n    json_data: 'str | bytes | bytearray',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default json_data None The JSON data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model. <p>Raises:</p> Type Description ValueError If <code>json_data</code> is not a JSON string."},{"location":"api/titiler/pgstac/settings/#model_validate_strings","title":"model_validate_strings","text":"<pre><code>def model_validate_strings(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given object contains string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default obj None The object contains string data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model."},{"location":"api/titiler/pgstac/settings/#parse_cors_origin","title":"parse_cors_origin","text":"<pre><code>def parse_cors_origin(\n    v\n)\n</code></pre> <p>Parse CORS origins.</p>"},{"location":"api/titiler/pgstac/settings/#parse_file","title":"parse_file","text":"<pre><code>def parse_file(\n    path: 'str | Path',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#parse_obj","title":"parse_obj","text":"<pre><code>def parse_obj(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#parse_raw","title":"parse_raw","text":"<pre><code>def parse_raw(\n    b: 'str | bytes',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#schema","title":"schema","text":"<pre><code>def schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}'\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#schema_json","title":"schema_json","text":"<pre><code>def schema_json(\n    *,\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#settings_customise_sources","title":"settings_customise_sources","text":"<pre><code>def settings_customise_sources(\n    settings_cls: 'type[BaseSettings]',\n    init_settings: 'PydanticBaseSettingsSource',\n    env_settings: 'PydanticBaseSettingsSource',\n    dotenv_settings: 'PydanticBaseSettingsSource',\n    file_secret_settings: 'PydanticBaseSettingsSource'\n) -&gt; 'tuple[PydanticBaseSettingsSource, ...]'\n</code></pre> <p>Define the sources and their order for loading the settings values.</p> <p>Parameters:</p> Name Type Description Default settings_cls None The Settings class. None init_settings None The <code>InitSettingsSource</code> instance. None env_settings None The <code>EnvSettingsSource</code> instance. None dotenv_settings None The <code>DotEnvSettingsSource</code> instance. None file_secret_settings None The <code>SecretsSettingsSource</code> instance. None <p>Returns:</p> Type Description None A tuple containing the sources and their order for loading the settings values."},{"location":"api/titiler/pgstac/settings/#update_forward_refs","title":"update_forward_refs","text":"<pre><code>def update_forward_refs(\n    **localns: 'Any'\n) -&gt; 'None'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#validate","title":"validate","text":"<pre><code>def validate(\n    value: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#instance-variables","title":"Instance variables","text":"<pre><code>model_computed_fields\n</code></pre> <p>Get the computed fields of this model instance.</p> <pre><code>model_extra\n</code></pre> <p>Get extra fields set during validation.</p> <pre><code>model_fields_set\n</code></pre> <p>Returns the set of fields that have been set on this model instance.</p>"},{"location":"api/titiler/pgstac/settings/#methods","title":"Methods","text":""},{"location":"api/titiler/pgstac/settings/#copy","title":"copy","text":"<pre><code>def copy(\n    self: 'Model',\n    *,\n    include: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    update: 'typing.Dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default include None Optional set or mapping specifying which fields to include in the copied model. None exclude None Optional set or mapping specifying which fields to exclude in the copied model. None update None Optional dictionary of field-value pairs to override field values in the copied model. None deep None If True, the values of fields that are Pydantic models will be deep copied. None <p>Returns:</p> Type Description None A copy of the model with included, excluded and updated fields as specified."},{"location":"api/titiler/pgstac/settings/#dict","title":"dict","text":"<pre><code>def dict(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#json","title":"json","text":"<pre><code>def json(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    encoder: 'typing.Callable[[Any], Any] | None' = PydanticUndefined,\n    models_as_dict: 'bool' = PydanticUndefined,\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#model_copy","title":"model_copy","text":"<pre><code>def model_copy(\n    self: 'Model',\n    *,\n    update: 'dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#model_copy</p> <p>Returns a copy of the model.</p> <p>Parameters:</p> Name Type Description Default update None Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data. None deep None Set to <code>True</code> to make a deep copy of the model. None <p>Returns:</p> Type Description None New model instance."},{"location":"api/titiler/pgstac/settings/#model_dump","title":"model_dump","text":"<pre><code>def model_dump(\n    self,\n    *,\n    mode: \"Literal['json', 'python'] | str\" = 'python',\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump</p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default mode None The mode in which <code>to_python</code> should run. If mode is 'json', the dictionary will only contain JSON serializable types. If mode is 'python', the dictionary may contain any Python objects. None include None A list of fields to include in the output. None exclude None A list of fields to exclude from the output. None by_alias None Whether to use the field's alias in the dictionary key if defined. None exclude_unset None Whether to exclude fields that are unset or None from the output. None exclude_defaults None Whether to exclude fields that are set to their default value from the output. None exclude_none None Whether to exclude fields that have a value of <code>None</code> from the output. None round_trip None Whether to enable serialization and deserialization round-trip support. None warnings None Whether to log warnings when invalid fields are encountered. None <p>Returns:</p> Type Description None A dictionary representation of the model."},{"location":"api/titiler/pgstac/settings/#model_dump_json","title":"model_dump_json","text":"<pre><code>def model_dump_json(\n    self,\n    *,\n    indent: 'int | None' = None,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'str'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump_json</p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default indent None Indentation to use in the JSON output. If None is passed, the output will be compact. None include None Field(s) to include in the JSON output. Can take either a string or set of strings. None exclude None Field(s) to exclude from the JSON output. Can take either a string or set of strings. None by_alias None Whether to serialize using field aliases. None exclude_unset None Whether to exclude fields that have not been explicitly set. None exclude_defaults None Whether to exclude fields that have the default value. None exclude_none None Whether to exclude fields that have a value of <code>None</code>. None round_trip None Whether to use serialization/deserialization between JSON and class instance. None warnings None Whether to show any warnings that occurred during serialization. None <p>Returns:</p> Type Description None A JSON string representation of the model."},{"location":"api/titiler/pgstac/settings/#model_post_init","title":"model_post_init","text":"<pre><code>def model_post_init(\n    self,\n    _BaseModel__context: 'Any'\n) -&gt; 'None'\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <p>This is useful if you want to do some validation that requires the entire model to be initialized.</p>"},{"location":"api/titiler/pgstac/settings/#cachesettings","title":"CacheSettings","text":"<pre><code>class CacheSettings(\n    __pydantic_self__,\n    _case_sensitive: 'bool | None' = None,\n    _env_prefix: 'str | None' = None,\n    _env_file: 'DotenvType | None' = PosixPath('.'),\n    _env_file_encoding: 'str | None' = None,\n    _env_nested_delimiter: 'str | None' = None,\n    _secrets_dir: 'str | Path | None' = None,\n    **values: 'Any'\n)\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#ancestors-in-mro_1","title":"Ancestors (in MRO)","text":"<ul> <li>pydantic_settings.main.BaseSettings</li> <li>pydantic.main.BaseModel</li> </ul>"},{"location":"api/titiler/pgstac/settings/#class-variables_1","title":"Class variables","text":"<pre><code>model_config\n</code></pre> <pre><code>model_fields\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#static-methods_1","title":"Static methods","text":""},{"location":"api/titiler/pgstac/settings/#construct_1","title":"construct","text":"<pre><code>def construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#from_orm_1","title":"from_orm","text":"<pre><code>def from_orm(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#model_construct_1","title":"model_construct","text":"<pre><code>def model_construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if <code>Config.extra = 'allow'</code> was set since it adds all passed values</p> <p>Parameters:</p> Name Type Description Default _fields_set None The set of field names accepted for the Model instance. None values None Trusted or pre-validated data dictionary. None <p>Returns:</p> Type Description None A new instance of the <code>Model</code> class with validated data."},{"location":"api/titiler/pgstac/settings/#model_json_schema_1","title":"model_json_schema","text":"<pre><code>def model_json_schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    schema_generator: 'type[GenerateJsonSchema]' = &lt;class 'pydantic.json_schema.GenerateJsonSchema'&gt;,\n    mode: 'JsonSchemaMode' = 'validation'\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default by_alias None Whether to use attribute aliases or not. None ref_template None The reference template. None schema_generator None To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications None mode None The mode in which to generate the schema. None <p>Returns:</p> Type Description None The JSON schema for the given model class."},{"location":"api/titiler/pgstac/settings/#model_parametrized_name_1","title":"model_parametrized_name","text":"<pre><code>def model_parametrized_name(\n    params: 'tuple[type[Any], ...]'\n) -&gt; 'str'\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default params None Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>. None <p>Returns:</p> Type Description None String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables. <p>Raises:</p> Type Description TypeError Raised when trying to generate concrete names for non-generic models."},{"location":"api/titiler/pgstac/settings/#model_rebuild_1","title":"model_rebuild","text":"<pre><code>def model_rebuild(\n    *,\n    force: 'bool' = False,\n    raise_errors: 'bool' = True,\n    _parent_namespace_depth: 'int' = 2,\n    _types_namespace: 'dict[str, Any] | None' = None\n) -&gt; 'bool | None'\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default force None Whether to force the rebuilding of the model schema, defaults to <code>False</code>. None raise_errors None Whether to raise errors, defaults to <code>True</code>. None _parent_namespace_depth None The depth level of the parent namespace, defaults to 2. None _types_namespace None The types namespace, defaults to <code>None</code>. None <p>Returns:</p> Type Description None Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>."},{"location":"api/titiler/pgstac/settings/#model_validate_1","title":"model_validate","text":"<pre><code>def model_validate(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    from_attributes: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default obj None The object to validate. None strict None Whether to raise an exception on invalid fields. None from_attributes None Whether to extract data from object attributes. None context None Additional context to pass to the validator. None <p>Returns:</p> Type Description None The validated model instance. <p>Raises:</p> Type Description ValidationError If the object could not be validated."},{"location":"api/titiler/pgstac/settings/#model_validate_json_1","title":"model_validate_json","text":"<pre><code>def model_validate_json(\n    json_data: 'str | bytes | bytearray',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default json_data None The JSON data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model. <p>Raises:</p> Type Description ValueError If <code>json_data</code> is not a JSON string."},{"location":"api/titiler/pgstac/settings/#model_validate_strings_1","title":"model_validate_strings","text":"<pre><code>def model_validate_strings(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given object contains string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default obj None The object contains string data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model."},{"location":"api/titiler/pgstac/settings/#parse_file_1","title":"parse_file","text":"<pre><code>def parse_file(\n    path: 'str | Path',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#parse_obj_1","title":"parse_obj","text":"<pre><code>def parse_obj(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#parse_raw_1","title":"parse_raw","text":"<pre><code>def parse_raw(\n    b: 'str | bytes',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#schema_1","title":"schema","text":"<pre><code>def schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}'\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#schema_json_1","title":"schema_json","text":"<pre><code>def schema_json(\n    *,\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#settings_customise_sources_1","title":"settings_customise_sources","text":"<pre><code>def settings_customise_sources(\n    settings_cls: 'type[BaseSettings]',\n    init_settings: 'PydanticBaseSettingsSource',\n    env_settings: 'PydanticBaseSettingsSource',\n    dotenv_settings: 'PydanticBaseSettingsSource',\n    file_secret_settings: 'PydanticBaseSettingsSource'\n) -&gt; 'tuple[PydanticBaseSettingsSource, ...]'\n</code></pre> <p>Define the sources and their order for loading the settings values.</p> <p>Parameters:</p> Name Type Description Default settings_cls None The Settings class. None init_settings None The <code>InitSettingsSource</code> instance. None env_settings None The <code>EnvSettingsSource</code> instance. None dotenv_settings None The <code>DotEnvSettingsSource</code> instance. None file_secret_settings None The <code>SecretsSettingsSource</code> instance. None <p>Returns:</p> Type Description None A tuple containing the sources and their order for loading the settings values."},{"location":"api/titiler/pgstac/settings/#update_forward_refs_1","title":"update_forward_refs","text":"<pre><code>def update_forward_refs(\n    **localns: 'Any'\n) -&gt; 'None'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#validate_1","title":"validate","text":"<pre><code>def validate(\n    value: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#instance-variables_1","title":"Instance variables","text":"<pre><code>model_computed_fields\n</code></pre> <p>Get the computed fields of this model instance.</p> <pre><code>model_extra\n</code></pre> <p>Get extra fields set during validation.</p> <pre><code>model_fields_set\n</code></pre> <p>Returns the set of fields that have been set on this model instance.</p>"},{"location":"api/titiler/pgstac/settings/#methods_1","title":"Methods","text":""},{"location":"api/titiler/pgstac/settings/#check_enable","title":"check_enable","text":"<pre><code>def check_enable(\n    self\n)\n</code></pre> <p>Check if cache is disabled.</p>"},{"location":"api/titiler/pgstac/settings/#copy_1","title":"copy","text":"<pre><code>def copy(\n    self: 'Model',\n    *,\n    include: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    update: 'typing.Dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default include None Optional set or mapping specifying which fields to include in the copied model. None exclude None Optional set or mapping specifying which fields to exclude in the copied model. None update None Optional dictionary of field-value pairs to override field values in the copied model. None deep None If True, the values of fields that are Pydantic models will be deep copied. None <p>Returns:</p> Type Description None A copy of the model with included, excluded and updated fields as specified."},{"location":"api/titiler/pgstac/settings/#dict_1","title":"dict","text":"<pre><code>def dict(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#json_1","title":"json","text":"<pre><code>def json(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    encoder: 'typing.Callable[[Any], Any] | None' = PydanticUndefined,\n    models_as_dict: 'bool' = PydanticUndefined,\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#model_copy_1","title":"model_copy","text":"<pre><code>def model_copy(\n    self: 'Model',\n    *,\n    update: 'dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#model_copy</p> <p>Returns a copy of the model.</p> <p>Parameters:</p> Name Type Description Default update None Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data. None deep None Set to <code>True</code> to make a deep copy of the model. None <p>Returns:</p> Type Description None New model instance."},{"location":"api/titiler/pgstac/settings/#model_dump_1","title":"model_dump","text":"<pre><code>def model_dump(\n    self,\n    *,\n    mode: \"Literal['json', 'python'] | str\" = 'python',\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump</p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default mode None The mode in which <code>to_python</code> should run. If mode is 'json', the dictionary will only contain JSON serializable types. If mode is 'python', the dictionary may contain any Python objects. None include None A list of fields to include in the output. None exclude None A list of fields to exclude from the output. None by_alias None Whether to use the field's alias in the dictionary key if defined. None exclude_unset None Whether to exclude fields that are unset or None from the output. None exclude_defaults None Whether to exclude fields that are set to their default value from the output. None exclude_none None Whether to exclude fields that have a value of <code>None</code> from the output. None round_trip None Whether to enable serialization and deserialization round-trip support. None warnings None Whether to log warnings when invalid fields are encountered. None <p>Returns:</p> Type Description None A dictionary representation of the model."},{"location":"api/titiler/pgstac/settings/#model_dump_json_1","title":"model_dump_json","text":"<pre><code>def model_dump_json(\n    self,\n    *,\n    indent: 'int | None' = None,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'str'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump_json</p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default indent None Indentation to use in the JSON output. If None is passed, the output will be compact. None include None Field(s) to include in the JSON output. Can take either a string or set of strings. None exclude None Field(s) to exclude from the JSON output. Can take either a string or set of strings. None by_alias None Whether to serialize using field aliases. None exclude_unset None Whether to exclude fields that have not been explicitly set. None exclude_defaults None Whether to exclude fields that have the default value. None exclude_none None Whether to exclude fields that have a value of <code>None</code>. None round_trip None Whether to use serialization/deserialization between JSON and class instance. None warnings None Whether to show any warnings that occurred during serialization. None <p>Returns:</p> Type Description None A JSON string representation of the model."},{"location":"api/titiler/pgstac/settings/#model_post_init_1","title":"model_post_init","text":"<pre><code>def model_post_init(\n    self,\n    _BaseModel__context: 'Any'\n) -&gt; 'None'\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <p>This is useful if you want to do some validation that requires the entire model to be initialized.</p>"},{"location":"api/titiler/pgstac/settings/#postgressettings","title":"PostgresSettings","text":"<pre><code>class PostgresSettings(\n    __pydantic_self__,\n    _case_sensitive: 'bool | None' = None,\n    _env_prefix: 'str | None' = None,\n    _env_file: 'DotenvType | None' = PosixPath('.'),\n    _env_file_encoding: 'str | None' = None,\n    _env_nested_delimiter: 'str | None' = None,\n    _secrets_dir: 'str | Path | None' = None,\n    **values: 'Any'\n)\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#attributes","title":"Attributes","text":"Name Type Description Default postgres_user None postgres username. None postgres_pass None postgres password. None postgres_host None database hostname. None postgres_port None database port. None postgres_dbname None database name. None"},{"location":"api/titiler/pgstac/settings/#ancestors-in-mro_2","title":"Ancestors (in MRO)","text":"<ul> <li>pydantic_settings.main.BaseSettings</li> <li>pydantic.main.BaseModel</li> </ul>"},{"location":"api/titiler/pgstac/settings/#class-variables_2","title":"Class variables","text":"<pre><code>model_config\n</code></pre> <pre><code>model_fields\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#static-methods_2","title":"Static methods","text":""},{"location":"api/titiler/pgstac/settings/#assemble_db_connection","title":"assemble_db_connection","text":"<pre><code>def assemble_db_connection(\n    v: Optional[str],\n    info: pydantic_core.core_schema.ValidationInfo\n) -&gt; Any\n</code></pre> <p>Validate database config.</p>"},{"location":"api/titiler/pgstac/settings/#construct_2","title":"construct","text":"<pre><code>def construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#from_orm_2","title":"from_orm","text":"<pre><code>def from_orm(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#model_construct_2","title":"model_construct","text":"<pre><code>def model_construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if <code>Config.extra = 'allow'</code> was set since it adds all passed values</p> <p>Parameters:</p> Name Type Description Default _fields_set None The set of field names accepted for the Model instance. None values None Trusted or pre-validated data dictionary. None <p>Returns:</p> Type Description None A new instance of the <code>Model</code> class with validated data."},{"location":"api/titiler/pgstac/settings/#model_json_schema_2","title":"model_json_schema","text":"<pre><code>def model_json_schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    schema_generator: 'type[GenerateJsonSchema]' = &lt;class 'pydantic.json_schema.GenerateJsonSchema'&gt;,\n    mode: 'JsonSchemaMode' = 'validation'\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default by_alias None Whether to use attribute aliases or not. None ref_template None The reference template. None schema_generator None To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications None mode None The mode in which to generate the schema. None <p>Returns:</p> Type Description None The JSON schema for the given model class."},{"location":"api/titiler/pgstac/settings/#model_parametrized_name_2","title":"model_parametrized_name","text":"<pre><code>def model_parametrized_name(\n    params: 'tuple[type[Any], ...]'\n) -&gt; 'str'\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default params None Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>. None <p>Returns:</p> Type Description None String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables. <p>Raises:</p> Type Description TypeError Raised when trying to generate concrete names for non-generic models."},{"location":"api/titiler/pgstac/settings/#model_rebuild_2","title":"model_rebuild","text":"<pre><code>def model_rebuild(\n    *,\n    force: 'bool' = False,\n    raise_errors: 'bool' = True,\n    _parent_namespace_depth: 'int' = 2,\n    _types_namespace: 'dict[str, Any] | None' = None\n) -&gt; 'bool | None'\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default force None Whether to force the rebuilding of the model schema, defaults to <code>False</code>. None raise_errors None Whether to raise errors, defaults to <code>True</code>. None _parent_namespace_depth None The depth level of the parent namespace, defaults to 2. None _types_namespace None The types namespace, defaults to <code>None</code>. None <p>Returns:</p> Type Description None Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required. If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>."},{"location":"api/titiler/pgstac/settings/#model_validate_2","title":"model_validate","text":"<pre><code>def model_validate(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    from_attributes: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default obj None The object to validate. None strict None Whether to raise an exception on invalid fields. None from_attributes None Whether to extract data from object attributes. None context None Additional context to pass to the validator. None <p>Returns:</p> Type Description None The validated model instance. <p>Raises:</p> Type Description ValidationError If the object could not be validated."},{"location":"api/titiler/pgstac/settings/#model_validate_json_2","title":"model_validate_json","text":"<pre><code>def model_validate_json(\n    json_data: 'str | bytes | bytearray',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default json_data None The JSON data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model. <p>Raises:</p> Type Description ValueError If <code>json_data</code> is not a JSON string."},{"location":"api/titiler/pgstac/settings/#model_validate_strings_2","title":"model_validate_strings","text":"<pre><code>def model_validate_strings(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given object contains string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default obj None The object contains string data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model."},{"location":"api/titiler/pgstac/settings/#parse_file_2","title":"parse_file","text":"<pre><code>def parse_file(\n    path: 'str | Path',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#parse_obj_2","title":"parse_obj","text":"<pre><code>def parse_obj(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#parse_raw_2","title":"parse_raw","text":"<pre><code>def parse_raw(\n    b: 'str | bytes',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#schema_2","title":"schema","text":"<pre><code>def schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}'\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#schema_json_2","title":"schema_json","text":"<pre><code>def schema_json(\n    *,\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#settings_customise_sources_2","title":"settings_customise_sources","text":"<pre><code>def settings_customise_sources(\n    settings_cls: 'type[BaseSettings]',\n    init_settings: 'PydanticBaseSettingsSource',\n    env_settings: 'PydanticBaseSettingsSource',\n    dotenv_settings: 'PydanticBaseSettingsSource',\n    file_secret_settings: 'PydanticBaseSettingsSource'\n) -&gt; 'tuple[PydanticBaseSettingsSource, ...]'\n</code></pre> <p>Define the sources and their order for loading the settings values.</p> <p>Parameters:</p> Name Type Description Default settings_cls None The Settings class. None init_settings None The <code>InitSettingsSource</code> instance. None env_settings None The <code>EnvSettingsSource</code> instance. None dotenv_settings None The <code>DotEnvSettingsSource</code> instance. None file_secret_settings None The <code>SecretsSettingsSource</code> instance. None <p>Returns:</p> Type Description None A tuple containing the sources and their order for loading the settings values."},{"location":"api/titiler/pgstac/settings/#update_forward_refs_2","title":"update_forward_refs","text":"<pre><code>def update_forward_refs(\n    **localns: 'Any'\n) -&gt; 'None'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#validate_2","title":"validate","text":"<pre><code>def validate(\n    value: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#instance-variables_2","title":"Instance variables","text":"<pre><code>model_computed_fields\n</code></pre> <p>Get the computed fields of this model instance.</p> <pre><code>model_extra\n</code></pre> <p>Get extra fields set during validation.</p> <pre><code>model_fields_set\n</code></pre> <p>Returns the set of fields that have been set on this model instance.</p>"},{"location":"api/titiler/pgstac/settings/#methods_2","title":"Methods","text":""},{"location":"api/titiler/pgstac/settings/#copy_2","title":"copy","text":"<pre><code>def copy(\n    self: 'Model',\n    *,\n    include: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    update: 'typing.Dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default include None Optional set or mapping specifying which fields to include in the copied model. None exclude None Optional set or mapping specifying which fields to exclude in the copied model. None update None Optional dictionary of field-value pairs to override field values in the copied model. None deep None If True, the values of fields that are Pydantic models will be deep copied. None <p>Returns:</p> Type Description None A copy of the model with included, excluded and updated fields as specified."},{"location":"api/titiler/pgstac/settings/#dict_2","title":"dict","text":"<pre><code>def dict(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#json_2","title":"json","text":"<pre><code>def json(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    encoder: 'typing.Callable[[Any], Any] | None' = PydanticUndefined,\n    models_as_dict: 'bool' = PydanticUndefined,\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/titiler/pgstac/settings/#model_copy_2","title":"model_copy","text":"<pre><code>def model_copy(\n    self: 'Model',\n    *,\n    update: 'dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#model_copy</p> <p>Returns a copy of the model.</p> <p>Parameters:</p> Name Type Description Default update None Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data. None deep None Set to <code>True</code> to make a deep copy of the model. None <p>Returns:</p> Type Description None New model instance."},{"location":"api/titiler/pgstac/settings/#model_dump_2","title":"model_dump","text":"<pre><code>def model_dump(\n    self,\n    *,\n    mode: \"Literal['json', 'python'] | str\" = 'python',\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump</p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default mode None The mode in which <code>to_python</code> should run. If mode is 'json', the dictionary will only contain JSON serializable types. If mode is 'python', the dictionary may contain any Python objects. None include None A list of fields to include in the output. None exclude None A list of fields to exclude from the output. None by_alias None Whether to use the field's alias in the dictionary key if defined. None exclude_unset None Whether to exclude fields that are unset or None from the output. None exclude_defaults None Whether to exclude fields that are set to their default value from the output. None exclude_none None Whether to exclude fields that have a value of <code>None</code> from the output. None round_trip None Whether to enable serialization and deserialization round-trip support. None warnings None Whether to log warnings when invalid fields are encountered. None <p>Returns:</p> Type Description None A dictionary representation of the model."},{"location":"api/titiler/pgstac/settings/#model_dump_json_2","title":"model_dump_json","text":"<pre><code>def model_dump_json(\n    self,\n    *,\n    indent: 'int | None' = None,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: 'bool' = True\n) -&gt; 'str'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump_json</p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default indent None Indentation to use in the JSON output. If None is passed, the output will be compact. None include None Field(s) to include in the JSON output. Can take either a string or set of strings. None exclude None Field(s) to exclude from the JSON output. Can take either a string or set of strings. None by_alias None Whether to serialize using field aliases. None exclude_unset None Whether to exclude fields that have not been explicitly set. None exclude_defaults None Whether to exclude fields that have the default value. None exclude_none None Whether to exclude fields that have a value of <code>None</code>. None round_trip None Whether to use serialization/deserialization between JSON and class instance. None warnings None Whether to show any warnings that occurred during serialization. None <p>Returns:</p> Type Description None A JSON string representation of the model."},{"location":"api/titiler/pgstac/settings/#model_post_init_2","title":"model_post_init","text":"<pre><code>def model_post_init(\n    self,\n    _BaseModel__context: 'Any'\n) -&gt; 'None'\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <p>This is useful if you want to do some validation that requires the entire model to be initialized.</p>"},{"location":"api/titiler/pgstac/utils/","title":"Module titiler.pgstac.utils","text":"<p>titiler.pgstac utilities.</p> <p>None</p>"},{"location":"api/titiler/pgstac/utils/#functions","title":"Functions","text":""},{"location":"api/titiler/pgstac/utils/#retry","title":"retry","text":"<pre><code>def retry(\n    tries: int,\n    exceptions: Union[Type[Exception], Sequence[Type[Exception]]] = &lt;class 'Exception'&gt;,\n    delay: float = 0.0\n)\n</code></pre> <p>Retry Decorator</p>"},{"location":"notebooks/demo/","title":"demo","text":"In\u00a0[1]: Copied! <pre>import json\nimport httpx\nfrom folium import Map, TileLayer, GeoJson\n\nfrom geojson_pydantic import Feature, Polygon\n\nendpoint = \"http://127.0.0.1:8081\"\n\nprint(httpx.get(f\"{endpoint}/healthz\").json())\n</pre> import json import httpx from folium import Map, TileLayer, GeoJson  from geojson_pydantic import Feature, Polygon  endpoint = \"http://127.0.0.1:8081\"  print(httpx.get(f\"{endpoint}/healthz\").json()) <pre>{'database_online': True}\n</pre> In\u00a0[3]: Copied! <pre># bounds of the noaa-eri-nashville2020.json items\nbounds = (-87.0251, 36.0999, -85.4249, 36.2251)\n\npoly = Polygon.from_bounds(*bounds)\ngeojson = Feature(type=\"Feature\", geometry=poly, properties=None).dict(exclude_none=True)\n\nm = Map(\n    tiles=\"OpenStreetMap\",\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=8\n)\n\ngeo_json = GeoJson(\n    data=geojson,\n    style_function=lambda x: {\n        'opacity': 1, 'dashArray': '1', 'fillOpacity': 0, 'weight': 1\n    },\n)\ngeo_json.add_to(m)\nm\n</pre> # bounds of the noaa-eri-nashville2020.json items bounds = (-87.0251, 36.0999, -85.4249, 36.2251)  poly = Polygon.from_bounds(*bounds) geojson = Feature(type=\"Feature\", geometry=poly, properties=None).dict(exclude_none=True)  m = Map(     tiles=\"OpenStreetMap\",     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=8 )  geo_json = GeoJson(     data=geojson,     style_function=lambda x: {         'opacity': 1, 'dashArray': '1', 'fillOpacity': 0, 'weight': 1     }, ) geo_json.add_to(m) m Out[3]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[4]: Copied! <pre>search_request = {\n    # Filter collection\n    \"collections\": [\"noaa-emergency-response\"],\n    # limit bounds of the known items (note: the bbox will also be used in the tilejson response)\n    \"bbox\": bounds,\n    \"filter-lang\": \"cql-json\",\n}\n\nresponse = httpx.post(\n    f\"{endpoint}/mosaic/register\", json=search_request,\n).json()\nprint(response)\n\nsearchid = response[\"searchid\"]\n</pre> search_request = {     # Filter collection     \"collections\": [\"noaa-emergency-response\"],     # limit bounds of the known items (note: the bbox will also be used in the tilejson response)     \"bbox\": bounds,     \"filter-lang\": \"cql-json\", }  response = httpx.post(     f\"{endpoint}/mosaic/register\", json=search_request, ).json() print(response)  searchid = response[\"searchid\"] <pre>{'searchid': '6d436413d0eed760acc2f6bd16ca77a5', 'links': [{'rel': 'metadata', 'type': 'application/json', 'href': 'http://127.0.0.1:8081/mosaic/6d436413d0eed760acc2f6bd16ca77a5/info'}, {'rel': 'tilejson', 'type': 'application/json', 'href': 'http://127.0.0.1:8081/mosaic/6d436413d0eed760acc2f6bd16ca77a5/tilejson.json'}]}\n</pre> In\u00a0[5]: Copied! <pre>response = httpx.get(f\"{endpoint}/mosaic/list\").json()\nprint(\n    [\n        search[\"search\"][\"hash\"]\n        for search in response[\"searches\"]\n    ]\n)\n</pre> response = httpx.get(f\"{endpoint}/mosaic/list\").json() print(     [         search[\"search\"][\"hash\"]         for search in response[\"searches\"]     ] ) <pre>['b2b4e952ae7a8dd69cd11d595b398945', '6d436413d0eed760acc2f6bd16ca77a5']\n</pre> In\u00a0[6]: Copied! <pre>info_response = httpx.get(f\"{endpoint}/mosaic/{searchid}/info\").json()\nprint(info_response)\n</pre> info_response = httpx.get(f\"{endpoint}/mosaic/{searchid}/info\").json() print(info_response) <pre>{'search': {'hash': '6d436413d0eed760acc2f6bd16ca77a5', 'search': {'bbox': [-87.0251, 36.0999, -85.4249, 36.2251], 'collections': ['noaa-emergency-response'], 'filter-lang': 'cql-json'}, '_where': \"collection = ANY ('{noaa-emergency-response}')  AND st_intersects(geometry, '0103000020E610000001000000050000004BC8073D9BC155C0696FF085C90C42404BC8073D9BC155C0302AA913D01C42408104C58F315B55C0302AA913D01C42408104C58F315B55C0696FF085C90C42404BC8073D9BC155C0696FF085C90C4240')\", 'orderby': 'datetime DESC, id DESC', 'lastused': '2023-05-24T10:09:15.184690+00:00', 'usecount': 1, 'metadata': {'type': 'mosaic'}}, 'links': [{'rel': 'self', 'type': 'application/json', 'href': 'http://127.0.0.1:8081/mosaic/6d436413d0eed760acc2f6bd16ca77a5/info'}, {'rel': 'tilejson', 'type': 'application/json', 'href': 'http://127.0.0.1:8081/mosaic/6d436413d0eed760acc2f6bd16ca77a5/tilejson.json'}]}\n</pre> In\u00a0[7]: Copied! <pre>tj_response = httpx.get(f\"{endpoint}/mosaic/{searchid}/tilejson.json?assets=cog\").json()\nprint(tj_response)\n</pre> tj_response = httpx.get(f\"{endpoint}/mosaic/{searchid}/tilejson.json?assets=cog\").json() print(tj_response) <pre>{'tilejson': '2.2.0', 'name': '6d436413d0eed760acc2f6bd16ca77a5', 'version': '1.0.0', 'scheme': 'xyz', 'tiles': ['http://127.0.0.1:8081/mosaic/6d436413d0eed760acc2f6bd16ca77a5/tiles/WebMercatorQuad/{z}/{x}/{y}@1x?assets=cog'], 'minzoom': 0, 'maxzoom': 24, 'bounds': [-87.0251, 36.0999, -85.4249, 36.2251], 'center': [-86.225, 36.162499999999994, 0]}\n</pre> In\u00a0[8]: Copied! <pre>m = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=14\n)\n\ngeo_json = GeoJson(\n    data=geojson,\n    style_function=lambda x: {\n        'opacity': 1, 'dashArray': '1', 'fillOpacity': 0, 'weight': 1\n    },\n)\ngeo_json.add_to(m)\n\naod_layer = TileLayer(\n    tiles=tj_response[\"tiles\"][0],\n    attr=\"Mosaic\",\n    min_zoom=14,\n    max_zoom=18,\n    max_native_zoom=18,\n)\naod_layer.add_to(m)\nm\n</pre> m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=14 )  geo_json = GeoJson(     data=geojson,     style_function=lambda x: {         'opacity': 1, 'dashArray': '1', 'fillOpacity': 0, 'weight': 1     }, ) geo_json.add_to(m)  aod_layer = TileLayer(     tiles=tj_response[\"tiles\"][0],     attr=\"Mosaic\",     min_zoom=14,     max_zoom=18,     max_native_zoom=18, ) aod_layer.add_to(m) m Out[8]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[9]: Copied! <pre>search_request = {\n    # Filter collection\n    \"collections\": [\"noaa-emergency-response\"],\n    # limit bounds of the known items (note: the bbox will also be used in the tilejson response)\n    \"bbox\": bounds,\n    \"filter-lang\": \"cql-json\",\n    \"metadata\": {\n        \"bounds\": [-87.0251, 36.0999, -85.4249, 36.2251],  # This is redondant because it's in the bbox filter\n        \"minzoom\": 14,\n        \"maxzoom\": 18,\n        \"assets\": [\"cog\"],\n        \"defaults\": {\n            \"true_color\": {\n                \"bidx\": [1, 2, 3],\n            },\n        },\n    },\n}\n\nresponse = httpx.post(\n    f\"{endpoint}/mosaic/register\", json=search_request,\n).json()\nprint(response)\n\nsearchid = response[\"searchid\"]\n</pre> search_request = {     # Filter collection     \"collections\": [\"noaa-emergency-response\"],     # limit bounds of the known items (note: the bbox will also be used in the tilejson response)     \"bbox\": bounds,     \"filter-lang\": \"cql-json\",     \"metadata\": {         \"bounds\": [-87.0251, 36.0999, -85.4249, 36.2251],  # This is redondant because it's in the bbox filter         \"minzoom\": 14,         \"maxzoom\": 18,         \"assets\": [\"cog\"],         \"defaults\": {             \"true_color\": {                 \"bidx\": [1, 2, 3],             },         },     }, }  response = httpx.post(     f\"{endpoint}/mosaic/register\", json=search_request, ).json() print(response)  searchid = response[\"searchid\"] <pre>{'searchid': '4b0db3dbd1858d54a3a55f84de97d1ca', 'links': [{'rel': 'metadata', 'type': 'application/json', 'href': 'http://127.0.0.1:8081/mosaic/4b0db3dbd1858d54a3a55f84de97d1ca/info'}, {'rel': 'tilejson', 'type': 'application/json', 'href': 'http://127.0.0.1:8081/mosaic/4b0db3dbd1858d54a3a55f84de97d1ca/tilejson.json'}]}\n</pre> In\u00a0[10]: Copied! <pre>tj_response = httpx.get(f\"{endpoint}/mosaic/{searchid}/tilejson.json?assets=cog\").json()\nprint(tj_response)\n</pre> tj_response = httpx.get(f\"{endpoint}/mosaic/{searchid}/tilejson.json?assets=cog\").json() print(tj_response) <pre>{'tilejson': '2.2.0', 'name': '4b0db3dbd1858d54a3a55f84de97d1ca', 'version': '1.0.0', 'scheme': 'xyz', 'tiles': ['http://127.0.0.1:8081/mosaic/4b0db3dbd1858d54a3a55f84de97d1ca/tiles/WebMercatorQuad/{z}/{x}/{y}@1x?assets=cog'], 'minzoom': 14, 'maxzoom': 18, 'bounds': [-87.0251, 36.0999, -85.4249, 36.2251], 'center': [-86.225, 36.162499999999994, 14]}\n</pre> In\u00a0[11]: Copied! <pre>m = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=14\n)\n\ngeo_json = GeoJson(\n    data=geojson,\n    style_function=lambda x: {\n        'opacity': 1, 'dashArray': '1', 'fillOpacity': 0, 'weight': 1\n    },\n)\ngeo_json.add_to(m)\n\naod_layer = TileLayer(\n    tiles=tj_response[\"tiles\"][0],\n    attr=\"Mosaic\",\n    min_zoom=tj_response[\"minzoom\"],\n    max_zoom=tj_response[\"maxzoom\"],\n    max_native_zoom=tj_response[\"maxzoom\"],    \n)\naod_layer.add_to(m)\nm\n</pre> m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=14 )  geo_json = GeoJson(     data=geojson,     style_function=lambda x: {         'opacity': 1, 'dashArray': '1', 'fillOpacity': 0, 'weight': 1     }, ) geo_json.add_to(m)  aod_layer = TileLayer(     tiles=tj_response[\"tiles\"][0],     attr=\"Mosaic\",     min_zoom=tj_response[\"minzoom\"],     max_zoom=tj_response[\"maxzoom\"],     max_native_zoom=tj_response[\"maxzoom\"],     ) aod_layer.add_to(m) m Out[11]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/demo/#titilerpgstac-demo","title":"titiler.PgSTAC Demo\u00b6","text":"<p>This Notebook aims to show the different features provided by titiler.pgstac application</p> <p>In order to run this demo you'll need to have a PgSTAC database and the titiler.pgstac application running. The easiest way to launch them is to use the repo's docker-compose.yml</p> <pre><code>docker-compose up tiler</code></pre>"},{"location":"notebooks/demo/#python-requirements","title":"Python requirements\u00b6","text":"<pre><code>pip install httpx folium pypgstac psycopg psycopg-pool geojson-pydantic</code></pre>"},{"location":"notebooks/demo/#populate-the-pgstac-db-with-data","title":"Populate the PgSTAC db with data\u00b6","text":"<pre><code>$ pypgstac load collections tests/fixtures/noaa-emergency-response.json --dsn postgresql://username:password@localhost:5439/postgis --method insert \n$ pypgstac load items tests/fixtures/noaa-eri-nashville2020.json --dsn postgresql://username:password@localhost:5439/postgis --method insert</code></pre>"},{"location":"notebooks/demo/#register-search-query","title":"Register Search query\u00b6","text":""},{"location":"notebooks/demo/#show-list-of-mosaics","title":"Show list of Mosaics\u00b6","text":""},{"location":"notebooks/demo/#get-search-metadata","title":"Get Search Metadata\u00b6","text":""},{"location":"notebooks/demo/#get-tilejson","title":"Get TileJSON\u00b6","text":"<p>Note: to return a valid tilejson document you'll need to pass either the <code>assets</code> or <code>expression</code> option.</p>"},{"location":"notebooks/demo/#load-tiles","title":"Load tiles\u00b6","text":""},{"location":"notebooks/demo/#register-a-mosaic-with-metadata","title":"Register a Mosaic with Metadata\u00b6","text":""}]}
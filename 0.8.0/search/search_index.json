{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> <p>Connect PgSTAC and TiTiler.</p> </p> <p> </p> <p>Documentation: stac-utils.github.io/titiler-pgstac/</p> <p>Source Code: stac-utils/titiler-pgstac</p> <p>TiTiler-PgSTAC is a TiTiler extension that connects to a PgSTAC database to create dynamic mosaics based on search queries.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install from PyPI and run:</p> <pre><code># Make sure to have pip up to date\n$ python -m pip install -U pip\n\n# Install `psycopg` or `psycopg[\"binary\"]` or `psycopg[\"c\"]`\n$ python -m pip install psycopg[\"binary\"]\n\n$ python -m pip install titiler.pgstac\n</code></pre> <p>To install from sources and run for development:</p> <pre><code>$ git clone https://github.com/stac-utils/titiler-pgstac.git\n$ cd titiler-pgstac\n$ python -m pip install -e .\n</code></pre>"},{"location":"#pgstac-version","title":"<code>PgSTAC</code> version","text":"<p><code>titiler.pgstac</code> depends on <code>pgstac &gt;=0.3.4</code> (github.com/stac-utils/pgstac/blob/main/CHANGELOG.md#v034).</p>"},{"location":"#psycopg-requirement","title":"<code>psycopg</code> requirement","text":"<p><code>titiler.pgstac</code> depends on the <code>psycopg</code> library. Because there are three ways of installing this package (<code>psycopg</code> or , <code>psycopg[\"c\"]</code>, <code>psycopg[\"binary\"]</code>), the user must install this separately from <code>titiler.pgstac</code>.</p> <ul> <li><code>psycopg</code>: no wheel, pure python implementation. It requires the <code>libpq</code> installed in the system.</li> <li><code>psycopg[\"binary\"]</code>: binary wheel distribution (shipped with libpq) of the <code>psycopg</code> package and is simpler for development. It requires development packages installed on the client machine.</li> <li><code>psycopg[\"c\"]</code>: a C (faster) implementation of the libpq wrapper. It requires the <code>libpq</code> installed in the system.</li> </ul> <p><code>psycopg[c]</code> or <code>psycopg</code> are generally recommended for production use.</p> <p>In <code>titiler.pgstac</code> setup.py, we have added three options to let users choose which psycopg install to use:</p> <ul> <li><code>pip install titiler.pgstac[\"psycopg\"]</code>: pure python</li> <li><code>pip install titiler.pgstac[\"psycopg-c\"]</code>: use the C wrapper (requires development packages installed on the client machine)</li> <li><code>pip install titiler.pgstac[\"psycopg-binary\"]</code>: binary wheels</li> </ul>"},{"location":"#launch","title":"Launch","text":"<p>You'll need to have <code>POSTGRES_USER</code>, <code>POSTGRES_PASS</code>, <code>POSTGRES_DBNAME</code>, <code>POSTGRES_HOST</code>, <code>POSTGRES_PORT</code> variables set in your environment pointing to your Postgres database where pgstac has been installed.</p> <pre><code>export POSTGRES_USER=username\nexport POSTGRES_PASS=password\nexport POSTGRES_DBNAME=postgis\nexport POSTGRES_HOST=database\nexport POSTGRES_PORT=5432\n</code></pre> <pre><code>$ pip install uvicorn\n$ uvicorn titiler.pgstac.main:app --reload\n</code></pre>"},{"location":"#using-docker","title":"Using Docker","text":"<pre><code>$ git clone https://github.com/stac-utils/titiler-pgstac.git\n$ cd titiler-pgstac\n$ docker-compose up --build tiler\n</code></pre> <p>It runs <code>titiler.pgstac</code> using Gunicorn web server. To run Uvicorn based version:</p> <pre><code>$ docker-compose up --build tiler-uvicorn\n</code></pre>"},{"location":"#contribution-development","title":"Contribution &amp; Development","text":"<p>See CONTRIBUTING.md</p>"},{"location":"#license","title":"License","text":"<p>See LICENSE</p>"},{"location":"#authors","title":"Authors","text":"<p>See contributors for a listing of individual contributors.</p>"},{"location":"#changes","title":"Changes","text":"<p>See CHANGES.md.</p>"},{"location":"contributing/","title":"Development - Contributing","text":"<p>Issues and pull requests are more than welcome: github.com/stac-utils/titiler-pgstac/issues</p> <p>dev install</p> <pre><code>$ git clone https://github.com/stac-utils/titiler-pgstac.git\n$ cd titiler\n$ pip install pre-commit -e .[\"dev,test\"]\n</code></pre> <p>You can then run the tests with the following command:</p> <pre><code>python -m pytest --cov titiler.pgstac --cov-report term-missing\n</code></pre> <p>This repo is set to use <code>pre-commit</code> to run isort, flake8, pydocstring, black (\"uncompromising Python code formatter\") and mypy when committing new code.</p> <pre><code>$ pre-commit install\n</code></pre>"},{"location":"intro/","title":"Intro","text":"<p>TiTiler.PgSTAC is a TiTiler extension, which create dynamic tiler connected to PgSTAC databases.</p> <p>By default the main application (<code>titiler.pgstac.main.app</code>) provides two sets of endpoints:</p> <ul> <li> <p><code>/mosaic/{searchid}</code>: Dynamic mosaic tiler based on STAC Search Queries</p> </li> <li> <p><code>/collections/{collection_id}/items/{item_id}</code>: Dynamic tiler for single STAC item (stored in PgSTAC)</p> </li> </ul>"},{"location":"intro/#mosaic","title":"Mosaic","text":"<p>The goal of the <code>mosaic</code> endpoints is to use any <code>search</code> query to create tiles. <code>titiler-pgstac</code> provides a set of endpoint to <code>register</code> and <code>list</code> the <code>search</code> queries.</p>"},{"location":"intro/#register-a-search-request","title":"Register a <code>Search</code> request","text":"<p>Important</p> <p>In <code>TiTiler.PgSTAC</code> a STAC <code>Search Query</code> is equivalent to a Mosaic.</p> <p>Before being able to create Map Tiles, the user needs to register a <code>Search Query</code> within the PgSTAC database (in the <code>searches</code> table). By default, <code>TiTiler.PgSTAC</code> has a <code>/mosaic/register (POST)</code> endpoint which will:</p> <ul> <li>validate the search query (based on the STAC API specification <code>item-search</code>)</li> <li>send the search query to the postgres database using the <code>search_query</code> PgSTAC function</li> <li>return a <code>searchid</code> (might be also called <code>mosaicid</code>).</li> </ul> <p>Example</p> <pre><code>curl -X 'POST' 'http://127.0.0.1:8081/mosaic/register' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"collections\":[\"landsat-c2l2-sr\"], \"bbox\":[-123.75,34.30714385628804,-118.125,38.82259097617712], \"filter-lang\": \"cql-json\"}' | jq\n\n&gt;&gt; {\n  \"searchid\": \"5a1b82d38d53a5d200273cbada886bd7\",\n  \"links\": [\n    {\n      \"rel\": \"metadata\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/5a1b82d38d53a5d200273cbada886bd7/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/5a1b82d38d53a5d200273cbada886bd7/tilejson.json\"\n    }\n  ]\n}\n\n# Or using CQL-2\ncurl -X 'POST' 'http://127.0.0.1:8081/mosaic/register' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"filter\": {\"op\": \"and\", \"args\": [{\"op\": \"=\", \"args\": [{\"property\": \"collection\"}, \"landsat-c2l2-sr\"]}, {\"op\": \"s_intersects\", \"args\": [{\"property\": \"geometry\"}, {\"coordinates\": [[[-123.75, 34.30714385628804], [-123.75, 38.82259097617712], [-118.125, 38.82259097617712], [-118.125, 34.30714385628804], [-123.75, 34.30714385628804]]], \"type\": \"Polygon\"}]}]}}' | jq\n\n&gt;&gt; {\n  \"searchid\": \"5063721f06957d6b2320326d82e90d1e\",\n  \"links\": [\n    {\n      \"rel\": \"metadata\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/5063721f06957d6b2320326d82e90d1e/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/5063721f06957d6b2320326d82e90d1e/tilejson.json\"\n    }\n  ]\n}\n</code></pre>"},{"location":"intro/#mosaic-metadata","title":"Mosaic metadata","text":"<pre><code>curl http://127.0.0.1:8081/mosaic/5063721f06957d6b2320326d82e90d1e/info | jq\n\n&gt;&gt; {\n  \"search\": {\n    \"hash\": \"5063721f06957d6b2320326d82e90d1e\",  # &lt;-- this is the search/mosaic ID\n    \"search\": {  # &lt;-- Summary of the search request\n      \"filter\": {  # &lt;-- this is CQL2 filter associated with the search\n        \"op\": \"and\",\n        \"args\": [\n          {\n            \"op\": \"=\",\n            \"args\": [\n              {\n                \"property\": \"collection\"\n              },\n              \"landsat-c2l2-sr\"\n            ]\n          },\n          {\n            \"op\": \"s_intersects\",\n            \"args\": [\n              {\n                \"property\": \"geometry\"\n              },\n              {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                  [\n                    [\n                      -123.75,\n                      34.30714385628804\n                    ],\n                    [\n                      -123.75,\n                      38.82259097617712\n                    ],\n                    [\n                      -118.125,\n                      38.82259097617712\n                    ],\n                    [\n                      -118.125,\n                      34.30714385628804\n                    ],\n                    [\n                      -123.75,\n                      34.30714385628804\n                    ]\n                  ]\n                ]\n              }\n            ]\n          }\n        ]\n      }\n    },\n    \"_where\": \"(  ( (collection_id = 'landsat-c2l2-sr') and st_intersects(geometry, '0103000020E610000001000000050000000000000000F05EC055F6687D502741400000000000F05EC02D553EA94A6943400000000000885DC02D553EA94A6943400000000000885DC055F6687D502741400000000000F05EC055F6687D50274140'::geometry) )  )  \",  # &lt;-- internal pgstac WHERE expression\n    \"orderby\": \"datetime DESC, id DESC\",\n    \"lastused\": \"2022-03-03T11:44:55.878504+00:00\",  # &lt;-- internal pgstac variable\n    \"usecount\": 2,  # &lt;-- internal pgstac variable\n    \"metadata\": {  # &lt;-- titiler-pgstac Mosaic Metadata\n      \"type\": \"mosaic\"  # &lt;-- where using the `/mosaic/register` endpoint, titiler-pgstac will add `type=mosaic` to the metadata\n    }\n  },\n  \"links\": [\n    {\n      \"rel\": \"self\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/5063721f06957d6b2320326d82e90d1e/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/5063721f06957d6b2320326d82e90d1e/tilejson.json\"\n    }\n  ]\n}\n</code></pre> <p>Note: In addition to the <code>search query</code>, a user can pass <code>metadata</code>, which will be saved in the postgres table.</p> <pre><code>curl -X 'POST' 'http://127.0.0.1:8081/mosaic/register' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"collections\":[\"landsat-c2l2-sr\"], \"bbox\":[-123.75,34.30714385628804,-118.125,38.82259097617712], \"filter-lang\": \"cql-json\", \"metadata\": {\"minzoom\": 8, \"maxzoom\": 13, \"assets\": [\"B04\", \"B03\", \"B02\"], \"defaults\": {\"true_color\": {\"assets\": [\"B04\", \"B03\", \"B02\"], \"color_formula\": \"Gamma RGB 3.5 Saturation 1.7 Sigmoidal RGB 15 0.35\"}}}}' | jq\n\n&gt;&gt; {\n  \"searchid\": \"f31d7de8a5ddfa3a80b9a9dd06378db1\",\n  \"links\": [\n    {\n      \"rel\": \"metadata\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/f31d7de8a5ddfa3a80b9a9dd06378db1/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/f31d7de8a5ddfa3a80b9a9dd06378db1/tilejson.json\"\n    }\n  ]\n}\n\ncurl http://127.0.0.1:8081/mosaic/f31d7de8a5ddfa3a80b9a9dd06378db1/info | jq '.search.metadata'\n&gt;&gt; {\n  \"type\": \"mosaic\",\n  \"minzoom\": 8,\n  \"maxzoom\": 13,\n  \"assets\": [\n    \"B04\",\n    \"B03\",\n    \"B02\"\n  ],\n  \"defaults\": {\n    \"true_color\": {\n      \"assets\": [\n        \"B04\",\n        \"B03\",\n        \"B02\"\n      ],\n      \"color_formula\": \"Gamma RGB 3.5 Saturation 1.7 Sigmoidal RGB 15 0.35\"\n    }\n  }\n}\n</code></pre>"},{"location":"intro/#fetch-mosaic-tiles","title":"Fetch mosaic <code>Tiles</code>","text":"<p>When we have a <code>searchid</code> we can now call the dynamic tiler and ask for Map Tiles.</p> <p></p> <p>How it works</p> <p>On each <code>Tile</code> request, the tiler api is going to call the PgSTAC <code>geometrysearch</code> function with the <code>searchid</code> and the Tile geometry to get the list of STAC items (code). Then based on the <code>assets</code> parameter, the tiler will construct the tile image (code).</p> <p>Important</p> <p>Because <code>Tiles</code> will be created from STAC items we HAVE TO pass <code>assets={stac asset}</code> option to the tile endpoint.</p> <p>See full list of options</p> <p>Example</p> <pre><code>curl 'http://127.0.0.1:8081/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/tiles/8/40/102.png?assets=B01&amp;rescale=0,16000 &gt; 8-40-102.png\n</code></pre>"},{"location":"intro/#items","title":"Items","text":"<p>Set of endpoints created using TiTiler's <code>MultiBaseTilerFactory</code> but with <code>item</code> and <code>collection</code> path parameter (instead of the <code>url=</code> query parameter).</p> <p>example</p> <pre><code>curl http://127.0.0.1:8081/collections/landsat-c2l2-sr/items/LC08_L1TP_028004_20171002_20171018_01_A1\n</code></pre> <p>See full list of endpoints</p>"},{"location":"item_endpoints/","title":"Item","text":"<p>The <code>titiler.pgstac</code> package comes with a full FastAPI application with Mosaic and single STAC item support.</p> <p>The <code>Item</code> endpoints are created using TiTiler's MultiBaseTilerFactory</p> Method URL Output Description <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/bounds</code> JSON (Bounds) return dataset's bounds <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/assets</code> JSON return the list of available assets <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/info</code> JSON (Info) return assets basic info <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/info.geojson</code> GeoJSON (InfoGeoJSON) return assets basic info as a GeoJSON feature <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/asset_statistics</code> JSON (Statistics) return per asset statistics <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/statistics</code> JSON (Statistics) return assets statistics (merged) <code>POST</code> <code>/collections/{collection_id}/items/{item_id}/statistics</code> GeoJSON (Statistics) return assets statistics for a GeoJSON (merged) <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/tiles[/{TileMatrixSetId}]/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin create a web map tile image from assets <code>GET</code> <code>/collections/{collection_id}/items/{item_id}[/{TileMatrixSetId}]/tilejson.json</code> JSON (TileJSON) return a Mapbox TileJSON document <code>GET</code> <code>/collections/{collection_id}/items/{item_id}[/{TileMatrixSetId}]/WMTSCapabilities.xml</code> XML return OGC WMTS Get Capabilities <code>GET</code> <code>/collections/{collection_id}/items/{item_id}[/{TileMatrixSetId}]/map</code> HTML simple map viewer <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/point/{lon},{lat}</code> JSON (Point) return pixel values from assets <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/preview[.{format}]</code> image/bin create a preview image from assets <code>GET</code> <code>/collections/{collection_id}/items/{item_id}/crop/{minx},{miny},{maxx},{maxy}[/{width}x{height}].{format}</code> image/bin create an image from part of assets <code>POST</code> <code>/collections/{collection_id}/items/{item_id}/crop[/{width}x{height}][.{format}]</code> image/bin create an image from a geojson feature intersecting assets"},{"location":"item_endpoints/#tiles","title":"Tiles","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/tiles[/{TileMatrixSetId}]/{z}/{x}/{y}[@{scale}x][.{format}]</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> <li>TileMatrixSetId (str): TileMatrixSet name, default is <code>WebMercatorQuad</code>. Optional</li> <li>z (int): TMS tile's zoom level.</li> <li>x (int): TMS tile's column.</li> <li>y (int): TMS tile's row.</li> <li>scale (int): Tile size scale, default is set to 1 (256x256). Optional</li> <li>format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Add buffer on each side of the tile (e.g 0.5 = 257x257, 1.0 = 258x258).</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/tiles/1/2/3?assets=B01&amp;assets=B00</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/tiles/1/2/3.jpg?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/tiles/WorldCRS84Quad/1/2/3@2x.png?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/tiles/WorldCRS84Quad/1/2/3?expression=B01/B02&amp;rescale=0,1000&amp;colormap_name=cfastie&amp;asset_as_band=True</code></li> </ul>"},{"location":"item_endpoints/#preview","title":"Preview","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/preview[.{format}]</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> <li>format: Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>max_size (int): Max image size, default is 1024.</li> <li>height (int): Force output image height.</li> <li>width (int): Force output image width.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> </ul> </li> </ul> <p>Important</p> <ul> <li> <p>assets OR expression is required</p> </li> <li> <p>if height and width are provided max_size will be ignored.</p> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/preview?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/preview.jpg?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/preview?assets=B01&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul>"},{"location":"item_endpoints/#crop-part","title":"Crop / Part","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/crop/{minx},{miny},{maxx},{maxy}.{format}</code> <code>:endpoint:/collections/{collection_id}/items/{item_id}/crop/{minx},{miny},{maxx},{maxy}/{width}x{height}.{format}</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> <li>minx,miny,maxx,maxy (str): Comma (',') delimited bounding box in WGS84.</li> <li>height (int): Force output image height. Optional</li> <li>width (int): Force output image width. Optional</li> <li>format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>max_size (int): Max image size, default is 1024.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> </ul> </li> </ul> <p>Important</p> <ul> <li> <p>assets OR expression is required</p> </li> <li> <p>if height and width are provided max_size will be ignored.</p> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/crop/0,0,10,10.png?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/crop/0,0,10,10.png?assets=B01&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul> <p><code>:endpoint:/collections/{collection_id}/items/{item_id}/crop[/{width}x{height}][].{format}] - [POST]</code></p> <ul> <li> <p>Body:</p> <ul> <li>feature (JSON): A valid GeoJSON feature (Polygon or MultiPolygon)</li> </ul> </li> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> <li>height (int): Force output image height. Optional</li> <li>width (int): Force output image width. Optional</li> <li>format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>max_size (int): Max image size, default is 1024.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> </ul> </li> </ul> <p>Important</p> <ul> <li> <p>assets OR expression is required</p> </li> <li> <p>if height and width are provided max_size will be ignored.</p> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/crop?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/crop.png?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/100x100.png?assets=B01&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul>"},{"location":"item_endpoints/#point","title":"Point","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/point/{lon},{lat}</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> <li>lon,lat, (str): Comma (',') delimited point Longitude and Latitude WGS84.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/point/0,0?assets=B01</code></li> </ul>"},{"location":"item_endpoints/#tilesjson","title":"TilesJSON","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}[/{TileMatrixSetId}]/tilejson.json</code> tileJSON document</p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> <li>TileMatrixSetId: TileMatrixSet name, default is <code>WebMercatorQuad</code>.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>tile_format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value.</li> <li>tile_scale (int): Tile size scale, default is set to 1 (256x256).</li> <li>minzoom (int): Overwrite default minzoom.</li> <li>maxzoom (int): Overwrite default maxzoom.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Add buffer on each side of the tile (e.g 0.5 = 257x257, 1.0 = 258x258).</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/tilejson.json?assets=B01</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/tilejson.json?assets=B01&amp;tile_format=png</code></li> <li><code>https://myendpoint/collections/mycollection/items/oneitem/WorldCRS84Quad/tilejson.json?tile_scale=2&amp;expression=B01/B02&amp;asset_as_band=True</code></li> </ul>"},{"location":"item_endpoints/#bounds","title":"Bounds","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/bounds</code> - Return the bounds of the STAC item.</p> <ul> <li>PathParams:<ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/bounds</code></li> </ul>"},{"location":"item_endpoints/#info","title":"Info","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/info</code> - Return basic info on STAC item's COG.</p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names. Default to all available assets.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/info?assets=B01</code></li> </ul> <p><code>:endpoint:/collections/{collection_id}/items/{item_id}/info.geojson</code> - Return basic info on STAC item's COG as a GeoJSON feature</p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>collection (str): STAC Collection ID. Required</li> <li>item (str): STAC Item ID. Required</li> <li>assets (array[str]): asset names. Default to all available assets.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/info.geojson?assets=B01</code></li> </ul> <p><code>:endpoint:/collections/{collection_id}/items/{item_id}/assets</code> - Return the list of available assets</p>"},{"location":"item_endpoints/#available-assets","title":"Available Assets","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/assets</code> - Return a list of available assets</p> <ul> <li>PathParams:<ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/assets</code></li> </ul>"},{"location":"item_endpoints/#statistics","title":"Statistics","text":"<p><code>:endpoint:/collections/{collection_id}/items/{item_id}/asset_statistics - [GET]</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>collection (str): STAC Collection ID. Required</li> <li>item (str): STAC Item ID. Required</li> <li>assets (array[str]): asset names. Default to all available assets.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>asset_expression (array[str]): Per asset band math expression (e.g <code>Asset1|b1\\*b2</code>).</li> <li>max_size (int): Max image size from which to calculate statistics, default is 1024.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/statistics?assets=B01&amp;categorical=true&amp;c=1&amp;c=2&amp;c=3&amp;p=2&amp;p98</code></li> </ul> <p><code>:endpoint:/collections/{collection_id}/items/{item_id}/statistics - [GET]</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>collection (str): STAC Collection ID. Required</li> <li>item (str): STAC Item ID. Required</li> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>max_size (int): Max image size from which to calculate statistics, default is 1024.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/statistics?assets=B01&amp;categorical=true&amp;c=1&amp;c=2&amp;c=3&amp;p=2&amp;p98</code></li> </ul> <p><code>:endpoint:/collections/{collection_id}/items/{item_id}/statistics - [POST]</code></p> <ul> <li> <p>Body:</p> <ul> <li>feature (JSON): A valid GeoJSON feature or FeatureCollection</li> </ul> </li> <li> <p>PathParams:</p> <ul> <li>collection_id (str): STAC Collection ID.</li> <li>item_id (str): STAC Item ID.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>max_size (int): Max image size from which to calculate statistics, default is 1024.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/collections/mycollection/items/oneitem/statistics?assets=B01&amp;categorical=true&amp;c=1&amp;c=2&amp;c=3&amp;p=2&amp;p98</code></li> </ul>"},{"location":"mosaic_endpoints/","title":"Mosaic","text":"<p>The <code>titiler.pgstac</code> package comes with a full FastAPI application with Mosaic and single STAC item support.</p> Method URL Output Description <code>POST</code> <code>/mosaic/register</code> JSON (Register) Register Search query <code>GET</code> <code>/mosaic/{searchid}/info</code> JSON (Info) Return Search query infos <code>GET</code> <code>/mosaic/list</code> JSON (Infos) Return list of Search entries with <code>Mosaic</code> type <code>GET</code> <code>/mosaic/{searchid}/{lon},{lat}/assets</code> JSON Return a list of assets which overlap a given point <code>GET</code> <code>/mosaic/{searchid}/tiles[/{TileMatrixSetId}]/{z}/{x}/{Y}/assets</code> JSON Return a list of assets which overlap a given tile <code>GET</code> <code>/mosaic/{searchid}/tiles[/{TileMatrixSetId}]/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin Create a web map tile image for a search query and a tile index <code>GET</code> <code>/mosaic/{searchid}[/{TileMatrixSetId}]/tilejson.json</code> JSON (TileJSON) Return a Mapbox TileJSON document <code>GET</code> <code>/mosaic/{searchid}[/{TileMatrixSetId}]/WMTSCapabilities.xml</code> XML return OGC WMTS Get Capabilities <code>GET</code> <code>/mosaic/{searchid}[/{TileMatrixSetId}]/map</code> HTML simple map viewer <code>POST</code> <code>/mosaic/{searchid}/statistics</code> GeoJSON (Statistics) Return statistics for geojson features <code>GET</code> <code>/mosaic/{searchid}/bbox/{minx},{miny},{maxx},{maxy}[/{width}x{height}].{format}</code> image/bin Create an image from part of a dataset <code>POST</code> <code>/mosaic/{searchid}/feature[/{width}x{height}][.{format}]</code> image/bin Create an image from a GeoJSON feature"},{"location":"mosaic_endpoints/#register-a-search-request","title":"Register a Search Request","text":"<p><code>:endpoint:/mosaic/register - [POST]</code></p> <ul> <li>Body (a combination of Search+Metadata): A JSON body composed of a valid STAC Search query (see: github.com/radiantearth/stac-api-spec/tree/master/item-search) and Mosaic's metadata.</li> </ul> <pre><code>// titiler-pgstac search body example\n{\n  // STAC search query\n  \"collections\": [\n    \"string\"\n  ],\n  \"ids\": [\n    \"string\"\n  ],\n  \"bbox\": [\n    \"number\",\n    \"number\",\n    \"number\",\n    \"number\"\n  ],\n  \"intersects\": {\n    \"type\": \"Point\",\n    \"coordinates\": [\n      \"number\",\n      \"number\"\n    ]\n  },\n  \"query\": {\n    \"additionalProp1\": {},\n    \"additionalProp2\": {},\n    \"additionalProp3\": {}\n  },\n  \"filter\": {},\n  \"datetime\": \"string\",\n  \"sortby\": \"string\",\n  \"filter-lang\": \"cql-json\",\n  // titiler-pgstac mosaic metadata\n  \"metadata\": {\n    \"type\": \"mosaic\",\n    \"bounds\": [\n      \"number\",\n      \"number\",\n      \"number\",\n      \"number\"\n    ],\n    \"minzoom\": \"number\",\n    \"maxzoom\": \"number\",\n    \"name\": \"string\",\n    \"assets\": [\n      \"string\",\n      \"string\",\n    ],\n    \"defaults\": {}\n  }\n}\n</code></pre> <p>Important</p> <p>In <code>titiler-pgstac</code> we extended the regular <code>stac</code> search to add a metadata entry. Metadata defaults to <code>{\"type\": \"mosaic\"}</code>.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/mosaic/register</code></li> </ul> <pre><code>curl -X 'POST' 'http://127.0.0.1:8081/mosaic/register' -H 'accept: application/json' -H 'Content-Type: application/json' -d '{\"collections\":[\"landsat-c2l2-sr\"], \"bbox\":[-123.75,34.30714385628804,-118.125,38.82259097617712], \"filter-lang\": \"cql-json\"}' | jq\n&gt;&gt; {\n  \"searchid\": \"5a1b82d38d53a5d200273cbada886bd7\",\n  \"links\": [\n    {\n      \"rel\": \"metadata\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/5a1b82d38d53a5d200273cbada886bd7/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/5a1b82d38d53a5d200273cbada886bd7/tilejson.json\"\n    }\n  ]\n}\n\n# or using CQL2\ncurl -X 'POST' 'http://127.0.0.1:8081/mosaic/register' -H 'accept: application/json' -H 'Content-Type: application/json' -d '{\"filter\": {\"op\": \"=\", \"args\": [{\"property\": \"collection\"}, \"landsat-c2l2-sr\"]}}'\n\n# or using CQL2 with metadata\ncurl -X 'POST' 'http://127.0.0.1:8081/mosaic/register' -H 'accept: application/json' -H 'Content-Type: application/json' -d '{\"filter\": {\"op\": \"=\", \"args\": [{\"property\": \"collection\"}, \"landsat-c2l2-sr\"]}, \"metadata\": {\"name\": \"landsat mosaic\"}}'\n</code></pre>"},{"location":"mosaic_endpoints/#search-infos","title":"Search infos","text":"<p><code>:endpoint:/mosaic/{searchid}/info - [GET]</code></p> <ul> <li>PathParams:<ul> <li>searchid: search query hashkey.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/mosaic/5a1b82d38d53a5d200273cbada886bd7/info</code></li> </ul> <pre><code>curl 'http://127.0.0.1:8081/mosaic/5a1b82d38d53a5d200273cbada886bd7/info' | jq\n&gt;&gt; {\n  \"search\": {\n    \"hash\": \"5a1b82d38d53a5d200273cbada886bd7\",\n    \"search\": {\n      \"bbox\": [\n        -123.75,\n        34.30714385628804,\n        -118.125,\n        38.82259097617712\n      ],\n      \"collections\": [\n        \"landsat-c2l2-sr\"\n      ],\n      \"filter-lang\": \"cql-json\"\n    },\n    \"_where\": \"(  TRUE  )  AND collection_id = ANY ('{landsat-c2l2-sr}')  AND geometry &amp;&amp; '0103000020E610000001000000050000000000000000F05EC055F6687D502741400000000000F05EC02D553EA94A6943400000000000885DC02D553EA94A6943400000000000885DC055F6687D502741400000000000F05EC055F6687D50274140' \",\n    \"orderby\": \"datetime DESC, id DESC\",\n    \"lastused\": \"2022-03-03T11:42:07.213313+00:00\",\n    \"usecount\": 2,\n    \"metadata\": {\n      \"type\": \"mosaic\"\n    }\n  },\n  \"links\": [\n    {\n      \"rel\": \"self\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/5a1b82d38d53a5d200273cbada886bd7/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/5a1b82d38d53a5d200273cbada886bd7/tilejson.json\"\n    }\n  ]\n}\n</code></pre>"},{"location":"mosaic_endpoints/#list-searches","title":"List Searches","text":"<p><code>:endpoint:/mosaic/list - [GET]</code></p> <ul> <li>QueryParams:<ul> <li>limit (int): Page size limit, Default is <code>10</code>.</li> <li>offset (int): Page offset.</li> <li>sortby (str): Sort the searches by Metadata properties (ascending (default) or descending (<code>-</code>)).</li> </ul> </li> </ul> <p>Important</p> <p>Additional query-parameters (form <code>PROP=VALUE</code>) will be considered as a property filter.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/mosaic/list</code></li> <li><code>https://myendpoint/mosaic/list?limit=100</code></li> <li><code>https://myendpoint/mosaic/list?limit=10&amp;offset=10</code> (page 2)</li> <li><code>https://myendpoint/mosaic/list?data=noaa</code> (only show mosaics with <code>metadata.data == noaa</code>)</li> <li><code>https://myendpoint/mosaic/list?sortby=lastused</code> (sort mosaic by <code>lastused</code> pgstac search property)</li> <li><code>https://myendpoint/mosaic/list?sortby=-prop</code> (sort mosaic (descending) by <code>metadata.prop</code> values)</li> </ul>"},{"location":"mosaic_endpoints/#tiles","title":"Tiles","text":"<p><code>:endpoint:/mosaic/{searchid}/tiles[/{TileMatrixSetId}]/{z}/{x}/{y}[@{scale}x][.{format}]</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>searchid: search query hashkey.</li> <li>TileMatrixSetId: TileMatrixSet name, default is <code>WebMercatorQuad</code>. OPTIONAL</li> <li>z: Tile's zoom level.</li> <li>x: Tile's column.</li> <li>y: Tile's row.</li> <li>scale: Tile size scale, default is set to 1 (256x256). OPTIONAL</li> <li>format: Output image format, default is set to None and will be either JPEG or PNG depending on masked value. OPTIONAL</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>nodata: Overwrite internal Nodata value. OPTIONAL</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Add buffer on each side of the tile (e.g 0.5 = 257x257, 1.0 = 258x258).</li> <li>pixel_selection (str): Pixel selection method (cogeotiff.github.io/rio-tiler/mosaic/).</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/tiles/1/2/3?assets=B01</code></li> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/tiles/1/2/3.jpg?assets=B01</code></li> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/tiles/WorldCRS84Quad/1/2/3@2x.png?assets=B01&amp;assets=B02&amp;assets=B03</code></li> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/tiles/WorldCRS84Quad/1/2/3?assets=B01&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul>"},{"location":"mosaic_endpoints/#tilesjson","title":"TilesJSON","text":"<p><code>:endpoint:/mosaic/{searchid}[/{TileMatrixSetId}]/tilejson.json</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>searchid: search query hashkey.</li> <li>TileMatrixSetId: TileMatrixSet name, default is <code>WebMercatorQuad</code>. OPTIONAL</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>tile_format: Output image format, default is set to None and will be either JPEG or PNG depending on masked value.</li> <li>tile_scale: Tile size scale, default is set to 1 (256x256). OPTIONAL</li> <li>minzoom: Overwrite default minzoom. OPTIONAL</li> <li>maxzoom: Overwrite default maxzoom. OPTIONAL</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Add buffer on each side of the tile (e.g 0.5 = 257x257, 1.0 = 258x258).</li> <li>pixel_selection (str): Pixel selection method (cogeotiff.github.io/rio-tiler/mosaic/).</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/tilejson.json?assets=B01</code></li> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/tilejson.json?assets=B01&amp;tile_format=png</code></li> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/WorldCRS84Quad/tilejson.json?assets=B01&amp;tile_scale=2</code></li> </ul>"},{"location":"mosaic_endpoints/#wmts","title":"WMTS","text":"<p><code>:endpoint:/mosaic/{searchid}[/{TileMatrixSetId}]/WMTSCapabilities.xml</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>searchid: search query hashkey.</li> <li>TileMatrixSetId: TileMatrixSet name, default is <code>WebMercatorQuad</code>. OPTIONAL</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>tile_format: Output image format, default is set to PNG.</li> <li>tile_scale: Tile size scale, default is set to 1 (256x256). OPTIONAL</li> <li>minzoom: Overwrite default minzoom. OPTIONAL</li> <li>maxzoom: Overwrite default maxzoom. OPTIONAL</li> </ul> </li> </ul> <p>Important</p> <p>additional query-parameters will be forwarded to the <code>tile</code> URL. If no <code>defaults</code> mosaic metadata, assets OR expression will be required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/WMTSCapabilities.xml?assets=B01</code></li> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/WMTSCapabilities.xml?assets=B01&amp;tile_format=png</code></li> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/WorldCRS84Quad/WMTSCapabilities.xml?assets=B01&amp;tile_scale=2</code></li> </ul>"},{"location":"mosaic_endpoints/#assets","title":"Assets","text":"<p><code>:endpoint:/mosaic/{searchid}/tiles/[{TileMatrixSetId}]/{z}/{x}/{y}/assets</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>searchid: search query hashkey.</li> <li>TileMatrixSetId: TileMatrixSet name, default is <code>WebMercatorQuad</code>. OPTIONAL</li> <li>z: Tile's zoom level.</li> <li>x: Tile's column.</li> <li>y: Tile's row.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/tiles/0/0/0/assets</code></li> </ul> <p><code>:endpoint:/mosaic/{searchid}/{lon},{lat}/assets</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>searchid: search query hashkey.</li> <li>lon: Longitude (in WGS84 CRS).</li> <li>lat: Latitude (in WGS84 CRS).</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/0.0,0.0/assets</code></li> </ul>"},{"location":"mosaic_endpoints/#statistics","title":"Statistics","text":"<p><code>:endpoint:/mosaic/{searchid}/statistics - [POST]</code></p> <ul> <li> <p>Body:</p> <ul> <li>feature (JSON): A valid GeoJSON feature or FeatureCollection</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input geometry. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size from which to calculate statistics.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>nodata: Overwrite internal Nodata value. OPTIONAL</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds.</li> <li>pixel_selection (str): Pixel selection method (cogeotiff.github.io/rio-tiler/mosaic/).</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> </ul> </li> </ul> <p>Important</p> <p>if height and width are provided max_size will be ignored.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/statistics?assets=B01</code></li> </ul>"},{"location":"mosaic_endpoints/#bboxfeature","title":"BBOX/Feature","text":"<p><code>:endpoint:/mosaic/{searchid}/bbox/{minx},{miny},{maxx},{maxy}.{format}</code></p> <p><code>:endpoint:/mosaic/{searchid}/bbox/{minx},{miny},{maxx},{maxy}/{width}x{height}.{format}</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>searchid: search query hashkey.</li> <li>minx,miny,maxx,maxy (str): Comma (',') delimited bounding box in WGS84.</li> <li>format (str): Output image format.</li> <li>height (int): Force output image height.</li> <li>width (int): Force output image width.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input coordinates. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size.</li> <li>nodata: Overwrite internal Nodata value. OPTIONAL</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>pixel_selection (str): Pixel selection method (cogeotiff.github.io/rio-tiler/mosaic/).</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> </ul> </li> </ul> <p>Important</p> <p>if height and width are provided max_size will be ignored.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/bbox/0,0,10,10.png?assets=B01</code></li> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/bbox/0,0,10,10/400x300.png?assets=B01</code></li> </ul> <p><code>:endpoint:/mosaic/{searchid}/feature[/{width}x{height}][].{format}] - [POST]</code></p> <ul> <li> <p>Body:</p> <ul> <li>feature (JSON): A valid GeoJSON feature (Polygon or MultiPolygon)</li> </ul> </li> <li> <p>PathParams:</p> <ul> <li>height (int): Force output image height. Optional</li> <li>width (int): Force output image width. Optional</li> <li>format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1;2;3</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input geometry. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size.</li> <li>nodata: Overwrite internal Nodata value. OPTIONAL</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): rasterio resampling method. Default is <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>pixel_selection (str): Pixel selection method (cogeotiff.github.io/rio-tiler/mosaic/).</li> <li>scan_limit (int): Return as soon as we scan N items, Default is 10,000 in PgSTAC.</li> <li>items_limit (int): Return as soon as we have N items per geometry, Default is 100 in PgSTAC.</li> <li>time_limit (int): Return after N seconds to avoid long requests, Default is 5sec in PgSTAC.</li> <li>exitwhenfull (bool): Return as soon as the geometry is fully covered, Default is <code>True</code> in PgSTAC.</li> <li>skipcovered (bool): Skip any items that would show up completely under the previous items, Default is <code>True</code> in PgSTAC.</li> </ul> </li> </ul> <p>Important</p> <p>if height and width are provided max_size will be ignored.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/feature?assets=B01</code></li> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/feature.png?assets=B01f</code></li> <li><code>https://myendpoint/mosaic/f1ed59f0a6ad91ed80ae79b7b52bc707/feature/100x100.png?assets=B01</code></li> </ul>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#080-2023-10-06","title":"0.8.0 (2023-10-06)","text":"<ul> <li>update titiler requirement to <code>&gt;=0.14.0,&lt;0.15</code></li> <li>remove <code>max_size</code> default for mosaic's <code>/statistics [POST]</code> endpoint  breaking change</li> <li>add <code>/bbox</code> and <code>/feature [POST]</code> optional endpoints</li> <li>add <code>img_part_dependency</code> attribute in <code>MosaicTilerFactory</code> (defaults to <code>titiler.code.dependencies.PartFeatureParams</code>)</li> </ul>"},{"location":"release-notes/#070-2023-09-28","title":"0.7.0 (2023-09-28)","text":"<ul> <li>update requirements to switch to pydantic~=2.0</li> <li>pydantic&gt;=2.4,&lt;3.0</li> <li>pydantic-settings~=2.0</li> <li>geojson-pydantic~=1.0</li> <li> <p>cogeo-mosaic&gt;=7.0,&lt;8.0</p> </li> <li> <p>update titiler requirement to <code>&gt;=0.14.0,&lt;0.15</code></p> <ul> <li> <p>replace <code>-</code> by <code>_</code> in query parameters</p> <ul> <li>coord-crs -&gt; coord_crs</li> <li>dst-crs -&gt; dst_crs</li> </ul> </li> </ul> </li> </ul>"},{"location":"release-notes/#060-2023-09-18","title":"0.6.0 (2023-09-18)","text":"<ul> <li>add <code>tilejson</code> URL links for <code>layers</code> defined in mosaic's metadata in <code>/mosaic/register</code> and <code>/mosaic/{mosaic_id}/info</code> response</li> <li>support multiple <code>layers</code> in <code>/mosaic/{mosaic_id}/WMTSCapabilities.xml</code> endpoint created from mosaic's metadata</li> </ul> <p>breaking change</p> <ul> <li> <p>In <code>/mosaic/WMTSCapabilities.xml</code> we removed the query-parameters related to the <code>tile</code> endpoint (which are forwarded) so <code>?assets=</code> is no more required. The endpoint will still raise an error if there are no <code>layers</code> in the mosaic metadata and no required tile's parameters are passed.</p> <pre><code># before\nresponse = httpx.get(\"/mosaic/{mosaic_id}/WMTSCapabilities.xml\")\nassert response.status_code == 400\n\nresponse = httpx.get(\"/mosaic/{mosaic_id}/WMTSCapabilities.xml?assets=cog\")\nassert response.status_code == 200\n\n# now\n# If the mosaic has `defaults` layers set in the metadata\n# we will construct a WMTS document with multiple layers, so no need for the user to pass any `assets=`\nresponse = httpx.get(\"/mosaic/{mosaic_id}/WMTSCapabilities.xml\")\nassert response.status_code == 200\nwith rasterio.open(io.BytesIO(response.content)) as src:\n    assert src.profile[\"driver\"] == \"WMTS\"\n    assert len(src.subdatasets) == 2\n\n# If the user pass any valid `tile` parameters, an additional layer will be added to the one from the metadata\nresponse = httpx.get(\"/mosaic/{mosaic_id}/WMTSCapabilities.xml?assets=cog\")\nassert response.status_code == 200\nwith rasterio.open(io.BytesIO(response.content)) as src:\n    assert src.profile[\"driver\"] == \"WMTS\"\n    assert len(src.subdatasets) == 3\n</code></pre> </li> </ul>"},{"location":"release-notes/#051-2023-08-03","title":"0.5.1 (2023-08-03)","text":"<ul> <li>add <code>python-dotenv</code> requirement</li> </ul>"},{"location":"release-notes/#050-2023-07-20","title":"0.5.0 (2023-07-20)","text":"<ul> <li>update <code>titiler</code> requirement to <code>&gt;=0.12.0,&lt;0.13</code></li> <li>use <code>Annotated</code> Type for Query/Path parameters</li> <li>re-order endpoints in <code>MosaicTilerFactory</code> to avoid conflicts between <code>tiles</code> and <code>assets</code> endpoints</li> <li>remove <code>stac-pydantic</code> dependency</li> <li>add optional <code>root_path</code> setting to specify a url path prefix to use when running the app behind a reverse proxy</li> <li>add landing page <code>/</code></li> <li>use <code>lifespan</code> option instead of deprecated <code>@app.on_event</code> method to initiate/close DB connection</li> </ul> <p>breaking changes</p> <ul> <li>remove deprecated <code>/{searchid}/{z}/{x}/{y}/assets</code> endpoints</li> <li>use /api and /api.html for documentation (instead of /openapi.json and /docs)</li> <li>replace Enum's with <code>Literal</code> types</li> <li>replace variable <code>TileMatrixSetId</code> by <code>tileMatrixSetId</code></li> <li>add <code>pixel_selection_dependency</code> attribute to the <code>MosaicTilerFactory</code></li> </ul>"},{"location":"release-notes/#041-2023-06-21","title":"0.4.1 (2023-06-21)","text":"<ul> <li>update <code>titiler</code> requirement to <code>&gt;=0.11.7</code></li> <li>fix <code>/map</code> endpoint template name</li> <li>rename <code>add_map_viewer</code> to <code>add_viewer</code> option in <code>MosaicTilerFactory</code> for consistency with <code>titiler's</code> options</li> </ul>"},{"location":"release-notes/#040-2023-05-22","title":"0.4.0 (2023-05-22)","text":"<ul> <li>remove deprecated <code>/tiles/{searchid}/...</code> endpoints (replaced with <code>/{searchid}/tiles/...</code>)</li> <li>depreciate <code>/{searchid}/{z}/{x}/{y}/assets</code> endpoints and add <code>/{searchid}/tiles/{z}/{x}/{y}/assets</code></li> <li>update minimum titiler requirement to <code>&gt;=0.11.6</code></li> <li>remove timing headers</li> <li>add <code>strict_zoom</code> option (controled with <code>MOSAIC_STRICT_ZOOM</code> environment variable) to raise (or not) error when fetching tile outside mosaic min/max zoom range</li> </ul>"},{"location":"release-notes/#033-2023-04-27","title":"0.3.3 (2023-04-27)","text":"<ul> <li>update python packaging/build system to <code>pdm-pep517</code></li> <li>use <code>Ruff</code> for lint</li> <li>add retry mechanism on Database connection issues for <code>PGSTACBackend.get_assets()</code> and <code>get_stac_item</code> methods (back ported from 0.2.4)</li> </ul>"},{"location":"release-notes/#032-2023-03-14","title":"0.3.2 (2023-03-14)","text":"<ul> <li>update titiler requirement to <code>0.10.2</code></li> <li>fix maximum version of FastAPI to 0.92 (to avoid breaking change of starlette &gt;0.25)</li> </ul>"},{"location":"release-notes/#031-2022-12-16","title":"0.3.1 (2022-12-16)","text":"<ul> <li>update Type information for <code>dependencies.get_stac_item</code> (back ported from 0.2.2)</li> </ul>"},{"location":"release-notes/#030-2022-12-16","title":"0.3.0 (2022-12-16)","text":"<p>breaking changes</p> <ul> <li> <p>Use <code>/collections/{collection_id}/items/{item_id}</code> prefix for Item endpoint.     <pre><code># Before\n{endpoint}/stac/info?collection=collection1&amp;item=item1\n\n# Now\n{endpoint}/collections/collection1/items/item1/info\n</code></pre></p> </li> <li> <p>Change tile url path parameter order from <code>/tiles/{searchid}/{TileMatrixSetId}/{z}/{x}/{y}</code> to <code>/{searchid}/tiles/{TileMatrixSetId}/{z}/{x}/{y}</code> <pre><code># Before\n{endpoint}/mosaic/tiles/20200307aC0853900w361030/0/0/0\n\n# Now\n{endpoint}/mosaic/20200307aC0853900w361030/tiles/0/0/0\n</code></pre></p> </li> </ul>"},{"location":"release-notes/#024-2023-04-27","title":"0.2.4 (2023-04-27)","text":"<ul> <li>add retry mechanism on Database connection issues for <code>PGSTACBackend.get_assets()</code> and <code>get_stac_item</code> methods</li> </ul>"},{"location":"release-notes/#023-2023-03-14","title":"0.2.3 (2023-03-14)","text":"<ul> <li>fix maximum version of FastAPI to 0.92 (to avoid breaking change of starlette &gt;0.25)</li> </ul>"},{"location":"release-notes/#022-2022-12-16","title":"0.2.2 (2022-12-16)","text":"<ul> <li>update Type information for <code>dependencies.get_stac_item</code></li> </ul>"},{"location":"release-notes/#021-2022-12-15","title":"0.2.1 (2022-12-15)","text":"<ul> <li>update titiler requirement to <code>&gt;=0.10.1,&lt;0.11</code> and fix <code>/map</code> endpoint (to accept multiple TMS)</li> </ul>"},{"location":"release-notes/#020-2022-12-13","title":"0.2.0 (2022-12-13)","text":"<ul> <li>add python 3.10 and 3.11 support</li> <li>update to rio-tiler 4.1</li> <li>add <code>/{searchid}/map</code> endpoint to the <code>MosaicTilerFactory</code> (added when <code>add_map_viewer</code> is set to <code>True</code>)</li> <li>add <code>/{searchid}/WMTSCapabilities.xml</code> OGC WMTS endpoint to the <code>MosaicTilerFactory</code></li> <li>add <code>/list</code> to the <code>MosaicTilerFactory</code> to list available mosaics (added when <code>add_mosaic_list</code> is set to <code>True</code>)</li> </ul> <p>breaking changes</p> <ul> <li>remove python 3.7 support</li> <li>update titiler requirement to <code>&gt;=0.10.0</code></li> <li>replace <code>connection_string</code> by <code>database_url</code> in <code>settings.PostgresSettings</code>. We can now directly set <code>DATABASE_URL</code> environment variable.</li> </ul>"},{"location":"release-notes/#frontend-changes","title":"Frontend changes","text":"<ul> <li>remove <code>asset_expression</code> (Mosaic and Item)</li> <li>histogram band names are prefixed with <code>b</code> (e.g <code>b1</code>) (Mosaic and Item) (ref: github.com/cogeotiff/rio-tiler/blob/main/docs/src/v4_migration.md#band-names)</li> <li>expression for STAC have to be in form of <code>{asset}_b{band_name}</code> (e.g <code>red_b1/green_b1</code>) (Mosaic and Item) (ref: github.com/cogeotiff/rio-tiler/blob/main/docs/src/v4_migration.md#multibasereader-expressions)</li> <li>added <code>asset_as_band</code> option to force expression to be in form of <code>{asset}</code> (e.g <code>red/green</code>) (Mosaic and Item)</li> <li>expression's band should now be delimited with <code>;</code> (previously <code>,</code> was accepted) (Mosaic and Item)</li> <li>point output model to include band_names (Item)</li> <li>added <code>algorithm</code> options</li> </ul>"},{"location":"release-notes/#010-2022-06-27","title":"0.1.0 (2022-06-27)","text":"<ul> <li>update <code>titiler.core</code> and <code>titiler.mosaic</code> requirement to <code>0.7</code></li> <li>add <code>MosaicTilerFactory._tilejson_routes</code> method to register <code>TileJSON</code> routes</li> <li>raise <code>cogeo_mosaic.errors.MosaicNotFoundError</code> when SearchId is not found in pgstac.searches table</li> </ul> <p>breaking changes</p> <ul> <li>move version definition in <code>titiler.pgstac.__version__</code></li> <li>remove unused <code>fetch_options</code> in <code>titiler.pgstac.reader.PgSTACReader</code></li> </ul>"},{"location":"release-notes/#010a10-2022-05-16-pre-release","title":"0.1.0a10 (2022-05-16) Pre-Release","text":"<ul> <li>update <code>titiler</code> version and add <code>reader_dependency</code> and <code>backend_dependency</code> in endpoint factory.</li> </ul>"},{"location":"release-notes/#010a9-2022-05-05-pre-release","title":"0.1.0.a9 (2022-05-05) Pre-Release","text":"<ul> <li>remove LRU cache on all settings classes to enable support for manually providing settings via keyword arguments and to minimize lines of code (author @alukach, stac-utils/titiler-pgstac!54)</li> </ul>"},{"location":"release-notes/#010a8-2022-05-02-pre-release","title":"0.1.0.a8 (2022-05-02) Pre-Release","text":"<ul> <li>Insert mosaic metadata <code>min/max zoom</code> and <code>bounds</code> in tilejson (stac-utils/titiler-pgstac!51)</li> <li>allow users the ability to optionally provide <code>PostgresSettings</code> to <code>connect_to_db()</code> function in the event that they want to customize how their DB credentials are populated (author @alukach, stac-utils/titiler-pgstac!53)</li> </ul>"},{"location":"release-notes/#010a7-2022-04-05-pre-release","title":"0.1.0.a7 (2022-04-05) Pre-Release","text":"<ul> <li>add <code>feature()</code> method to <code>PGSTACBackend</code> mosaic backend</li> <li>add <code>/statistics</code> endpoint to return statistics given a GeoJSON feature or featureCollection</li> <li>add <code>collection</code> in allowed returned fields</li> <li>switch to <code>pgstac.search</code> to get the STAC Item in <code>titiler.pgstac.dependencies.get_stac_item</code> (stac-utils/titiler-pgstac!50)</li> </ul>"},{"location":"release-notes/#010a6-2022-03-14-pre-release","title":"0.1.0.a6 (2022-03-14) Pre-Release","text":"<ul> <li>move dependencies to <code>titiler.pgstac.dependencies</code></li> <li>add <code>/stac</code> endpoints to work with PgSTAC items</li> </ul> <p>breaking changes</p> <ul> <li>add <code>/mosaic</code> prefix to the PgSTAC mosaic endpoints</li> </ul>"},{"location":"release-notes/#010a5-2022-03-03-pre-release","title":"0.1.0.a5 (2022-03-03) Pre-Release","text":"<ul> <li>Add <code>search_dependency</code> to allow customization of the PgSTAC Search query (Author @drnextgis, stac-utils/titiler-pgstac!41)</li> <li>Add PgSTAC Search entries model (stac-utils/titiler-pgstac!43)</li> <li>Add <code>Metadata</code> specification (stac-utils/titiler-pgstac!38)</li> </ul> <p>breaking changes</p> <ul> <li>update <code>titiler.core</code> and <code>titiler.mosaic</code> requirement to <code>&gt;=0.5</code></li> <li>When registering a <code>search</code> to PgSTAC with the <code>/register</code> endpoint, a default metadata <code>{\"type\": \"mosaic\"}</code> will be set.</li> <li>Renamed <code>titiler.pgstac.models</code> to <code>titiler.pgstac.model</code></li> <li>Renamed <code>titiler.pgstac.models.SearchQuery</code> to <code>titiler.pgstac.model.PgSTACSearch</code> (and removed <code>metadata</code>)</li> <li> <p>output response for <code>/register</code> endpoint: <pre><code>// before\n{\n    \"searchid\": \"...\",\n    \"metadata\": \"http://endpoint/.../info\",\n    \"tiles\": \"http://endpoint/.../tilejson.json\",\n}\n\n// now\n{\n    \"searchid\": \"...\",\n    \"links\": [\n        {\n            \"rel\": \"info\",\n            \"href\": \"http://endpoint/.../info\",\n            \"type\": \"application/json\",\n        },\n        {\n            \"rel\": \"tilejson\",\n            \"href\": \"http://endpoint/.../tilejson.json\",\n            \"type\": \"application/json\",\n        }\n    ]\n}\n</code></pre></p> </li> <li> <p>output response for <code>/info</code> endpoint: <pre><code>// before\n{\n    \"hash\": \"...\",\n    \"search\": {},\n    \"_where\": \"...\",\n    ...\n}\n\n// now\n{\n    \"search\": {\n        \"hash\": \"...\",\n        \"search\": {},\n        \"_where\": \"...\",\n        ...\n    },\n    \"links\": [\n        {\n            \"rel\": \"self\",\n            \"href\": \"http://endpoint/.../info\",\n            \"type\": \"application/json\",\n        },\n        {\n            \"rel\": \"tilejson\",\n            \"href\": \"http://endpoint/.../tilejson.json\",\n            \"type\": \"application/json\",\n        }\n    ]\n}\n</code></pre></p> </li> </ul>"},{"location":"release-notes/#010a4-2022-02-07-pre-release","title":"0.1.0.a4 (2022-02-07) Pre-Release","text":"<ul> <li>add tile <code>buffer</code> option to match rio-tiler tile options (stac-utils/titiler-pgstac!31)</li> </ul>"},{"location":"release-notes/#010a3-2021-12-15-pre-release","title":"0.1.0.a3 (2021-12-15) Pre-Release","text":"<ul> <li>Forward TMS to the STAC Reader (allow multiple TMS) (stac-utils/titiler-pgstac!28)</li> </ul>"},{"location":"release-notes/#010a2-2021-12-13-pre-release","title":"0.1.0.a2 (2021-12-13) Pre-Release","text":"<ul> <li>Switch to psycopg3</li> <li>add <code>filter-lang</code> in Search model to support newer PgSTAC (with CQL-2)</li> <li>add <code>metadata</code> in Search model to allow forwarding metadata to the search query entry in PgSTAC</li> </ul> <p>breaking changes</p> <ul> <li>Unify reader/writer db pools to <code>request.app.state.dbpool</code></li> <li>rename <code>PostgresSettings.db_max_inactive_conn_lifetime</code> to <code>PostgresSettings.max_idle</code></li> <li>remove <code>PostgresSettings().reader_connection_string</code> and <code>PostgresSettings().writer_connection_string</code>. Replaced with <code>PostgresSettings().connection_string</code></li> <li>update titiler requirement (&gt;= 0.4)</li> </ul>"},{"location":"release-notes/#010a1-2021-09-15-pre-release","title":"0.1.0.a1 (2021-09-15) Pre-Release","text":"<ul> <li>Surface PgSTAC options (<code>scan_limit</code>, <code>items_limit</code>, <code>time_limit</code>, <code>exitwhenfull</code> and <code>skipcovered</code>) in Tile endpoints</li> </ul> <p>breaking changes</p> <ul> <li>remove <code>psycopg2</code> requirements to avoid conflict with <code>psycopg2-binary</code> (stac-utils/titiler-pgstac!15)</li> </ul>"},{"location":"release-notes/#010a0-2021-09-06-pre-release","title":"0.1.0.a0 (2021-09-06) Pre-Release","text":"<p>Initial release</p>"},{"location":"tiler_factories/","title":"Tiler Factories","text":"<p><code>TiTiler.PgSTAC</code> provides a <code>MosaicTilerFactory</code> factory which is an helper functions to create FastAPI router (<code>fastapi.APIRouter</code>) with a minimal set of endpoints.</p>"},{"location":"tiler_factories/#titilerpgstacfactorymosaictilerfactory","title":"<code>titiler.pgstac.factory.MosaicTilerFactory</code>","text":"<pre><code># Minimal PgSTAC Mosaic Application\nfrom contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI\nfrom titiler.pgstac.db import close_db_connection, connect_to_db\nfrom titiler.pgstac.factory import MosaicTilerFactory\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"FastAPI Lifespan.\"\"\"\n    # Create Connection Pool\n    await connect_to_db(app)\n    yield\n    # Close the Connection Pool\n    await close_db_connection(app)\n\n\napp = FastAPI(lifespan=lifespan)\n\nmosaic = MosaicTilerFactory()\napp.include_router(mosaic.router)\n</code></pre> Method URL Output Description <code>POST</code> <code>/register</code> JSON (Register) Register Search query  OPTIONAL <code>GET</code> <code>/list</code> JSON (Info) Return Search query infos  OPTIONAL <code>GET</code> <code>/{searchid}/info</code> JSON (Infos) Return list of Search entries with <code>Mosaic</code> type  OPTIONAL <code>GET</code> <code>/{searchid}/{lon},{lat}/assets</code> JSON Return a list of assets which overlap a given point <code>GET</code> <code>/{searchid}/tiles[/{TileMatrixSetId}]/{z}/{x}/{Y}/assets</code> JSON Return a list of assets which overlap a given tile <code>GET</code> <code>/{searchid}/tiles[/{TileMatrixSetId}]/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin Create a web map tile image for a search query and a tile index <code>GET</code> <code>/{searchid}[/{TileMatrixSetId}]/tilejson.json</code> JSON (TileJSON) Return a Mapbox TileJSON document <code>GET</code> <code>/{searchid}[/{TileMatrixSetId}]/WMTSCapabilities.xml</code> XML Return OGC WMTS Get Capabilities <code>GET</code> <code>/{searchid}[/{TileMatrixSetId}]/map</code> HTML Simple map viewer OPTIONAL <code>POST</code> <code>/{searchid}/statistics</code> GeoJSON (Statistics) Return statistics for geojson features OPTIONAL <code>GET</code> <code>/{searchid}/bbox/{minx},{miny},{maxx},{maxy}[/{width}x{height}].{format}</code> image/bin Create an image from part of a dataset OPTIONAL <code>POST</code> <code>/{searchid}/feature[/{width}x{height}][.{format}]</code> image/bin Create an image from a GeoJSON feature OPTIONAL"},{"location":"tiler_factories/#item","title":"Item","text":"<p>For the <code>single STAC item</code> endpoints we use TiTiler's <code>MultiBaseTilerFactory</code> with a custom <code>path_dependency</code> to use <code>item</code> and <code>collection</code> path parameter (instead of the default <code>url</code> query param).</p> <p>This custom <code>path_dependency</code> will connect to PgSTAC directly to fetch the STAC Item and pass it to a custom Reader based on <code>rio_tiler.io.MultiBaseReader</code>.</p> <pre><code># Minimal PgSTAC Item Application\nfrom contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI\n\nfrom titiler.core.factory import MultiBaseTilerFactory\n\nfrom titiler.pgstac.db import close_db_connection, connect_to_db\nfrom titiler.pgstac.dependencies import ItemPathParams\nfrom titiler.pgstac.reader import PgSTACReader\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"FastAPI Lifespan.\"\"\"\n    # Create Connection Pool\n    await connect_to_db(app)\n    yield\n    # Close the Connection Pool\n    await close_db_connection(app)\n\n\napp = FastAPI(lifespan=lifespan)\n\nitem = MultiBaseTilerFactory(\n    reader=PgSTACReader,\n    path_dependency=ItemPathParams,\n    router_prefix=\"/collections/{collection_id}/items/{item_id}\",\n)\napp.include_router(item.router, prefix=\"/collections/{collection_id}/items/{item_id}\")\n</code></pre>"},{"location":"tms_endpoints/","title":"TileMatrixSet","text":"Method URL Output Description <code>GET</code> <code>/tileMatrixSets</code> JSON (TMS list) return the list of supported TileMatrixSet <code>GET</code> <code>/tileMatrixSets/{TileMatrixSetId}</code> JSON (TileMatrixSet) return the TileMatrixSet JSON document"},{"location":"tms_endpoints/#list-tms","title":"List TMS","text":"<p><code>:endpoint:/tileMatrixSets</code> - Get the list of supported TileMatrixSet</p> <pre><code>curl https://myendpoint/tileMatrixSets | jq\n&gt;&gt; {\n  \"tileMatrixSets\": [\n    {\n      \"id\": \"LINZAntarticaMapTilegrid\",\n      \"title\": \"LINZ Antarctic Map Tile Grid (Ross Sea Region)\",\n      \"links\": [\n        {\n          \"href\": \"https://myendpoint/tileMatrixSets/LINZAntarticaMapTilegrid\",\n          \"rel\": \"item\",\n          \"type\": \"application/json\"\n        }\n      ]\n    },\n    ...\n  ]\n}\n</code></pre>"},{"location":"tms_endpoints/#get-tms-info","title":"Get TMS info","text":"<p><code>:endpoint:/tileMatrixSets/{TileMatrixSetId}</code> - Get the TileMatrixSet JSON document</p> <ul> <li>PathParams:<ul> <li>TileMatrixSetId: TileMatrixSet name</li> </ul> </li> </ul> <pre><code>curl http://127.0.0.1:8000/tileMatrixSets/WebMercatorQuad | jq\n&gt;&gt; {\n  \"type\": \"TileMatrixSetType\",\n  \"title\": \"Google Maps Compatible for the World\",\n  \"identifier\": \"WebMercatorQuad\",\n  \"supportedCRS\": \"http://www.opengis.net/def/crs/EPSG/0/3857\",\n  \"wellKnownScaleSet\": \"http://www.opengis.net/def/wkss/OGC/1.0/GoogleMapsCompatible\",\n  \"boundingBox\": {\n    \"type\": \"BoundingBoxType\",\n    \"crs\": \"http://www.opengis.net/def/crs/EPSG/0/3857\",\n    \"lowerCorner\": [\n      -20037508.3427892,\n      -20037508.3427892\n    ],\n    \"upperCorner\": [\n      20037508.3427892,\n      20037508.3427892\n    ]\n  },\n  \"tileMatrix\": [\n    {\n      \"type\": \"TileMatrixType\",\n      \"identifier\": \"0\",\n      \"scaleDenominator\": 559082264.028717,\n      \"topLeftCorner\": [\n        -20037508.3427892,\n        20037508.3427892\n      ],\n      \"tileWidth\": 256,\n      \"tileHeight\": 256,\n      \"matrixWidth\": 1,\n      \"matrixHeight\": 1\n    },\n    ...\n</code></pre>"},{"location":"advanced/custom_search/","title":"Custom search model","text":"<p>Even though <code>TiTiler.PgSTAC</code> includes default FastAPI application, it also can be used like a library if you want to extend or override default behavior.</p> <p>Let's look at one such example. Imagine that we use JSON Web Token (JWT) based approach for authorization and every token contains information about area a user has access to:</p> <pre><code>{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"iat\": 1516239022,\n  \"scope\": \"zone_A\"\n}\n</code></pre> <p>We want our application to take this information into account while registering a search query. It can be done in the following way:</p> <pre><code>from contextlib import asynccontextmanager\n\nfrom typing import Tuple\nimport json\nimport jwt\nfrom fastapi import FastAPI\nfrom fastapi.security.utils import get_authorization_scheme_param\nfrom starlette.requests import Request\nfrom titiler.pgstac.factory import MosaicTilerFactory\nfrom titiler.pgstac.model import RegisterMosaic, Metadata, PgSTACSearch\nfrom titiler.pgstac.db import close_db_connection, connect_to_db\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"FastAPI Lifespan.\"\"\"\n    # Create Connection Pool\n    await connect_to_db(app, settings=postgres_settings)\n    yield\n    # Close the Connection Pool\n    await close_db_connection(app)\n\napp = FastAPI(lifespan=lifespan)\n\nAREAS = {\n    \"zone_A\": {\"type\": \"Point\", \"coordinates\": [-41.93, -12.76]},\n    \"zone_B\": {\"type\": \"Point\", \"coordinates\": [2.15, 41.39]},\n}\n\n\ndef search_factory(request: Request, body: RegisterMosaic) -&gt; Tuple[PgSTACSearch, Metadata]:\n    authorization = request.headers.get(\"Authorization\")\n    scheme, token = get_authorization_scheme_param(authorization)\n    payload = jwt.decode(token, algorithms=[\"HS256\"], key=\"your-256-bit-secret\")\n\n    search = body.dict(exclude_none=True, exclude={\"metadata\"}, by_alias=True)\n    search[\"filter\"] = {\n        \"op\": \"and\",\n        \"args\": [\n            {\n                \"op\": \"s_intersects\",\n                \"args\": [{\"property\": \"geometry\"}, AREAS[payload[\"scope\"]]],\n            },\n            search[\"filter\"],\n        ],\n    }\n\n    return model.PgSTACSearch(**search), body.metadata\n\n\nmosaic = MosaicTilerFactory(search_dependency=search_factory)\napp.include_router(mosaic.router)\n</code></pre> <p>Checking:</p> <pre><code>$ curl -s -X 'POST' \\\n  'http://localhost:8081/register' \\\n  -H 'accept: application/json' \\\n  -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJzY29wZSI6InpvbmVfQSJ9.BelzluX7v7kYObix2KSyy1T5gEOQYQn_pyNO5Ri0gWo' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"filter\":{\"op\":\"and\",\"args\":[{\"op\":\"=\",\"args\":[{\"property\":\"collection\"},\"l1\"]}]}}' | jq '.searchid'\n\"bbc3c8f4c392436f74de6cd0308469f6\"\n\n$ curl -X 'GET' \\\n  'http://localhost:8081/bbc3c8f4c392436f74de6cd0308469f6/info' \\\n  -H 'accept: application/json'\n{\"hash\":\"bbc3c8f4c392436f74de6cd0308469f6\",\"search\":{\"filter\":{\"op\":\"and\",\"args\":[{\"op\":\"s_intersects\",\"args\":[{\"property\":\"geometry\"},{\"type\":\"Point\",\"coordinates\":[-41.93,-12.76]}]},{\"op\":\"and\",\"args\":[{\"op\":\"=\",\"args\":[{\"property\":\"collection\"},\"l1\"]}]}]}},\"_where\":\"(  ( st_intersects(geometry, '0101000020E6100000D7A3703D0AF744C085EB51B81E8529C0'::geometry) and  ( (collection_id = 'l1') )  )  )  \",\"orderby\":\"datetime DESC, id DESC\",\"lastused\":\"2022-02-23T13:00:04.090757+00:00\",\"usecount\":3,\"metadata\":{\"type\":\"mosaic\"}}\n</code></pre>"},{"location":"advanced/custom_tilejson/","title":"Custom TileJSON endpoint","text":"<p>Goal: enable users to select a predefined configuration stored in the mosaic Metadata.</p> <pre><code>import sys\nfrom typing import Optional\nfrom dataclasses import dataclass\n\nfrom morecantile import TileMatrixSet\nfrom titiler.core.resources.enums import ImageType\nfrom titiler.core.models.mapbox import TileJSON\nfrom titiler.pgstac import factory as TitilerPgSTACFactory\nfrom titiler.pgstac.dependencies import PgSTACParams\n\nfrom fastapi import Depends, Query\n\nfrom starlette.requests import Request\n\nif sys.version_info &gt;= (3, 9):\n    from typing import Annotated  # pylint: disable=no-name-in-module\nelse:\n    from typing_extensions import Annotated\n\n\n@dataclass\nclass MosaicTilerFactory(TitilerPgSTACFactory.MosaicTilerFactory):\n    \"\"\"Custom factory.\"\"\"\n\n    def _tilejson_routes(self) -&gt; None:\n        \"\"\"Custom TileJSON endpoint.\"\"\"\n\n        @self.router.get(\n            \"/{searchid}/tilejson.json\",\n            response_model=TileJSON,\n            responses={200: {\"description\": \"Return a tilejson\"}},\n            response_model_exclude_none=True,\n        )\n        @self.router.get(\n            \"/{searchid}/{tileMatrixSetId}/tilejson.json\",\n            response_model=TileJSON,\n            responses={200: {\"description\": \"Return a tilejson\"}},\n            response_model_exclude_none=True,\n        )\n        def tilejson(\n            request: Request,\n            searchid=Depends(self.path_dependency),\n            tileMatrixSetId: Annotated[  # type: ignore\n                Literal[tuple(self.supported_tms.list())],\n                f\"Identifier selecting one of the TileMatrixSetId supported (default: '{self.default_tms}')\",\n            ] = self.default_tms,\n            layer: Annotated[\n                str,\n                Query(description=\"Name of default configuration\"),\n            ] = None,\n            tile_format: Annotated[\n                Optional[ImageType],\n                Query(\n                    description=\"Default will be automatically defined if the output image needs a mask (png) or not (jpeg).\",\n                ),\n            ] = None,\n            tile_scale: Annotated[\n                Optional[int],\n                Query(\n                    gt=0, lt=4, description=\"Tile size scale. 1=256x256, 2=512x512...\"\n                ),\n            ] = None,\n            minzoom: Annotated[\n                Optional[int],\n                Query(description=\"Overwrite default minzoom.\"),\n            ] = None,\n            maxzoom: Annotated[\n                Optional[int],\n                Query(description=\"Overwrite default maxzoom.\"),\n            ] = None,\n            layer_params=Depends(self.layer_dependency),\n            dataset_params=Depends(self.dataset_dependency),\n            pixel_selection=Depends(self.pixel_selection_dependency),\n            buffer: Annotated[\n                Optional[float],\n                Query(\n                    gt=0,\n                    title=\"Tile buffer.\",\n                    description=\"Buffer on each side of the given tile. It must be a multiple of `0.5`. Output **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257, 1.0 = 258x258).\",\n                ),\n            ] = None,\n            post_process=Depends(self.process_dependency),\n            rescale=Depends(self.rescale_dependency),\n            color_formula: Annotated[\n                Optional[str],\n                Query(\n                    title=\"Color Formula\",\n                    description=\"rio-color formula (info: https://github.com/mapbox/rio-color)\",\n                ),\n            ] = None,\n            colormap=Depends(self.colormap_dependency),\n            render_params=Depends(self.render_dependency),\n            pgstac_params: PgSTACParams = Depends(),\n            backend_params=Depends(self.backend_dependency),\n            reader_params=Depends(self.reader_dependency),\n        ):\n            \"\"\"Return TileJSON document for a SearchId.\"\"\"\n            with request.app.state.dbpool.connection() as conn:\n                with conn.cursor(row_factory=class_row(model.Search)) as cursor:\n                    cursor.execute(\n                        \"SELECT * FROM searches WHERE hash=%s;\",\n                        (searchid,),\n                    )\n                    search_info = cursor.fetchone()\n                    if not search_info:\n                        raise KeyError(f\"search {searchid} not found\")\n\n            route_params = {\n                \"searchid\": search_info.id,\n                \"z\": \"{z}\",\n                \"x\": \"{x}\",\n                \"y\": \"{y}\",\n                \"tileMatrixSetId\": tileMatrixSetId,\n            }\n            if tile_scale:\n                route_params[\"scale\"] = tile_scale\n            if tile_format:\n                route_params[\"format\"] = tile_format.value\n\n            tiles_url = self.url_for(request, \"tile\", **route_params)\n\n            qs_key_to_remove = [\n                \"tilematrixsetid\",\n                \"tile_format\",\n                \"tile_scale\",\n                \"minzoom\",\n                \"maxzoom\",\n                \"layer\",\n            ]\n            qs = [\n                (key, value)\n                for (key, value) in request.query_params._list\n                if key.lower() not in qs_key_to_remove\n            ]\n\n            if layer:\n                config = search_info.defaults.get(layer)\n                if not config:\n                    raise HTTPException(status_code=404, detail=f\"Invalid {layer} configuration.\")\n\n                # This assume the default configuration follows the endpoint expected format\n                # as `\"true_color\": [(\"assets\", \"B4\"), (\"assets\", \"B3\"), (\"assets\", \"B2\")]`\n                qs = QueryParams(config)\n\n            if qs:\n                tiles_url += f\"?{urlencode(qs)}\"\n\n            minzoom = _first_value([minzoom, search_info.metadata.minzoom], tms.minzoom)\n            maxzoom = _first_value([maxzoom, search_info.metadata.maxzoom], tms.maxzoom)\n            bounds = _first_value(\n                [search_info.input_search.get(\"bbox\"), search_info.metadata.bounds],\n                tms.bbox,\n            )\n            return {\n                \"bounds\": bounds,\n                \"minzoom\": minzoom,\n                \"maxzoom\": maxzoom,\n                \"name\": search_info.metadata.name or search_info.id,\n                \"tiles\": [tiles_url],\n            }\n</code></pre>"},{"location":"advanced/metadata/","title":"Mosaic metadata specification","text":"<p><code>TiTiler-PgSTAC</code> uses PgSTAC search to host mosaic parameters for performance purposes. To help users we added the possibility to add <code>metadata</code> to search entries and in <code>TiTiler-PgSTAC</code> we introduced a <code>non-official</code> specification to help user storing meaningful informations.</p>"},{"location":"advanced/metadata/#specification","title":"Specification","text":"<pre><code>{\n    // OPTIONAL. Default: \"mosaic\" (No other value accepted for now). Describe the `type` of metadata.\n    \"type\": \"mosaic\",\n\n    // OPTIONAL. Default: null.\n    // The maximum extent of available map tiles. The bounds are represented in WGS:84\n    // latitude and longitude values, in the order left, bottom, right, top.\n    // Values may be integers or floating point numbers.\n    \"bounds\": [ -180, -85.05112877980659, 180, 85.0511287798066 ],\n\n    // OPTIONAL. Default: null.\n    // An integer specifying the minimum zoom level.\n    \"minzoom\": 0,\n\n    // OPTIONAL. Default: null.\n    // An integer specifying the maximum zoom level. MUST be &gt;= minzoom.\n    \"maxzoom\": 11,\n\n    // OPTIONAL. Default: null. The name can contain any legal character.\n    \"name\": \"compositing\",\n\n    // OPTIONAL. Default: null. An array of available assets.\n    \"assets\": [\"image\", \"cog\"],\n\n    // OPTIONAL. Default: null. A set of `defaults` configuration to be forwarded to the /tiles endpoints.\n    \"defaults\": {\n        \"true_color\": {\n            \"assets\": [\"B4\", \"B3\", \"B2\"],\n            \"color_formula\": \"Gamma RGB 3.5 Saturation 1.7 Sigmoidal RGB 15 0.35\",\n        },\n        \"ndvi\": {\n            \"expression\": \"(B4-B3)/(B4+B3)\",\n            \"rescale\": \"-1,1\",\n            \"colormap_name\": \"viridis\"\n        }\n    }\n}\n</code></pre> <p>Important</p> <ul> <li>When using the <code>/mosaic/register</code> endpoint, <code>{\"type\": \"mosaic\"}</code> will be set by default</li> <li>All metadata fields are optional and custom fields are also allowed.</li> </ul> <pre><code>curl -X 'POST' 'http://127.0.0.1:8081/mosaic/register' -H 'accept: application/json' -H 'Content-Type: application/json' -d '{\"filter\": {\"op\": \"=\", \"args\": [{\"property\": \"collection\"}, \"landsat-c2l2-sr\"]}, \"metadata\": {\"name\": \"landsat mosaic\"}}'\n&gt;&gt; {\n  \"searchid\": \"d7fcdefd0457c949ea7a6192bc2c7122\",\n  \"links\": [\n    {\n      \"rel\": \"metadata\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/d7fcdefd0457c949ea7a6192bc2c7122/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/d7fcdefd0457c949ea7a6192bc2c7122/tilejson.json\"\n    }\n  ]\n}\n\ncurl http://127.0.0.1:8081/mosaic/d7fcdefd0457c949ea7a6192bc2c7122/info | jq '.search.metadata'\n&gt;&gt; {\n  \"type\": \"mosaic\",\n  \"name\": \"landsat mosaic\"\n}\n</code></pre> <pre><code>curl -X 'POST' 'http://127.0.0.1:8081/mosaic/register' -H 'accept: application/json' -H 'Content-Type: application/json' -d '{\"collections\": [\"noaa-emergency-response\"], \"bbox\": [-87.0251, 36.0999, -85.4249, 36.2251], \"filter-lang\": \"cql-json\", \"metadata\": {\"bounds\": [-87.0251, 36.0999, -85.4249, 36.2251], \"minzoom\": 14, \"maxzoom\": 18, \"assets\": [\"cog\"], \"defaults\": {\"true_color\": {\"bidx\": [1, 2, 3]}}}}'\n&gt;&gt; {\n  \"searchid\":\"4b0db3dbd1858d54a3a55f84de97d1ca\",\n  \"links\":[\n    {\n      \"rel\": \"metadata\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/4b0db3dbd1858d54a3a55f84de97d1ca/info\"\n    },\n    {\n      \"rel\": \"tilejson\",\n      \"type\": \"application/json\",\n      \"href\": \"http://127.0.0.1:8081/mosaic/4b0db3dbd1858d54a3a55f84de97d1ca/tilejson.json\"\n    }\n  ]\n}\n\ncurl http://127.0.0.1:8081/mosaic/4b0db3dbd1858d54a3a55f84de97d1ca/info | jq '.search.metadata'\n&gt;&gt; {\n  \"type\": \"mosaic\",\n  \"bounds\": [\n    -87.0251,\n    36.0999,\n    -85.4249,\n    36.2251\n  ],\n  \"minzoom\": 14,\n  \"maxzoom\": 18,\n  \"assets\": [\n    \"cog\"\n  ],\n  \"defaults\": {\n    \"true_color\": {\n      \"bidx\": [\n        1,\n        2,\n        3\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"advanced/mosaic_list/","title":"Mosaic list","text":"<p>Starting with <code>titiler-pgstac&gt;=0.2.0</code>, we've added a <code>/mosaic/list</code> endpoint to be able to list all registered mosaics. When we add a mosaic via <code>/mosaic/register</code> we add a specific <code>metadata.type: \"mosaic\"</code> to the pgstac <code>search</code> entry, which is then used by the <code>/mosaic/list</code> endpoint to filter the pgstac <code>searches</code>.</p> <p>In order to make the mosaic list performant, users might want to alter their PgSTAC database to add an index</p> <pre><code>$ psql\npostgis=# SET schema 'pgstac';\n&gt;&gt; SET\n\npostgis=# CREATE INDEX IF NOT EXISTS searches_mosaic ON searches ((true)) WHERE metadata-&gt;&gt;'type'='mosaic';\n&gt;&gt; NOTICE:  relation \"searches_mosaic\" already exists, skipping\n&gt;&gt; CREATE INDEX\n\npostgis=# SELECT\n    indexname,\n    indexdef\nFROM\n    pg_indexes\nWHERE\n    tablename = 'searches';\n\n&gt;&gt;     indexname    |                                                         indexdef\n&gt;&gt; -----------------+---------------------------------------------------------------------------------------------------------------------------\n&gt;&gt;  searches_pkey   | CREATE UNIQUE INDEX searches_pkey ON pgstac.searches USING btree (hash)\n&gt;&gt;  searches_mosaic | CREATE INDEX searches_mosaic ON pgstac.searches USING btree ((true)) WHERE ((metadata -&gt;&gt; 'type'::text) = 'mosaic'::text)\n</code></pre> <p>ref: github.com/developmentseed/eoAPI/blob/master/stack/handlers/db_handler.py#L204-L213</p>"},{"location":"notebooks/demo/","title":"demo","text":"In\u00a0[1]: Copied! <pre>import json\nimport httpx\nfrom folium import Map, TileLayer, GeoJson\n\nfrom geojson_pydantic import Feature, Polygon\n\nendpoint = \"http://127.0.0.1:8081\"\n\nprint(httpx.get(f\"{endpoint}/healthz\").json())\n</pre> import json import httpx from folium import Map, TileLayer, GeoJson  from geojson_pydantic import Feature, Polygon  endpoint = \"http://127.0.0.1:8081\"  print(httpx.get(f\"{endpoint}/healthz\").json()) <pre>{'database_online': True}\n</pre> In\u00a0[3]: Copied! <pre># bounds of the noaa-eri-nashville2020.json items\nbounds = (-87.0251, 36.0999, -85.4249, 36.2251)\n\npoly = Polygon.from_bounds(*bounds)\ngeojson = Feature(type=\"Feature\", geometry=poly, properties=None).dict(exclude_none=True)\n\nm = Map(\n    tiles=\"OpenStreetMap\",\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=8\n)\n\ngeo_json = GeoJson(\n    data=geojson,\n    style_function=lambda x: {\n        'opacity': 1, 'dashArray': '1', 'fillOpacity': 0, 'weight': 1\n    },\n)\ngeo_json.add_to(m)\nm\n</pre> # bounds of the noaa-eri-nashville2020.json items bounds = (-87.0251, 36.0999, -85.4249, 36.2251)  poly = Polygon.from_bounds(*bounds) geojson = Feature(type=\"Feature\", geometry=poly, properties=None).dict(exclude_none=True)  m = Map(     tiles=\"OpenStreetMap\",     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=8 )  geo_json = GeoJson(     data=geojson,     style_function=lambda x: {         'opacity': 1, 'dashArray': '1', 'fillOpacity': 0, 'weight': 1     }, ) geo_json.add_to(m) m Out[3]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[4]: Copied! <pre>search_request = {\n    # Filter collection\n    \"collections\": [\"noaa-emergency-response\"],\n    # limit bounds of the known items (note: the bbox will also be used in the tilejson response)\n    \"bbox\": bounds,\n    \"filter-lang\": \"cql-json\",\n}\n\nresponse = httpx.post(\n    f\"{endpoint}/mosaic/register\", json=search_request,\n).json()\nprint(response)\n\nsearchid = response[\"searchid\"]\n</pre> search_request = {     # Filter collection     \"collections\": [\"noaa-emergency-response\"],     # limit bounds of the known items (note: the bbox will also be used in the tilejson response)     \"bbox\": bounds,     \"filter-lang\": \"cql-json\", }  response = httpx.post(     f\"{endpoint}/mosaic/register\", json=search_request, ).json() print(response)  searchid = response[\"searchid\"] <pre>{'searchid': '6d436413d0eed760acc2f6bd16ca77a5', 'links': [{'rel': 'metadata', 'type': 'application/json', 'href': 'http://127.0.0.1:8081/mosaic/6d436413d0eed760acc2f6bd16ca77a5/info'}, {'rel': 'tilejson', 'type': 'application/json', 'href': 'http://127.0.0.1:8081/mosaic/6d436413d0eed760acc2f6bd16ca77a5/tilejson.json'}]}\n</pre> In\u00a0[5]: Copied! <pre>response = httpx.get(f\"{endpoint}/mosaic/list\").json()\nprint(\n    [\n        search[\"search\"][\"hash\"]\n        for search in response[\"searches\"]\n    ]\n)\n</pre> response = httpx.get(f\"{endpoint}/mosaic/list\").json() print(     [         search[\"search\"][\"hash\"]         for search in response[\"searches\"]     ] ) <pre>['b2b4e952ae7a8dd69cd11d595b398945', '6d436413d0eed760acc2f6bd16ca77a5']\n</pre> In\u00a0[6]: Copied! <pre>info_response = httpx.get(f\"{endpoint}/mosaic/{searchid}/info\").json()\nprint(info_response)\n</pre> info_response = httpx.get(f\"{endpoint}/mosaic/{searchid}/info\").json() print(info_response) <pre>{'search': {'hash': '6d436413d0eed760acc2f6bd16ca77a5', 'search': {'bbox': [-87.0251, 36.0999, -85.4249, 36.2251], 'collections': ['noaa-emergency-response'], 'filter-lang': 'cql-json'}, '_where': \"collection = ANY ('{noaa-emergency-response}')  AND st_intersects(geometry, '0103000020E610000001000000050000004BC8073D9BC155C0696FF085C90C42404BC8073D9BC155C0302AA913D01C42408104C58F315B55C0302AA913D01C42408104C58F315B55C0696FF085C90C42404BC8073D9BC155C0696FF085C90C4240')\", 'orderby': 'datetime DESC, id DESC', 'lastused': '2023-05-24T10:09:15.184690+00:00', 'usecount': 1, 'metadata': {'type': 'mosaic'}}, 'links': [{'rel': 'self', 'type': 'application/json', 'href': 'http://127.0.0.1:8081/mosaic/6d436413d0eed760acc2f6bd16ca77a5/info'}, {'rel': 'tilejson', 'type': 'application/json', 'href': 'http://127.0.0.1:8081/mosaic/6d436413d0eed760acc2f6bd16ca77a5/tilejson.json'}]}\n</pre> In\u00a0[7]: Copied! <pre>tj_response = httpx.get(f\"{endpoint}/mosaic/{searchid}/tilejson.json?assets=cog\").json()\nprint(tj_response)\n</pre> tj_response = httpx.get(f\"{endpoint}/mosaic/{searchid}/tilejson.json?assets=cog\").json() print(tj_response) <pre>{'tilejson': '2.2.0', 'name': '6d436413d0eed760acc2f6bd16ca77a5', 'version': '1.0.0', 'scheme': 'xyz', 'tiles': ['http://127.0.0.1:8081/mosaic/6d436413d0eed760acc2f6bd16ca77a5/tiles/WebMercatorQuad/{z}/{x}/{y}@1x?assets=cog'], 'minzoom': 0, 'maxzoom': 24, 'bounds': [-87.0251, 36.0999, -85.4249, 36.2251], 'center': [-86.225, 36.162499999999994, 0]}\n</pre> In\u00a0[8]: Copied! <pre>m = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=14\n)\n\ngeo_json = GeoJson(\n    data=geojson,\n    style_function=lambda x: {\n        'opacity': 1, 'dashArray': '1', 'fillOpacity': 0, 'weight': 1\n    },\n)\ngeo_json.add_to(m)\n\naod_layer = TileLayer(\n    tiles=tj_response[\"tiles\"][0],\n    attr=\"Mosaic\",\n    min_zoom=14,\n    max_zoom=18,\n    max_native_zoom=18,\n)\naod_layer.add_to(m)\nm\n</pre> m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=14 )  geo_json = GeoJson(     data=geojson,     style_function=lambda x: {         'opacity': 1, 'dashArray': '1', 'fillOpacity': 0, 'weight': 1     }, ) geo_json.add_to(m)  aod_layer = TileLayer(     tiles=tj_response[\"tiles\"][0],     attr=\"Mosaic\",     min_zoom=14,     max_zoom=18,     max_native_zoom=18, ) aod_layer.add_to(m) m Out[8]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[9]: Copied! <pre>search_request = {\n    # Filter collection\n    \"collections\": [\"noaa-emergency-response\"],\n    # limit bounds of the known items (note: the bbox will also be used in the tilejson response)\n    \"bbox\": bounds,\n    \"filter-lang\": \"cql-json\",\n    \"metadata\": {\n        \"bounds\": [-87.0251, 36.0999, -85.4249, 36.2251],  # This is redondant because it's in the bbox filter\n        \"minzoom\": 14,\n        \"maxzoom\": 18,\n        \"assets\": [\"cog\"],\n        \"defaults\": {\n            \"true_color\": {\n                \"bidx\": [1, 2, 3],\n            },\n        },\n    },\n}\n\nresponse = httpx.post(\n    f\"{endpoint}/mosaic/register\", json=search_request,\n).json()\nprint(response)\n\nsearchid = response[\"searchid\"]\n</pre> search_request = {     # Filter collection     \"collections\": [\"noaa-emergency-response\"],     # limit bounds of the known items (note: the bbox will also be used in the tilejson response)     \"bbox\": bounds,     \"filter-lang\": \"cql-json\",     \"metadata\": {         \"bounds\": [-87.0251, 36.0999, -85.4249, 36.2251],  # This is redondant because it's in the bbox filter         \"minzoom\": 14,         \"maxzoom\": 18,         \"assets\": [\"cog\"],         \"defaults\": {             \"true_color\": {                 \"bidx\": [1, 2, 3],             },         },     }, }  response = httpx.post(     f\"{endpoint}/mosaic/register\", json=search_request, ).json() print(response)  searchid = response[\"searchid\"] <pre>{'searchid': '4b0db3dbd1858d54a3a55f84de97d1ca', 'links': [{'rel': 'metadata', 'type': 'application/json', 'href': 'http://127.0.0.1:8081/mosaic/4b0db3dbd1858d54a3a55f84de97d1ca/info'}, {'rel': 'tilejson', 'type': 'application/json', 'href': 'http://127.0.0.1:8081/mosaic/4b0db3dbd1858d54a3a55f84de97d1ca/tilejson.json'}]}\n</pre> In\u00a0[10]: Copied! <pre>tj_response = httpx.get(f\"{endpoint}/mosaic/{searchid}/tilejson.json?assets=cog\").json()\nprint(tj_response)\n</pre> tj_response = httpx.get(f\"{endpoint}/mosaic/{searchid}/tilejson.json?assets=cog\").json() print(tj_response) <pre>{'tilejson': '2.2.0', 'name': '4b0db3dbd1858d54a3a55f84de97d1ca', 'version': '1.0.0', 'scheme': 'xyz', 'tiles': ['http://127.0.0.1:8081/mosaic/4b0db3dbd1858d54a3a55f84de97d1ca/tiles/WebMercatorQuad/{z}/{x}/{y}@1x?assets=cog'], 'minzoom': 14, 'maxzoom': 18, 'bounds': [-87.0251, 36.0999, -85.4249, 36.2251], 'center': [-86.225, 36.162499999999994, 14]}\n</pre> In\u00a0[11]: Copied! <pre>m = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=14\n)\n\ngeo_json = GeoJson(\n    data=geojson,\n    style_function=lambda x: {\n        'opacity': 1, 'dashArray': '1', 'fillOpacity': 0, 'weight': 1\n    },\n)\ngeo_json.add_to(m)\n\naod_layer = TileLayer(\n    tiles=tj_response[\"tiles\"][0],\n    attr=\"Mosaic\",\n    min_zoom=tj_response[\"minzoom\"],\n    max_zoom=tj_response[\"maxzoom\"],\n    max_native_zoom=tj_response[\"maxzoom\"],    \n)\naod_layer.add_to(m)\nm\n</pre> m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=14 )  geo_json = GeoJson(     data=geojson,     style_function=lambda x: {         'opacity': 1, 'dashArray': '1', 'fillOpacity': 0, 'weight': 1     }, ) geo_json.add_to(m)  aod_layer = TileLayer(     tiles=tj_response[\"tiles\"][0],     attr=\"Mosaic\",     min_zoom=tj_response[\"minzoom\"],     max_zoom=tj_response[\"maxzoom\"],     max_native_zoom=tj_response[\"maxzoom\"],     ) aod_layer.add_to(m) m Out[11]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/demo/#titilerpgstac-demo","title":"titiler.PgSTAC Demo\u00b6","text":"<p>This Notebook aims to show the different features provided by titiler.pgstac application</p> <p>In order to run this demo you'll need to have a PgSTAC database and the titiler.pgstac application running. The easiest way to launch them is to use the repo's docker-compose.yml</p> <pre><code>docker-compose up tiler</code></pre>"},{"location":"notebooks/demo/#python-requirements","title":"Python requirements\u00b6","text":"<pre><code>pip install httpx folium pypgstac psycopg psycopg-pool geojson-pydantic</code></pre>"},{"location":"notebooks/demo/#populate-the-pgstac-db-with-data","title":"Populate the PgSTAC db with data\u00b6","text":"<pre><code>$ pypgstac load collections tests/fixtures/noaa-emergency-response.json --dsn postgresql://username:password@localhost:5439/postgis --method insert \n$ pypgstac load items tests/fixtures/noaa-eri-nashville2020.json --dsn postgresql://username:password@localhost:5439/postgis --method insert</code></pre>"},{"location":"notebooks/demo/#register-search-query","title":"Register Search query\u00b6","text":""},{"location":"notebooks/demo/#show-list-of-mosaics","title":"Show list of Mosaics\u00b6","text":""},{"location":"notebooks/demo/#get-search-metadata","title":"Get Search Metadata\u00b6","text":""},{"location":"notebooks/demo/#get-tilejson","title":"Get TileJSON\u00b6","text":"<p>Note: to return a valid tilejson document you'll need to pass either the <code>assets</code> or <code>expression</code> option.</p>"},{"location":"notebooks/demo/#load-tiles","title":"Load tiles\u00b6","text":""},{"location":"notebooks/demo/#register-a-mosaic-with-metadata","title":"Register a Mosaic with Metadata\u00b6","text":""}]}